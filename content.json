{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Tim Chan","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2020-03-19T06:59:53.000Z","updated":"2024-03-26T04:05:49.259Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"About meTim Chen「 Keep exploring 」… 我的价值观 使命（虚）：活着&amp;找到自己的位置&amp;表达自我 愿景（实）：让AI为我工作 待人接物：先德后能 如何不加班：专业+效率，合理评估落地功能，提升效率要学习方法论，善于利用工具；保持专业就要保持持续学习能力。 我的“护城河” 坚持读书 Keep Reading + Buddism 佛学（ 健康：坚持运动 Keep fit + 快乐：冥想，保持好心态 Keep a good attitude） 专业知识：AI + Blockchain PS P图 + 剪辑 Video Edit 电子琴 Electric Piano + 摄影 Photography + 滑板 Skateboarding + Taro Card 塔罗牌 我的时间观 参考IG：桃园市文化市中心 通常人们说时间管理，其实准确来说应该是人的精力管理，所谓时间管理大师，应该称为精力管理大师。 因为不同人的精力在不同时段是不同的，所以应该针对自身的条件制定适合自己的精力时间表。 从方法论的方向出发，一天24小时通常分为8小时的工作时间，8小时的自我分配时间，8小时的睡觉时间。其中除了睡觉时间后，我们正在可以分配的时间是8+8&#x3D;16，然而再除去2小时的吃法和休息时间，我们最终能支配的时间是14小时。 根据【紧急-重要】四象限划分4-3-2-1精力管理法： 划分到小时可以参考如下： 然而我们大多数人并没有在意精力管理，得过且过又一天，通常如下这样： 我爱看的影视剧国内电影 投名状-豆瓣7.7 电视 西游记 (1986)-豆瓣9.7 西游记续集 (2000)-豆瓣9.0 走向共和-豆瓣9.6 大明王朝1566-豆瓣9.8 国际电影 肖申克的救赎-豆瓣9.7 电视 摩登家庭-豆瓣9.5 我爱看的纪录片 大国崛起 (2006)"},{"title":"archives","date":"2023-07-13T03:20:43.000Z","updated":"2023-07-13T03:20:43.494Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"books","date":"2024-01-01T03:20:52.000Z","updated":"2024-04-01T00:50:55.231Z","comments":true,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":"Tim Chen「 Keep exploring 」… 阅读理解其实就是字面理解的2个步骤：阅读+理解。 阅读：通读，了解大意和框架。 理解：细读，分析细节和内涵，加入自己的理解，通常可以写成读书笔记。 在读书籍 4月份review前3个月读的书籍，包括： 刘润，《底层逻辑》，《底层逻辑2》，《胜算》 《原子习惯》，《How to Fail at Almost Everything and Still Win Big》 《the Alchemist-炼金术士》 书名 书本链接 开始日期 完成日期 读书笔记 微精通 豆瓣读书-微精通 2024-03-25 阅读中 Mastering Bitcoin, 3rd Edition 豆瓣读书-Mastering Bitcoin, 3rd Edition 2024-02-26 未开始 下一本读什么 书名 书本链接 开始日期 完成日期 读书笔记 追寻记忆的痕迹 豆瓣读书-追寻记忆的痕迹 未开始 在听书籍 书名 书本链接 开始日期 完成日期 视频链接 读书笔记 洛克菲勒给儿子的38封信 豆瓣读书-洛克菲勒给儿子的38封信 2024-01-21 未听完 b站 youtube &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;我是分界线&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 已读书籍2024 书名 书本链接 开始日期 完成日期 读书笔记 the Alchemist 豆瓣读书-炼金术士 2024-03-26 2024-03-29 How to Fail at Almost Everything and Still Win Big 豆瓣读书-原版，豆瓣读书-中文版 2024-03-10 2024-03-24 粗读完 豆瓣笔记 原子習慣 豆瓣读书-原子習慣 2024-03-10 2024-03-24 粗读完 底层逻辑 豆瓣读书-底层逻辑 2024-01-21 2024-01-27 The World I see-Li Feifei 豆瓣读书-The World I see 2024-01-14 2024-01-20 胜算-刘润 豆瓣读书-胜算 2024-01-14 2024-01-20 底层逻辑2-刘润 豆瓣读书-底层逻辑2 2024-01-01 2024-01-06 2022 书名 书本链接 开始日期 完成日期 读书笔记 陈可辛 自己的路 豆瓣读书-陈可辛 自己的路 2022-10-9 2024-10-16 十年一觉电影梦-李安 豆瓣读书-十年一觉电影梦 2022-10-01 2022-10-07 已读心理书籍2024 书名 书本链接 开始日期 完成日期 读书笔记 成瘾 豆瓣读书-成瘾 2024-02-20 2024-03-08 成瘾始于痛苦，戒瘾终于平衡！ 内心强大比什么都重要 豆瓣读书-内心强大比什么都重要 2024-02-08 2024-02-20 在印度遇見佛陀-常霖法师 谷歌读书-在印度遇見佛陀 2024-01-28 2024-01-29 issue在线阅读 超越生死，李连杰寻找李连杰 谷歌读书-超越生死，李连杰寻找李连杰 2024-01-14 2024-01-20 我的情绪为何总被他人左右 豆瓣读书-我的情绪为何总被他人左右 2024-01-07 2024-01-13 我的情绪为何总被他人左右-读书笔记 已听书籍2024 书名 书本链接 开始日期 完成日期 视频链接 读书笔记 我的人生樣樣稀鬆照樣贏 我的人生樣樣稀鬆照樣贏 2024-03-13 2024-03-13 youtube 豆瓣笔记 2023 书名 书本链接 开始日期 完成日期 视频链接 读书笔记 成瘾 豆瓣读书-成瘾 2023-08-07 2023-08-07 youtube 成瘾始于痛苦，戒瘾终于平衡！ 必看！国内外权谋大戏集合国内 编码 戏目 解说 1 大明王朝1566 豆瓣9.8分，国剧之王！34万字解说全剧《大明王朝1566》！科普历史详析权谋大合集 东哥说剧-Youtube 2 走向共和 一口气看完《走向共和》全集！能坚持下来的都是勇士！ 3 大宅门 万字解说《大宅门》合集！一段苍生沉浮的家国荣辱，一个百年家族的铿锵傲骨！ 4 三国2010 一口气看完4K大型史诗电视剧《新三国演义》完整版，全网最深度，最高清解说，东汉末年，群雄争霸，谁才是真正的英雄？ 5 86版西游记 西游记续集2000 六小龄童版西游记【古书DVD原盘修复】(25话全) 西游记续集.HDTV 7 87版红楼梦 红楼梦87版 36集全（CCTV4HD） 8 水浒传 一口气看完【水浒传】全网独家最全版本，水浒中每个人物深度解说！ 9 投名状 16年前被骂烂片，如今却被奉为经典？生不逢时的国产神作！《投名状》 国外 编码 戏目 解说 1 权力的游戏 YT-好尸-一口气带你看完史诗巨作【权力的游戏】全八季 全网最详细！爆肝6个月，原剧+小说深度解析！让你一次看爽《权力的游戏》1-8季 2 纸牌屋 《纸牌屋》精讲全集"},{"title":"categories","date":"2023-07-13T03:21:07.000Z","updated":"2023-07-13T03:21:07.681Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"jokes","date":"2024-02-23T10:59:30.000Z","updated":"2024-03-20T13:22:57.112Z","comments":true,"path":"jokes/index.html","permalink":"http://example.com/jokes/index.html","excerpt":"","text":"段子 我向来三分钟热度，一天有1440分钟，所以因为你，我每天都沸腾480遍. 微博网友 How old are you 怎么老是你？梗 小时候上多了兴趣班，长大以后没兴趣上班。 医生，请问年轻人在职场上适合佩戴什么表？医生：Excel表，下一位！ 我去买生蚝，回家的路上，生蚝全都掉出了袋子，钻到了泥土里，我才知道，蚝喜欢泥（好喜欢你）。 我只有两样事情不行，这也不行，那也不行。 (对女孩)你长得有点像我噢妈，也有点像我家姐，那你可以做我的噢妈家姐（Omakase 日式料理厨师发板）吗？这样我就可以任你摆布了。 我喜欢淋雨，淋雨可以变得更“损”，因为雨后春笋。 我只有两样事情在行，这也在行，那也在行。 毒舌 骗子能骗多久是由傻子决定的。 天晴了，雨停了，你又觉得你行了。 小时候以为人生是一场马拉松，长大后才发现，人生是一场马拉松，但是你是一匹驴。 小时候以为人生是自己创造的，现在悟透了，自己这一生已被权贵所创造。 在这个看脸看钱看爹的世界，努力和奋斗大概是无用的附加品。 吃得苦中苦，伺候人上人。 这个由资本和算法驱动的世界，作为韭菜，连呼吸都被数字化了。 俗话说，人生如棋，但有时候你只是棋盘上的一粒尘埃，连棋子都不如。 无性婚姻的原因，是知道生儿育女的负担和痛苦抵消不了那一瞬间所谓的快感。 猪圈的猪死活都不生育，最焦急的是养猪的人，而不是猪。 繁荣，永远离不开，娼盛。 感悟 对自己说的话 人各有命，上天注定。有人天生为王，有人落草为寇。脚下的路如果不是你自己的选择，那旅途的终点到底在哪，也没人不知道。你会走到哪，碰到谁，都不一定。karma is bitch. 请你不要对结果执着，关心过程、体验经过，生命活在当下也不抗拒改变，才有可能保有最大的收获。 只有自己看不起自己才急着须要向别人证明自己！ 做个“悲观的“乐观主义者！ 我們都是在懵懂的年紀犯錯，在懂得的年紀承受後果。 当我们和现实妥协的时候，我们的青春就结束了✔️ 我们的思想都是代表谁的，是谁传播了，我们为什么相信了？ 许知远：迷茫是常态，痛苦是常态，要接受这个事实。我们不要过度关注和思考这个词，而要trial and error，不断试错，最好能去挑战一个你热爱的且难度高的任务，去完成它。 我们需要追波逐流，理解这个时代，但是我们也需要创造我们的时间，我们的时间是代表着我们的精神价值的东西。 你远比想象中更坚强，更勇敢，更强大！ 小时候总想着想大成为一个有钱人，长大后才发觉自己要变成一个明白人，后来觉悟自已要做一个明白的糊涂人。 凡事根本没有绝对的对与错，还有中间的灰色部分。 去感受害怕的感受，去做害怕的或者讨厌的事情，这才是成长了。 对他人说的话 资本能够存活的基础是太多能够被压榨的基层人们和玩不起的人了。越没资本的人们顾虑越多，所以越认真和越玩不起。 人情社会：人情是人与人之间的感情，社会是一个有规则的集体，人情社会可以解析为人情可以凌驾于规则之上。 中间层的两头理论：上头说了能做决定，下头说了能干活。 匿名戒酒会(AA)的十二步骤 如果一个人不相信上帝，但仍希望参与匿名戒酒会（AA）的十二步骤，可以根据个人的信仰体系和价值观重新解释这些步骤。以下是一种可能的重新解释方式： 承认自己无法控制酒精，以及对酒精的上瘾已经对生活造成了破坏。 相信自己内在的力量、团体的支持力量或者人类的团结力量，可以帮助恢复正常生活。 决定将自己的意志和生活交给这种更大的力量，无论是个人内在的力量、社区的支持还是人类的智慧。 彻底检查并承认自己的缺点和错误，意识到这些缺点和错误是导致酒精成瘾的原因。 诚实地告诉自己和其他人自己的错误，寻求社区支持和理解。 愿意让自己的内在力量、社区的支持或人类的团结力量来改变自己的缺点和错误。 找到被自己的行为伤害的人，并努力弥补，通过行动来改善自己的关系。 制定名单，列出所有受害者，并在可能时进行赔偿，尽力修复受伤害的关系。 持续进行个人的道德审查，并当犯错时立即纠正，意识到自己的行为对他人和自己造成的影响。 通过冥想、思考或与他人的交流来加深与自己内在力量、社区支持或人类的团结力量的联系，以获得智慧和力量。 有了这种精神觉醒后，试图将这种精神原则传递给其他有需要的人，并尽量践行它们在日常生活中的应用，为社区提供支持和帮助。 继续进行这些步骤的实践，以及在自己和其他人身上的精神成长和启蒙，持续改善自己的生活质量和关系。"},{"title":"tags","date":"2023-07-13T03:20:52.000Z","updated":"2023-07-13T03:20:52.860Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"炼金术士5-结语","slug":"认知-修行-平衡/炼金术士5-结语","date":"2024-04-05T06:53:30.000Z","updated":"2024-04-05T06:57:15.825Z","comments":true,"path":"2024/04/05/认知-修行-平衡/炼金术士5-结语/","link":"","permalink":"http://example.com/2024/04/05/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/%E7%82%BC%E9%87%91%E6%9C%AF%E5%A3%AB5-%E7%BB%93%E8%AF%AD/","excerpt":"","text":"Paulo Coelho 保罗·科埃略 夜幕降临时，男孩到达了这座废弃的小教堂。 圣器室里那棵梧桐树还在那里，透过半毁的屋顶仍然可以看到星星。 他记得有一次他和他的羊在那里。 这是一个平静的夜晚……除了梦。 现在他不是和他的羊群在一起，而是带着一把铲子。 他坐在那里看着天空很长时间。 然后他从背包里拿出一瓶酒，喝了一些。 他记得沙漠里的那个夜晚，他和炼金术士坐在一起，看着星星，一起喝酒。 他想到了他走过的许多道路，以及上帝选择向他展示他的宝藏的奇怪方式。 如果他不相信反复做梦的意义，他就不会遇到吉普赛女人、国王、小偷，或者…… 我不可能出错”，他对自己说。 他睡着了，醒来时太阳已经很高了。 他开始挖掘梧桐树的根部。 “你这个老巫师。”男孩对着天空喊道。 “你知道整个事情的经过，你甚至在修道院留下了一点金子，让我可以回到这座教堂。和尚看到我衣衫褴褛地回来，就笑了。你就不能救我一命吗？” “不，”他听到风中的一个声音说道。 “如果我告诉你，你就不会看到金字塔了。它们很漂亮，不是吗？” 男孩微笑着，继续挖。 半小时后，他的铲子碰到了坚硬的东西。 一小时后，他面前出现了一箱西班牙金币。 还有宝石、饰有红白羽毛的金面具、镶有珠宝的石像。 征服的战利品早已被这个国家遗忘，一些征服者也没有告诉他的孩子们。 男孩从包里拿出乌陵和土明。 这两块石头他只用过一次，一次是在一天早上，当时他在市场上。 他的一生，他的道路，一直给他提供了足够的预兆。 他把乌陵和土明放在箱子里。 它们也是他新宝藏的一部分，因为它们提醒着他再也见不到的老国王了。 这是真的; 生活对于那些追求自己命运的人来说确实是慷慨的，男孩想。 然后他想起他必须到达塔里法，这样他才能像他所承诺的那样，将十分之一的财宝交给吉普赛女人。 那些吉普赛人真聪明，他想。 也许是因为他们经常搬家。 风又开始吹了。 那是黎凡特风，来自非洲的风。 它没有带来沙漠的气味，也没有摩尔人入侵的威胁。 相反，它带来了一种他熟悉的香水味，还有一个吻的触感——一个从远处传来的吻，慢慢地，慢慢地，直到落在他的唇上。 男孩笑了。 这是她第一次这样做。 “我来了，法蒂玛”，他说。","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"炼金术士","slug":"炼金术士","permalink":"http://example.com/tags/%E7%82%BC%E9%87%91%E6%9C%AF%E5%A3%AB/"}]},{"title":"Web3概况","slug":"Web3/web3概况","date":"2024-04-05T02:03:30.000Z","updated":"2024-04-05T02:03:06.633Z","comments":true,"path":"2024/04/05/Web3/web3概况/","link":"","permalink":"http://example.com/2024/04/05/Web3/web3%E6%A6%82%E5%86%B5/","excerpt":"","text":"","categories":[{"name":"技能-修行-进步-Web3","slug":"技能-修行-进步-Web3","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Web3/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"炼金术士4-第二章","slug":"认知-修行-平衡/炼金术士4-第二章","date":"2024-04-03T07:38:30.000Z","updated":"2024-04-05T07:30:45.612Z","comments":true,"path":"2024/04/03/认知-修行-平衡/炼金术士4-第二章/","link":"","permalink":"http://example.com/2024/04/03/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/%E7%82%BC%E9%87%91%E6%9C%AF%E5%A3%AB4-%E7%AC%AC%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"Paulo Coelho 保罗·科埃略 1 男孩在水晶商店工作了快一个月了，他心理清楚，这并不是一份能让他开心的工作。 商人整天在柜台后面咕哝着，告诉男孩要小心碎片，不要弄坏任何东西。 但他还是坚持了这份工作，因为商人虽然是个脾气暴躁的老人，但对他很公平。 男孩每卖出一件作品都会得到丰厚的佣金，并且已经可以存一些钱了。 那天早上他算了一笔账：如果继续像以前那样每天干活，他需要一整年才能买几只羊。 “我想为水晶做一个展示柜”，男孩对商人说。 “我们可以把它放在外面，吸引那些经过山脚的人”。 商人回答说：“我以前从来没有吃过。” “人走过，撞到，碎片就会碎”。 “好吧，当我带着我的羊穿过田野时，如果我们遇到一条蛇，其中一些可能会死。但这就是羊和牧羊人的生活”。 商人找到一位想要三块水晶玻璃杯的顾客。 他的销量比以往任何时候都好……仿佛时间回到了过去，当时这条街是丹吉尔的主要景点之一。 顾客离开后，他对男孩说：“生意确实好转了。” “我做得好多了，很快你就可以回到你的羊身边了。为什么要对生活要求更多呢？”。 “因为我们必须对预兆做出反应”，男孩几乎无意识地说。 然后他后悔自己说过的话，因为商人从未见过国王。 老国王曾说过：“这就是所谓的有利原则，初学者的运气。因为生活要你实现你的命运”。 但商人听懂了男孩的话。 男孩出现在店里本身就是一个预兆，随着时间的流逝，钱不断涌入钱箱，他并不后悔雇用了这个男孩。 这个男孩得到的钱比他应得的多，因为商人认为销售额不会很高，所以给了男孩很高的佣金。 他原以为自己很快就会回到羊群身边。 “你为什么想去金字塔？” 他要求摆脱显示器的事务。 “因为我一直听说过它们”，男孩回答道，没有提及他的梦想。 那件宝藏现在只是一段痛苦的回忆，他努力避免去想它。 “我不知道这附近有谁愿意穿越沙漠只是为了看看金字塔”，商人说。 “它们只是一堆石头。你可以在你的后院建造一个”。 “你从来没有梦想过旅行。”男孩说着，转身去接待一位走进商店的顾客。 两天后，商人与男孩谈论了这个展览。 “我不太喜欢改变”，他说。 “你和我不像哈桑，那个富商。如果他买错了，对他影响不大。但我们两个必须忍受我们的错误”。 确实如此，男孩悲伤地想。 “你为什么认为我们应该有这个展示？” “我想更快地回到我的羊身边。当运气站在我们这边时，我们必须利用它，尽可能地帮助它，就像它帮助我们一样。这就是所谓的好感原则。或者初学者的运气”。 商人沉默了一会儿。 然后他说：“先知给了我们《古兰经》，并留给我们一生中要履行的五项义务。最重要的是只相信独一的真主。其他的是每天祈祷五次，在斋月期间禁食 ，并对穷人施舍”。 他停在那里。 当他谈到先知时，他的眼睛里充满了泪水。 他是一个虔诚的人，尽管他非常不耐烦，但他还是想按照穆斯林法律生活。 “第五项义务是什么？” 男孩问道。 “两天前，你说我从来没有梦想过旅行。”商人回答道。 “每个穆斯林的第五项义务是朝圣。我们一生中至少有一次必须参观圣城麦加。 “麦加比金字塔远很多。当我年轻的时候，我只想攒够钱开一家店。我以为有一天我会变得富有，可以去麦加。我开始 赚了一些钱，但我总是舍不得把店留给专人负责，水晶是很娇贵的东西。与此同时，人们一直路过我的店，前往麦加。其中一些是富有的朝圣者， 带着仆人和骆驼乘着商队旅行，但大多数朝圣的人都比我穷。 “所有去那里的人都为此感到高兴。他们把朝圣的标志贴在自家门上。其中一个以补靴子为生的鞋匠说，他已经在这片土地上旅行了将近一年。 沙漠，但当他不得不穿过丹吉尔的街道购买皮革时，他变得更加疲倦”。 “那么，你为什么不现在就去麦加呢？” 男孩问道。 “因为对麦加的思念让我活了下来。这就是帮助我面对这些千篇一律的日子的原因，架子上这些无声的水晶，以及那家可怕的咖啡馆的午餐和晚餐。我担心如果我的梦想 当我意识到这一点时，我就没有理由继续活下去了。 “你梦想着你的羊和金字塔，但你和我不同，因为你想要实现你的梦想。我只想梦想着麦加。我已经想象过一千次穿越沙漠，到达广场 关于圣石，我在允许自己触摸它之前绕着它走了七次。我已经想象过那些会在我身边的人，以及那些在我面前的人，以及我们将分享的对话和祈祷。但是 我担心这一切都会令人失望，所以我宁愿只做梦”。 那天，商人允许男孩建造这个展示架。 并不是每个人都能以同样的方式看到他的梦想成真。 2 又过了两个月，货架给水晶店带来了很多顾客。 男孩估计，如果他再工作六个月，他就可以回到西班牙买六十只羊，然后再买六十只。 不到一年，他的羊群数量就会增加一倍，而且他将能够与阿拉伯人做生意，因为他现在能够说他们奇怪的语言。 自从那天早上在市场上，他就再也没有使用过乌陵和土明，因为埃及现在对他来说就像麦加对商人一样遥远的梦想。 不管怎样，这个男孩对他的工作感到很高兴，并且一直想着有一天他会作为胜利者在塔里法下船。 老国王曾说过：“你必须永远知道自己想要什么”。 男孩知道了，并且现在正在朝着这个目标努力。 也许这是他的财富，因为他来到了那片陌生的土地，遇到了一个小偷，并且不花一分钱就将他的羊群数量增加了一倍。 他为自己感到骄傲。 他学到了一些重要的东西，比如如何处理水晶、无言的语言……以及预兆。 一天下午，他在山顶上看到一个人，抱怨爬了这么远，找不到一个像样的地方喝点东西。 习惯于识别预兆的男孩对商人说道。 “我们把茶卖给爬山的人吧”。 “这附近有很多卖茶的地方”，商家说。 “但是我们可以用水晶玻璃杯出售茶。人们会喜欢茶并想购买水晶玻璃杯。有人告诉我，美丽是男人的最大诱惑者”。 商人没有回应，但那天下午，在祈祷并关门后，他邀请男孩和他坐在一起，分享他的水烟，这是阿拉伯人使用的一种奇怪的烟斗。 “你在找什么？” 老商人问道。 “我已经告诉过你了，我要把我的羊买回来，所以我必须赚钱”。 商人在水烟袋里放了一些新煤，深深地吸了一口气。 “我开这家店已经三十年了。我知道水晶的好坏，以及关于水晶的一切知识。我知道它的尺寸和它的性能。如果我们用水晶来泡茶，这家店就会扩大 ……然后我就必须改变我的生活方式”。 “嗯，这样不是很好吗？” “我已经习惯了，在你来之前，我在想，我在同一个地方浪费了多少时间，而我的朋友们却纷纷离开，要么破产，要么过得比以前更好。 这让我很郁闷。现在看来，情况还不错。商店的大小正是我一直想要的。我不想改变任何东西，因为我不知道如何改变 应对变化。我已经习惯了现在的样子”。 男孩不知道该说什么。 老人继续说道：“你对我来说是真正的祝福。今天，我明白了一些我以前从未见过的事情：每一个被忽视的祝福都会变成诅咒。我的生活中不想要任何其他东西。但你却在强迫我 看看我从未了解过的财富和视野。现在我已经看到了它们，现在我看到了我的可能性有多么巨大，我会比你到来之前感觉更糟。 因为我知道我应该能够完成哪些事情，但我不想这样做”。 幸好我没有对塔里法的面包师说什么，男孩心里想。 太阳开始落山时，他们又继续抽了一会儿烟斗。 他们用阿拉伯语交谈，男孩为自己能够做到这一点感到自豪。 曾经有一段时间，他认为他的羊可以教他关于世界的一切知识。 但他们永远不可能教他阿拉伯语。 世界上可能还有其他事情是羊无法教给我的，男孩一边看着老商人，一边想。 实际上，它们所做的就是寻找食物和水。 也许并不是他们在教我，而是我在向他们学习。 “Maktub”，商人最后说道。 “这意味着什么？” 他回答说：“你必须生为阿拉伯人才能理解。” “但用你们的语言来说，它会像‘它是这样写的’”。 当他扑灭水烟袋中的煤炭时，他告诉男孩他可以开始卖水晶杯里的茶了。 有时，没有办法阻止河流。 3 男人们爬上了山，到达山顶时他们已经累了。 但在那里他们看到了一家水晶店，出售清爽的薄荷茶。 他们进去喝茶，茶装在漂亮的水晶玻璃杯里。 “我妻子从来没有想到过这一点”，一位人士说，他买了一些水晶——那天晚上他正在招待客人，客人们一定会被玻璃器皿的美丽所折服。 另一个人说，用水晶泡茶总是更美味，因为香气得以保留。 第三个说，用水晶杯泡茶是东方的传统，因为它具有神奇的力量。 不久，消息传开，不少人开始爬上山去，一睹这家老字号新花样的店铺的风采。 还有一些卖水晶茶的店也开了，但不是在山顶，生意也很少。 最终，商家不得不再雇用两名员工。 他开始进口大量的茶叶和水晶，他的商店受到了渴望新鲜事物的男男女女的青睐。 就这样，几个月过去了。 4 天亮前男孩就醒了。 距离他第一次踏上非洲大陆，已经过去了十一个月零九天。 他穿着专门为这一天买的白色亚麻阿拉伯服装。 他将头巾放在适当的位置，并用骆驼皮制成的环将其固定。 他穿着新买的凉鞋，默默走下楼梯。 这座城市还在沉睡中。 他给自己准备了一份三明治，喝了一杯水晶玻璃杯里的热茶。 然后他坐在阳光普照的门口，抽着水烟。 他默默地抽烟，什么也不想，听着风的声音带来沙漠的气味。 当他吸完烟后，他把手伸进口袋，坐了一会儿，思考着他取出的东西。 那是一大笔钱。 足够给自己买一百二十只羊、一张回程机票以及从非洲进口产品到自己国家的许可证。 他耐心地等待着商人醒来并开店。 然后两人又去喝茶了。 男孩说：“我今天就走。” “我有钱买羊。你也有钱去麦加”。 老人什么也没说。 “你愿意给我祝福吗？” 男孩问道。 “你帮助了我”。 男人继续泡茶，没有说话。 然后他转向男孩。 “我为你感到骄傲”，他说。 “你给我的水晶店带来了新的感觉。但你知道我不会去麦加。就像你知道你不会买你的羊一样”。 “谁告诉你的？” 男孩吃惊地问道。 “Maktub”老水晶商人说道。 他给了这个男孩祝福。 男孩回到自己的房间，收拾好行李。 他们装满了三个麻袋。 当他离开时，他在房间的角落里看到了他的旧牧羊人的袋子。 它被扎成一团，他已经很长一段时间几乎没有想到过它了。 当他从袋子里拿出夹克，想把它送给街上的某个人时，两块石头掉到了地板上。 乌陵和土明。 这让男孩想起了老国王，他惊讶地意识到自己已经有多久没有想起他了。 近一年来，他一直在不停地工作，只想着攒够钱，以便能够自豪地回到西班牙。 “永远不要停止梦想”，老国王说过。 “遵循预兆”。 男孩抱起乌陵和土明，再次有一种奇怪的感觉，老国王就在附近。 他辛苦工作了一年，预兆是该离开了。 我要回去做以前做过的事，男孩想。 尽管羊没有教我说阿拉伯语。 但羊教会了他一些更重要的东西：世界上有一种人人都能理解的语言，男孩在他试图改善商店里的东西的整个过程中一直在使用这种语言。 这是一种热情的语言，是用爱和目标完成的事情，也是对所相信和渴望的事物的探索的一部分。 丹吉尔不再是一座陌生的城市，他觉得，就像他征服了这个地方一样，他也能征服世界。 老国王曾说过：“当你想要某样东西时，整个宇宙都会齐心协力帮助你实现它”。 但老国王并没有提到任何关于被抢劫的事情，或者关于无尽的沙漠，或者关于那些知道自己的梦想是什么但不想实现它们的人的事情。 老国王没有告诉他金字塔只是一堆石头，也没有告诉他任何人都可以在他的后院建造一座。 他忘了提到，当你有足够的钱去买比你以前拥有的更大的羊群时，你就应该买它。 男孩拿起他的袋子，把它和其他东西放在一起。 他走下楼梯，发现店家正在接待一对外国夫妇，而另外两名顾客则在店里走来走去，用水晶玻璃杯喝着茶。 早上这个时候的活动比平时要多。 从他站的地方，他第一次看到老商人的头发和老国王的头发非常像。 他记得来到丹吉尔的第一天，当他没有东西吃，也无处可去时，糖果小贩的笑容——那笑容也像老国王的笑容。 他想，就好像他来过这里并留下了自己的印记一样。 然而，这些人都没有见过老国王。 另一方面，他说他总是出现来帮助那些试图实现自己命运的人。 他没有和水晶商人告别就离开了。 他不想和其他人一起哭。 他会想念这个地方和他学到的所有美好事物。 不过，他对自己更有信心，觉得自己可以征服世界。 “但我要回到我熟悉的田野，再次照顾我的羊群”。 他很肯定地对自己这么说，但他对自己的决定不再满意。 他为了梦想而努力了整整一年，而这个梦想却在一分钟一分钟地变得不那么重要了。 也许是因为那并不是他真正的梦想。 谁知道呢……也许像水晶商人那样更好：永远不要去麦加，只是一生都想去麦加，他想，再次试图说服自己。 但当他手里握着乌陵和土明时，它们就向他传递了老国王的力量和意志。 纯属巧合——或者也许这是一个预兆，男孩想——他来到了他第一天进入的酒吧。 小偷不在，店主给他端了一杯茶。 我总能回去当牧羊人，男孩想。 我学会了如何照顾羊，而且我没有忘记那是怎么做的。 但也许我再也没有机会去埃及金字塔了。 这位老人穿着黄金胸甲，他知道我的过去。 他确实是一个国王，一个明智的国王。 安达卢西亚的山丘距离酒店只有两个小时的路程，但他和金字塔之间却是一片沙漠。 然而男孩觉得可以用另一种方式来看待自己的处境：他实际上距离他的宝藏又近了两个小时……这两个小时延长到一整年并不重要。 我知道为什么我想回到我的羊群中，他想。 我了解羊； 他们不再是问题，而且可以成为好朋友。 另一方面，我不知道沙漠是否可以成为朋友，而我必须在沙漠中寻找我的宝藏。 如果找不到，我可以随时回家。 我终于有了足够的钱，以及我需要的所有时间。 为什么不？ 他突然感到无比的幸福。 他总能回去当牧羊人。 他总能再次成为一名水晶推销员。 也许世界上还有其他隐藏的宝藏，但他有一个梦想，他遇到了一位国王。 这不会发生在任何人身上！ 当他离开酒吧时，他正在计划。 他记得水晶商人的一位供应商通过穿越沙漠的商队运输他的水晶。 他手里拿着乌陵和土明； 因为这两块石头，他再次踏上了寻宝之路。 “当有人想要实现自己的命运时，我总是在附近”，老国王告诉他。 去供应商的仓库看看金字塔是否真的有那么远需要花多少钱？ 5 英国人坐在一座散发着动物、汗水和灰尘气味的建筑里的长凳上。 它一半是仓库，一半是畜栏。 我从来没想过自己会落到这样的境地，他一边翻阅化学期刊，一边想。 大学十年了，而我却在一个畜栏里。 但他必须继续前进。 他相信预兆。 他一生和所有的研究都旨在寻找宇宙中唯一一种真正的语言。 他首先学习了世界语，然后学习了世界宗教，现在又学习了炼金术。 他知道如何说世界语，他了解所有主要宗教，但他还不是炼金术士。 他揭开了重要问题背后的真相，但他的研究已经把他带到了一个他似乎无法超越的地步。 他曾试图与炼金术士建立关系，但没有成功。 但炼金术士们都是奇怪的人，他们只考虑自己，几乎总是拒绝帮助他。 谁知道呢，也许他们没能发现大师之作——贤者之石的秘密——因此将他们的知识保密。 他已经花掉了父亲留给他的大部分财产，徒劳地寻找贤者之石。 他在世界各地的大型图书馆里花费了大量的时间，购买了所有最稀有和最重要的炼金术书籍。 他在一本书中读到，许多年前，一位著名的阿拉伯炼金术士访问了欧洲。 据说他已经两百多岁了，还发现了贤者之石和长生不老药。 这个故事给英国人留下了深刻的印象。 但如果不是他的一位朋友——从沙漠考古探险回来——告诉他有一个阿拉伯人拥有超凡的力量，他绝不会认为这只是一个神话。 “他住在法尤姆绿洲”，他的朋友说。 “人们说他已经两百岁了，能点金成金”。 英国人无法抑制自己的兴奋。 他取消了所有的承诺，并整理了他最重要的书，现在他坐在一个布满灰尘、散发着臭味的仓库里。 外面，一支巨大的商队正在准备穿越撒哈拉沙漠，并计划途经法尤姆。 我要找到那个该死的炼金术士，英国人想。 动物的气味也变得更容易忍受了。 一个年轻的阿拉伯人也背着行李走了进来，向英国人打招呼。 “你被绑在哪里？” 年轻的阿拉伯人问道。 “我要去沙漠”，那人回答道，然后又继续看书。 他此时不想进行任何谈话。 他要做的就是回顾一下自己这些年所学到的一切，因为炼金术士肯定会对他进行考验。 年轻的阿拉伯人拿出一本书开始阅读。 这本书是用西班牙语写的。 那很好，英国人想。 他的西班牙语比阿拉伯语说得更好，而且，如果这个男孩要去法尤姆，当没有其他重要的事情要做时，就会有人可以说话。 6 男孩说：”真奇怪”，他又一次试着读这本书开头的埋葬场景。”我读这本书已经读了两年了，可我总是读不过前面几页”。即使没有国王的打扰，他也无法集中精力。 他对自己做出的决定仍有一些疑虑。但他明白了一件事：做出决定只是事情的开始。当一个人做出决定时，他就真的跳进了一股强大的洪流，这股洪流将把他带到他最初做出决定时做梦也想不到的地方。 他想，当我决定寻找我的宝藏时，我从未想过我会在一家水晶店工作。加入这支大篷车也许是我的决定，但它的去向对我来说将是一个谜。 旁边的英国人正在看书。他看起来很不友好，男孩进来时他显得很恼火。他们甚至可能成为朋友，但英国人结束了谈话。 男孩合上了书。他觉得自己不想做任何可能让自己看起来像那个英国人的事情。他从口袋里拿出 “乌林 “和 “图母”，开始把玩起来。 陌生人喊道：”Urim and Thummim！” 男孩立刻把它们放回口袋里 他说 “它们不卖” 英国人回答说：”它们不值钱” “它们只是岩石晶体做的，而地球上有数以百万计的岩石晶体。但了解这些东西的人都知道，它们就是乌陵和图母。我不知道世界上还有这种东西”。 男孩说：”它们是一位国王送给我的礼物”。 陌生人没有回答，而是把手伸进口袋，拿出两块和男孩的一样的石头。 “你是说国王吗？”他问。 “我猜你不相信国王会跟我这样的牧羊人说话。”他说，想结束谈话。 “根本不会。牧羊人是第一个认识到国王的人，而其他人却拒绝承认国王。因此，国王与牧羊人交谈并不奇怪”。 他继续说，生怕男孩听不懂他在说什么，”《圣经》里就有。就是这本书教会了我关于乌陵和图母的知识。这些石头是上帝唯一允许的占卜方式。祭司们把它们放在金胸甲里”。 男孩突然很高兴能来到仓库。 “也许这是一个预兆”，英国人半大声地说。 “谁告诉你预兆的？男孩的兴趣与日俱增。 “生活中的一切都是预兆”，英国人说，现在他合上了正在阅读的日记。”有一种通用语言，人人都懂，但早已被遗忘。 我正在寻找这种通用语言，以及其他一些东西。这就是我来这里的原因。我必须找到一个懂得这种通用语言的人。一个炼金术士”。 谈话被仓库老板打断了。 “你们俩走运了”，胖阿拉伯人说。”今天有一支商队要去法尤姆”。 “但我要去埃及”，男孩说。 阿拉伯人说：”法尤姆在埃及”。”你是哪种阿拉伯人？” “这是个好兆头”，英国人在胖阿拉伯人出去后说。”如果可以，我愿意写一本关于幸运和巧合的百科全书。’”他对男孩说，”这不是巧合。 ‘他告诉男孩，他遇到他时手里拿着乌林和图姆，这绝非巧合。他问男孩是否也在寻找炼金术士。 男孩说：”我在找宝藏”，说完他立刻后悔了。 但英国人似乎对此并不重视。 他说：”从某种意义上说，我也是”。 男孩说：”我甚至不知道炼金术是什么”，这时仓库老板叫他们到外面来。 7 “我是大篷车的首领”，一个黑眼睛大胡子说。”我掌握着每个人的生杀大权。沙漠是个反复无常的女人，有时她会把人逼疯”。 那里聚集了近两百人和四百头牲畜–骆驼、马、骡子和鸡。人群中有妇女、儿童，还有一些腰间佩剑、肩上扛着步枪的男人。英国人有几个手提箱，里面装满了书。现场一片嘈杂，领头的人不得不重复了好几遍，大家才听懂他在说什么。 “这里有很多不同的人，每个人都有自己的上帝。但我唯一侍奉的神是真主，我以真主的名义发誓，我将再次竭尽全力战胜沙漠。但我希望你们每个人都以自己信仰的真主起誓，无论如何都要服从我的命令。在沙漠中，不服从命令就意味着死亡”。 人群中传出一阵杂音。每个人都在默默地向自己的上帝起誓。 男孩向耶稣基督发誓。英国人一言不发。杂音持续的时间比简单的宣誓要长。人们也在祈求上天保佑。 军号长鸣，所有人都站了起来。男孩和英国人买了骆驼，他们茫然地爬上骆驼背。男孩为英国人的骆驼感到遗憾，因为它满载着一箱书。 英国人说：”世上没有巧合”，他接着仓库里中断的话题说。”我来这里是因为我的一个朋友听说有一个阿拉伯人……” 但大篷车开始移动，英国人的话已经听不清了。不过，男孩知道他要描述什么：一条神秘的链条将一件事与另一件事联系在一起，正是这条链条让他成为一名牧羊人，让他反复做梦，让他来到非洲附近的一座城市，找到一位国王，为了见到一位水晶商人而被抢劫，以及…… 男孩想，一个人越接近实现自己的命运，命运就越成为他存在的真正理由。 商队向东行进。商队在上午行进，在阳光最强烈的时候停了下来，下午晚些时候又继续前进。男孩很少和英国人说话，他大部分时间都在看书。 男孩默默地观察着动物和人们穿越沙漠的过程。 现在，一切都与他们出发那天完全不同了：那时，到处都是混乱和叫喊声、孩子的哭声和牲畜的嘶叫声，还有向导和商人紧张的命令声。 但是，在沙漠中，只有永恒的风声和牲畜的蹄声。就连向导之间也很少说话。 一天晚上，一个赶骆驼的人说 “我已经穿过这片沙地很多次了” “但沙漠如此辽阔，地平线如此遥远，让人感到自己的渺小，似乎应该保持沉默”。 男孩凭直觉明白了他的意思，即使他从未踏足过沙漠。每当他看到大海或火焰时，他都会沉默不语，为它们的元素力量所折服。 他想，我从羊身上学到了东西，我从水晶身上学到了东西。我也能从沙漠中学到一些东西。它看起来古老而睿智。 风一直没有停过，男孩想起了那天他坐在塔里法的堡垒前，迎面吹来的也是这样的风。这让他想起了他羊群的羊毛……他的羊群现在正在安达卢西亚的田野里寻找食物和水，一如既往。 “它们不再是我的羊了”，他不无怀念地自言自语道。”它们一定已经习惯了新的牧羊人，可能已经忘了我。这很好。 像羊这样的动物，习惯了旅行，就知道要继续前进”。 他想起了商人的女儿，确信她可能已经嫁人了。 也许嫁给了一个面包师，也许嫁给了另一个会读书、能给她讲精彩故事的牧羊人–毕竟，他可能不是唯一的一个。不过，他对骆驼司机的直觉理解让他很兴奋：也许他也在学习一种通用语言，这种语言涉及所有人的过去和现在。他的母亲习惯称之为 “预感”。小男孩开始明白，直觉其实是灵魂突然沉浸在生命的洪流中，所有人的历史都在其中，我们能够知道一切，因为一切都写在那里。 “玛克图布”，男孩说，他想起了那个水晶商人。 沙漠有些地方全是沙子，有些地方则是岩石。如果大篷车被巨石挡住，就得绕过去；如果有大片岩石，就得绕一大圈。如果沙子太细，牲畜的蹄子踩不动，他们就会寻找沙子更厚实的地方。有些地方的地面上还覆盖着干涸湖泊的盐分。骆驼在这些地方逡巡不前，赶骆驼的人不得不下马卸下骆驼。赶骆驼的人自己把货物驮到这种险峻的路面上，然后重新装上骆驼。如果向导生病或死亡，骆驼司机会抽签指定新的向导。 但所有这一切的发生都有一个基本原因：无论绕多少路、做多少调整，大篷车都是朝着同一个罗盘点前进。一旦克服了障碍，大篷车就会回到自己的路线上，瞄准一颗指示绿洲位置的星星。当人们看到那颗星星在清晨的天空中闪耀时，他们就知道自己走对了方向，找到了水、棕榈树、庇护所和其他人。只有那个英国人不知道这一切，他大部分时间都沉浸在看书中。 男孩也有自己的书，在旅途的头几天，他也试着读过。但他发现，观察商队和倾听风声更有趣。当他对骆驼有了更深的了解，并与骆驼建立了感情之后，他就把书扔掉了。虽然小男孩迷信每次翻开这本书都会学到一些重要的东西，但他认为这是不必要的负担。 他与同行的骆驼夫变得友好起来。晚上，当他们围坐在火堆旁时，男孩向赶骆驼的人讲述了他作为牧羊人的冒险经历。 在一次谈话中，赶驼人讲述了自己的生活。 “他说：”我以前住在埃尔-凯鲁姆附近。”我有我的果园，我的孩子，我的生活直到我死都不会改变。有一年，庄稼收成最好的时候，我们都去了麦加。我可以快乐地死去，这让我感觉很好。 “有一天，大地开始颤抖，尼罗河泛滥成灾。我以为这种事只会发生在别人身上，绝不会发生在我身上。我的邻居担心洪水会淹没他们所有的橄榄树，我的妻子担心我们会失去孩子。我以为我拥有的一切都会毁于一旦。 “土地被毁了，我不得不另谋生计。所以现在我是一名骆驼司机。但那场灾难让我明白了安拉的话：如果人们有能力实现自己的需要和愿望，就不必害怕未知。 “我们害怕失去我们所拥有的一切，无论是生命还是财产。但是，当我们明白我们的生命故事和世界历史是由同一双手书写的时候，这种恐惧就会烟消云散”。 有时，他们的商队会与另一支商队相遇。一个大篷车总是有另一个大篷车需要的东西–就好像所有的东西都是由同一只手书写的一样。当他们围坐在篝火旁时，赶骆驼的人交流着关于风灾的信息，讲述着关于沙漠的故事。 有时，神秘的蒙面人会出现，他们是贝都因人，负责沿商队路线进行监视。他们提供有关盗贼和野蛮部落的警告。他们来时悄无声息，走时也是如此，身着只露出眼睛的黑衣。一天晚上，一个骆驼夫来到火堆旁，英国人和男孩正坐在那里。他告诉他们：”有部落战争的传言”。 三人沉默了。男孩注意到，虽然没有人说话，但空气中弥漫着一种恐惧感。他再一次感受到了无言的语言……通用语言。 英国人问他们是否有危险。 骆驼司机说：”一旦进入沙漠，就再也回不去了” “当你无法回头时，你只需担心前进的最佳方式。其余的都取决于真主，包括危险”。 最后，他说了一个神秘的词：”Maktub”。 驼夫走后，男孩对英国人说：”你应该多注意大篷车”。”我们走了很多弯路，但总是朝着同一个目的地前进”。 英国人回答说：”你应该多读些关于这个世界的书”。”在这方面，书籍就像大篷车”。 庞大的人和动物队伍开始加快行进速度。白天总是寂静无声，但现在，就连旅行者们习惯于围炉夜话的夜晚也变得寂静无声。有一天，商队的首领决定不再点火，以免引起人们对商队的注意。 旅行者采用的做法是，晚上把动物围成一圈，一起睡在中间，以抵御夜间的寒冷。领队则在队伍的外围派驻武装哨兵。 一天晚上，英国人无法入睡。他叫来男孩，两人沿着营地周围的沙丘散步。当时正值满月，男孩向英国人讲述了他的故事。 英国人对男孩在水晶店工作后取得的进步非常着迷。 他说：”这是支配一切的原则”。”在炼金术中，它被称为世界之魂。当你全心全意想要得到某样东西时，就是你最接近世界之魂的时候。它总是一种积极的力量”。 他还说，这不仅仅是人类的天赋，地球上的万物都有灵魂，无论是矿物、植物还是动物，甚至只是一个简单的念头。 “地球上的一切都在不断地变化，因为地球是有生命的……它有灵魂。我们是灵魂的一部分，所以我们很少意识到它在为我们工作。但在水晶店里，你可能意识到，就连眼镜也在为你的成功而努力”。 男孩望着月亮和漂白的沙滩，想了一会儿。 他说：”我看着大篷车穿过沙漠”。”商队和沙漠说着同样的语言，正因为如此，沙漠才允许穿越。它将考验商队的每一步，看它是否来得及，如果来得及，我们就能到达绿洲”。 “如果我们中的任何一个人只是凭着个人的勇气加入了大篷车，却不懂这种语言，那么这次旅程会更加艰难”。 他们站在那里望着月亮。 “这就是预兆的魔力”，男孩说。”我见过向导如何解读沙漠的征兆，商队的灵魂如何与沙漠的灵魂对话”。 英国人说：”我最好多关注大篷车”。 男孩说：”我最好读读你的书”。 8 这些书很奇怪 它们谈到了水银、盐、龙和国王，他一点也不懂。但有一个观点似乎在所有书中都重复出现：万物都是一种事物的表现。 在其中一本书中，他了解到炼金术文献中最重要的文字只有寥寥几行，而且被刻在了绿宝石的表面上。 英国人说：”这就是翡翠碑”，他为自己能教这个孩子一些东西而感到自豪。 “那么，我们为什么需要这些书呢？”男孩问。 英国人回答说：”这样我们就能理解那几行字了”，但他似乎并不相信自己所说的话。 男孩最感兴趣的那本书讲述了著名炼金术士的故事。他们毕生致力于在实验室中提纯金属；他们相信，如果将一种金属加热多年，它就会褪去所有的特性，剩下的就是世界之魂。世界之魂使他们能够理解地球上的任何事物，因为它是万物交流的语言。他们把这一发现称为 “主作品”–它既是液体，又是固体。 “你们就不能通过观察人和预兆来理解这种语言吗？”男孩问。 英国人恼怒地回答：”你总是喜欢把一切都简单化”。 “炼金术是一门严肃的学科。每一步都必须完全按照大师们的方法进行”。 男孩了解到，大师作品中的液体部分被称为 “生命之药”，它能治愈所有疾病，还能让炼金术士免于衰老。固体部分被称为 “哲学家之石”。 “英国人说：”要找到哲人之石并不容易。”炼金术士们常年呆在实验室里，观察提纯金属的火焰。他们花了如此多的时间接近火焰，以至于逐渐放弃了世俗的虚荣。他们发现，金属的净化也带来了自身的净化”。 男孩想起了那个水晶商人。他曾说过，男孩清洗水晶碎片是件好事，这样他就能摆脱消极的想法。男孩越来越相信，炼金术可以在日常生活中学习。 “英国人说：”另外，哲人之石还有一个迷人的特性。一小片石头就能把大量金属变成黄金”。 听了这话，男孩对炼金术更加感兴趣了。他想，只要有耐心，就能把所有东西都变成金子。他阅读了许多成功人士的生平： 赫尔维蒂乌斯、埃利亚斯、福尔卡内利和格伯。他们的故事引人入胜：每个人都将自己的命运进行到底。他们旅行，与智者交谈，为难以置信的人创造奇迹，拥有哲人之石和生命之药。 但是，当男孩想学习如何完成大师的工作时，他完全迷失了方向。那里只有图画、编码说明和晦涩难懂的文字。 9 “他们为什么把事情搞得这么复杂？”一天晚上，他问英国人。男孩注意到英国人很烦躁，而且很想念他的书。 他说：”这样那些有责任理解的人才能理解”。 “想象一下，如果每个人都去把铅变成金子。黄金就会失去价值。 “只有那些坚持不懈、愿意深入研究事物的人，才能达到大师的境界。这就是我来到沙漠中央的原因。我在寻找一位真正的炼金术士，他能帮我破译密码”。 “这些书是什么时候写的？”男孩问。 “许多世纪以前”。 “那时候还没有印刷术”，男孩争辩道。”每个人都不可能知道炼金术。他们为什么用这么奇怪的语言，画这么多图画？” 英国人没有直接回答他。他说，在过去的几天里，他一直在关注商队是如何运作的，但他并没有学到什么新东西。他唯一注意到的是，关于战争的讨论越来越频繁。 10 有一天，男孩把书还给了英国人。英国人问：”你学到什么了吗？”他急切地想知道是什么。他需要找人倾诉，以避免考虑战争的可能性。 “我知道了世界是有灵魂的，谁理解了灵魂，谁就能理解事物的语言。我了解到，许多炼金术士实现了自己的命运，最终发现了世界之魂、哲人之石和生命之药。 “但最重要的是，我了解到这些东西都非常简单，甚至可以写在翡翠的表面”。 英国人失望了。多年的研究、神奇的符号、奇怪的文字和实验室设备……这些都没有给男孩留下深刻的印象。 他想，他的灵魂一定太原始了，无法理解这些东西。 他拿回自己的书，重新装进书包里。 “回去看商队吧”，他说。”那也没教会我什么”。 男孩继续沉思，沉思沙漠的寂静，沉思动物扬起的沙子。”每个人都有自己的学习方法”，他自言自语道。”他的方式和我的不一样，我的方式和他的也不一样。但我们都在寻找自己的命运，我尊重他这一点”。 11 商队开始日夜兼程。蒙面贝都因人越来越频繁地出现，骆驼司机–他已成为男孩的好朋友–解释说，部落之间的战争已经开始了。骆驼队能到达绿洲就已经很幸运了。 牲畜们已经筋疲力尽，男人们之间的交谈也越来越少。寂静是这个夜晚最可怕的一面，骆驼的呻吟声–以前只是骆驼的呻吟声–现在让每个人都感到害怕，因为这可能预示着一场突袭。 不过，骆驼司机似乎并不太在意战争的威胁。 他对男孩说：”我还活着。”一天晚上，他们吃了一串椰枣，没有火，也没有月亮。”当我吃饭的时候，我想的就是这个。如果我在行军，我就专心行军。如果我必须战斗，那也是和其他日子一样的好日子。 “因为我既不活在过去，也不活在未来。我只对现在感兴趣。如果你能始终专注于现在，你就会成为一个快乐的人。你会发现沙漠中也有生命，天上也有星星，部落成员也会战斗，因为他们也是人类的一部分。生活对你来说将是一场狂欢，一个盛大的节日，因为生活就是我们此刻的生活”。 两天后的晚上，当男孩准备睡觉时，他在寻找他们每晚追随的那颗星星。他觉得地平线比原来低了一些，因为他似乎看到了沙漠上的星星。 骆驼司机说：”那是绿洲”。 “男孩问：”那我们为什么不现在就去呢？ “因为我们要睡觉。 12 太阳升起时，男孩醒了过来。在他面前，前一天晚上小星星所在的地方，是一排无边无际的椰枣树，横跨整个沙漠。 “我们成功了！”也早早醒来的英国人说。 但男孩却很安静。他在沙漠的寂静中找到了家的感觉，他只想看看这些树。要到达金字塔，他还有很长的路要走，总有一天，这个早晨会成为回忆。但这就是当下–骆驼司机提到的聚会–他想活出当下，就像活出过去的教训和未来的梦想一样。虽然椰枣树的景象终有一天会成为回忆，但现在它代表着阴凉、水和躲避战争的庇护所。昨天，骆驼的呻吟预示着危险，而现在，一排椰枣树可能预示着奇迹。 男孩想，世界会说多种语言。 13 炼金术士看着成百上千的人和动物来到绿洲，心想：时代匆匆而过，商队也是如此。人们对着新来的人大喊大叫，尘土遮住了沙漠的阳光，绿洲上的孩子们因为陌生人的到来而兴奋不已。炼金术士看到部落酋长们向商队首领问好，并与他进行了长时间的交谈。 但这些对炼金术士来说都不重要。他已经见过许多人来人往，沙漠依然如故。他见过国王和乞丐在沙漠中行走。沙丘在风的吹拂下不断变化，但这些沙丘还是他从小就熟悉的沙丘。他总是喜欢看到旅行者在经历了数周的黄沙和蓝天之后，第一次看到椰枣树的绿色时所体验到的快乐。他想，也许上帝创造沙漠就是为了让人类欣赏椰枣树。 他决定专注于更实际的事情。他知道大篷车里有一个人，他要把自己的一些秘诀传授给他。预兆就是这么告诉他的。他还不认识那个人，但当他出现时，他那双练达的眼睛会认出他来。 他希望这个人和他之前的徒弟一样能干。 他想，我不明白为什么这些东西要通过口口相传。这并不完全是因为它们是秘密；上帝把他的秘密轻易地透露给了他的所有造物。 对于这个事实，他只有一个解释：事物之所以要以这种方式传播，是因为它们是由纯粹的生命构成的，而这种生命是无法用图画或文字记录下来的。 因为人们迷恋图画和文字，最终忘记了世界的语言。 14 小男孩简直不敢相信眼前的景象：绿洲并不像他曾经在地理书上看到的那样，只是几棵棕榈树环绕的一口井，而是比西班牙的许多城镇都要大得多。这里有三百口井，五万棵椰枣树，还有数不清的彩色帐篷分布其中。 英国人说：”这看起来就像《一千零一夜》”，他迫不及待地想见到炼金术士。 他们被孩子们团团围住，好奇地打量着陆续到来的动物和人们。绿洲上的男人们想知道他们是否看到了任何战斗，妇女们则相互争抢着商人们带来的布匹和宝石。沙漠的寂静就像一个遥远的梦境；商队中的旅行者们不停地交谈着，欢笑着，叫喊着，仿佛他们从精神世界中走了出来，发现自己又回到了人世间。他们如释重负，心情愉悦。 在沙漠中，他们一直小心翼翼地提防着，但骆驼司机向男孩解释说，绿洲一直被认为是中立地带，因为那里的居民大多是妇女和儿童。沙漠里到处都有绿洲，但部落成员在沙漠里打仗，把绿洲当作避难所。 好不容易，商队的首领把所有的人召集到一起，向他们下达了指示。在部落之间的冲突结束之前，他们必须留在绿洲上。由于他们是来访者，他们必须与居住在那里的人共享生活空间，并将获得最好的住宿条件。这就是好客之道。然后，他要求所有人，包括他自己的哨兵，将武器交给部落酋长指定的人。 首领解释说：”这是战争规则”。”绿洲不得庇护军队或部队”。 令男孩惊讶的是，英国人从包里拿出一把镀铬左轮手枪，交给了收缴武器的人。 “为什么是左轮手枪？”他问。 英国人回答说：”它帮助我信任别人”。 与此同时，男孩思考着他的宝藏。他的梦想越接近实现，事情就变得越困难。老国王所说的 “初学者的运气 “似乎不再起作用了。在追求梦想的过程中，他的毅力和勇气不断受到考验。因此，他不能草率，也不能急躁。如果他冲动地向前冲，就会看不到上帝在他的道路上留下的征兆和预言。 上帝把它们放在我的道路上。他的这一想法让自己大吃一惊。在此之前，他一直认为预兆是这个世界的东西。比如吃饭、睡觉，比如寻找爱情、寻找工作。他从未想过这些预兆是上帝用来指示他该做什么的语言。 他反复对自己说：”不要急躁”。”就像骆驼司机说的：’该吃的时候就吃，该走的时候就走。该走的时候就走’”。 第一天，每个人都累得睡着了，包括那个英国人。男孩被分配到一个离他朋友很远的地方，和其他五个年龄相仿的年轻人住在一个帐篷里。 他们都是沙漠里的人，吵着要听他讲大城市的故事。 男孩向他们讲述了自己的牧羊人生活，正准备讲述自己在水晶店的经历时，英国人走进了帐篷。 “我找了你一上午”，他边说边把男孩领到外面。”我需要你帮我找到炼金术士的住处。 首先，他们试图自己找到他。炼金术士的生活方式可能与绿洲上的其他人不同，很可能在他的帐篷里有一个持续燃烧的炉子。他们四处寻找，发现绿洲比他们想象的要大得多，有上百个帐篷。 英国人说：”我们几乎浪费了一整天的时间”，他和男孩在一口水井旁坐了下来。 “也许我们最好找个人问问”，男孩建议道。 英国人不想告诉别人他来到绿洲的原因，也拿不定主意。但最后，他同意让这个阿拉伯语说得比他好的男孩这样做。男孩走近一位来井边给羊皮装水的妇女。 “下午好，女士。我想知道炼金术士住在绿洲的什么地方。 女人说她从未听说过有这样一个人，便匆匆离开了。但在她离开之前，她建议男孩最好不要试图和穿黑衣服的女人交谈，因为她们都是已婚妇女。他应该尊重传统。 英国人很失望。看来他的长途跋涉是白费了。 男孩也很难过；他的朋友正在追寻自己的命运。而且，当一个人有了这样的追求，整个宇宙都会努力帮助他成功–老国王是这么说的。他的话不会错。 男孩说：”我以前从未听说过炼金术士”。”也许这里也没有人听说过”。 英国人眼睛一亮 “就是这样！也许这里没有人知道什么是炼金术士！ 找出为人们治病的人！” 几个身穿黑衣的妇女来到井边取水，但尽管英国人坚持，男孩却不跟她们说话。这时，一个男人走了过来。 “你知道这里有谁能治好人们的病吗？”男孩问道。 “真主能治好我们的病”，男人说，显然他被陌生人吓坏了。”你们在找巫医”。他说了几句《古兰经》里的经文，然后继续往前走。 另一个男人出现了。他年纪较大，提着一个小桶。男孩重复了他的问题 “阿拉伯人问：”你为什么要找这种人？ “男孩说：”因为我的朋友为了见他已经走了好几个月的路。 “如果绿洲上有这样一个人，他一定是非常强大的人”，老人想了一会儿说。”即使是部落酋长想见他也不行。只有在他同意的情况下。 “等待战争结束。然后跟随商队离开。不要试图进入绿洲的生活”，他说完就走了。 但英国人却兴高采烈。他们走对了路。 最后，一位年轻女子走了过来，她没有穿黑衣服。她肩上背着一个容器，头上蒙着面纱，但脸上没有遮挡。男孩向她打听炼金术士的情况。 那一刻，他似乎觉得时间静止了，世界之魂在他体内涌动。当他注视着她的黑眼睛，看到她的嘴唇在笑与沉默之间徘徊时，他明白了世界语言中最重要的部分–地球上每个人都能在心中理解的语言。那就是爱。它比人类更古老，比沙漠更久远。 每当两双眼睛相遇，就会产生同样的力量，就像他们在井边相遇一样。她笑了，这无疑是一个预兆–他一生都在等待的预兆，却不自知。他在羊群中、在书本里、在水晶中、在寂静的沙漠中寻找的预兆。 这是纯粹的世界之语。它不需要解释，就像宇宙在无尽的时间中穿梭时不需要解释一样。那一刻，男孩的感觉是，他在他生命中唯一的女人面前，而她无需多言，也能意识到这一点。他对此比世界上任何事情都更加确信。 他的父母和祖父母曾告诉他，必须先爱上一个人，真正了解一个人，然后才能承诺。但也许有这种想法的人从来没有学过通用语言。因为，当你懂得了这种语言，你就很容易明白，世界上有一个人在等着你，无论他是在沙漠之中，还是在某个伟大的城市。当这样的两个人相遇，目光交汇，过去和未来都变得不重要。只有那一刻，以及令人难以置信的确定性：阳光下的一切都只由一只手书写。正是这只手唤起了爱，为世界上的每个人创造了孪生灵魂。没有这种爱，人的梦想就没有意义。 马克图布，男孩想。 英国人摇了摇男孩： “来吧，问问她！” 男孩走近女孩，女孩笑了，他也跟着笑了。 “他问道：”你叫什么名字？ “法蒂玛”，女孩转过眼睛说。 “在我的国家，有些女人就叫这个名字。 “这是先知女儿的名字”，法蒂玛说。”侵略者把这个名字带到了各个地方”。这位美丽的姑娘说起入侵者时充满了自豪。 在英国人的追问下，男孩问起了那个能治好人们疾病的人。 她说：”那个人知道世界上所有的秘密”。”他能与沙漠中的精灵交流”。 精灵是善与恶的精灵。女孩指了指南方，表示怪人就住在那里。然后，她把水装满了容器，离开了。 英国人也消失了，去找炼金术士了。男孩在井边坐了很久，他想起有一天在塔里法，炼金术士给他带来了那个女人的香水，他意识到自己在知道她存在之前就已经爱上了她。他知道，对她的爱会让他发现世界上的一切宝藏。 第二天，男孩回到井边，希望能见到那个女孩。出乎他意料的是，英国人就在井边，望着沙漠。 他说：”我等了整个下午和晚上”。”他在夜幕降临时出现了。我告诉他我在寻找什么，他问我是否曾把铅变成金子。我告诉他，这就是我来这里学习的目的。他告诉我应该试着这样做。他只说了一句话：’去试试吧’”。 男孩什么也没说。这个可怜的英国人走了这么远的路，却被告知要重复他已经做了很多次的事情。 他对英国人说：”那就试试吧”。 “这就是我要做的。我现在就开始”。 英国人离开后，法蒂玛来了，她把她的容器装满了水。 男孩说：”我来只想告诉你一件事” “我要你做我的妻子。我爱你”。 女孩放下了容器，水洒了出来。 “我会每天在这里等你。我穿越沙漠，寻找金字塔附近的宝藏，对我来说，战争似乎是一种诅咒。但现在它是一种祝福，因为它把我带到了你身边”。 女孩说：”战争总有一天会结束”。 男孩看着周围的椰枣树。他提醒自己，他曾经是个牧羊人，他还可以再当一次牧羊人。法蒂玛比他的宝藏更重要。 “部落的人总是在寻找宝藏”，女孩说，好像她已经猜到了他在想什么。”沙漠里的女人以部落人为荣”。 她把水倒满后就离开了。 男孩每天都去井边和法蒂玛见面。他向她讲述自己的牧羊生活、国王和水晶店。他们成了朋友，除了和她在一起的那十五分钟，每一天似乎都不会过去。当他在绿洲呆了将近一个月后，商队首领召集所有同行的人开会。 “他说：”我们不知道战争什么时候会结束，所以我们不能继续赶路了。”战斗可能会持续很长时间，甚至几年。双方都有强大的力量，这场战争对两支军队都很重要。这不是一场正义与邪恶之战。当这种战争开始时，持续的时间会比其他战争更长–因为真主在两边”。 人们回到了住的地方，男孩当天下午去见了法蒂玛。他把上午的会面告诉了她。”法蒂玛说：”我们见面的第二天，你告诉我你爱我。然后，你教了我一些关于世界语言和世界灵魂的知识。正因为如此，我成为了你的一部分”。 男孩聆听着她的声音，觉得这比风吹枣树的声音还要动听。 “我在这片绿洲等你很久了。我已经忘记了我的过去，忘记了我的传统，忘记了沙漠里的男人对女人的要求。从孩提时代起，我就梦想着沙漠会给我带来一份美好的礼物。现在，我的礼物到了，就是你”。 男孩想牵起她的手。但法蒂玛的手紧紧抓住水壶的把手。 “你跟我说过你的梦，说过老国王和你的宝藏。你还告诉了我一些预兆。现在，我什么都不怕了，因为正是这些预兆把你带到了我身边。我是你梦想的一部分 你所谓的命运的一部分 “这就是为什么我希望你继续朝着你的目标前进。如果你必须等到战争结束，那就等吧。但如果你必须在那之前离开，那就继续追寻你的梦想。沙丘随风而变，但沙漠永不改变。我们的爱情也将如此。 “玛克图布”，她说。”如果我真的是你梦想的一部分，总有一天你会回来的”。 那天，男孩离开她时很伤心。他想起了他认识的所有已婚牧羊人。他们很难说服自己的妻子，必须去遥远的田野。爱要求他们与所爱的人在一起。 他告诉法蒂玛，在他们下次见面时， 她说：”沙漠带走了我们的人 他们不一定会回来” “我们知道，也习惯了。那些没有回来的人变成了云的一部分，变成了藏在峡谷里的动物的一部分，也变成了来自大地的水的一部分。他们成为万物的一部分……他们成为世界的灵魂。 “有些人回来了 其他女人也很高兴 因为她们相信她们的男人有一天也会回来 我曾经看着那些女人羡慕她们的幸福 现在，我也将成为等待的女人之一。 “我是一个沙漠女人，我为此感到自豪。我希望我的丈夫能像塑造沙丘的风一样自由徜徉。如果有必要，我也会接受这样的事实：他已成为沙漠中云、动物和水的一部分。 男孩去找那个英国人。他想告诉他法蒂玛的事。当他看到英国人在自己的帐篷外建了一个火炉时，他感到非常惊讶。那是一个奇怪的炉子，以木柴为燃料，上面有一个透明的烧瓶在加热。当英国人注视着沙漠时，他的眼睛似乎比看书时更明亮了。 “他说：”这是工作的第一阶段。”我必须分离出硫磺。要想成功完成这项工作，我必须不怕失败。正是因为害怕失败，我才不敢尝试大师的工作。现在，我开始了十年前就可以开始的工作。但我很高兴，至少我没有等上二十年”。 他继续烤火，男孩一直烤到沙漠在夕阳下变成粉红色。他有一种冲动，想走到沙漠中去，看看寂静的沙漠是否能解答他的疑问。 他徘徊了一会儿，一直看到绿洲的椰枣树。他聆听着风声，感受着脚下的石头。在这里或那里，他发现了一个贝壳，并意识到在遥远的年代，沙漠曾是一片海。他坐在石头上，任由地平线催眠自己。他试图将爱与占有区分开来，却无法将两者分开。但法蒂玛是沙漠中的女人，如果说有什么能帮助他理解的话，那就是沙漠。 当他坐在那里思考时，他感觉到头顶上有动静。抬头望去，他看到一对鹰在高空飞翔。 他看着鹰随风飘荡。虽然它们的飞行似乎没有规律可循，但对男孩来说却有一定的道理。只是他不明白这意味着什么。他跟着鸟儿的动作，试图从中读出点什么。 也许这些沙漠鸟儿能向他解释没有所有权的爱的含义。 他觉得困了。在他心里，他想保持清醒，但他也想睡觉。他自言自语道：”我正在学习世界之语，世界上的一切对我来说都开始有意义了……甚至连鹰的飞翔也是如此”。在这种心情下，他庆幸自己恋爱了。他想，当你坠入爱河时，一切都会变得更有意义。 突然，其中一只鹰在空中一个闪身俯冲，攻击另一只鹰。就在这时，男孩的脑海中突然浮现出一个稍纵即逝的画面：一支军队整装待发，骑着马冲向绿洲。这个画面立刻消失了，但却震撼了他。他听人说过海市蜃楼，自己也见过一些：海市蜃楼是一种欲望，由于其强烈，会在沙漠的沙地上显现出来。但他肯定不希望有一支军队入侵绿洲。 他想忘掉这些幻象，继续冥想。他再次尝试把注意力集中在沙漠的粉色阴影和石头上。但他的内心深处有些东西不允许他这样做。 老国王说过，”一定要注意预兆”。男孩回忆起他在幻象中看到的一切，并预感到这一切即将发生。 他站起身，向棕榈树走去。他再次从周围的事物中感受到了许多语言：这一次，沙漠是安全的，绿洲才变得危险。 骆驼司机坐在一棵棕榈树下，正在观察日落。他看到男孩从沙丘的另一边出现。 男孩说：”军队来了”。”我看到了幻象”。 骆驼夫回答说：”沙漠会让人产生幻觉”。 但男孩告诉了他关于鹰的事情：他一直在观察鹰的飞行，突然觉得自己坠入了世界之魂。 骆驼夫明白了男孩的意思。他知道，地球上的任何事物都能揭示万物的历史。你可以翻开一本书的任何一页，也可以观察一个人的手；你可以翻开一张卡片，也可以观察鸟儿的飞翔……无论观察到什么事物，你都能找到与自己当下体验的联系。事实上，这些事物本身并没有揭示出任何东西，只是人们通过观察身边发生的事情，找到了通往世界灵魂的途径。 沙漠中到处都是靠轻松洞察世界灵魂谋生的人。他们被称为先知，妇女和老人对他们充满恐惧。部落成员也很害怕向他们请教，因为如果知道自己注定会死，就不可能在战斗中取得胜利。部落成员更喜欢战斗的滋味，以及不知道结果如何的快感；未来已经被真主写好了，而真主所写的总是为了人类的利益。因此，部落成员只为当下而活，因为当下充满了惊喜，他们必须注意很多事情： 敌人的剑在哪里？ 他的马在哪里？为了活命，下一秒该给敌人怎样的一击？ 驼夫不是战士，他曾向先知们请教过。很多人都说对了，也有一些人说错了。后来，有一天，他找过的最年长的预言家（也是他最害怕的一位）问骆驼司机为什么对未来这么感兴趣。 “他回答说：”嗯……这样我就能做事了。”这样我就能改变那些我不想发生的事情”。 “但这样它们就不会成为你未来的一部分了”，预言家说。 “也许我只是想知道未来，以便为即将发生的事情做好准备”。 预言家说：”如果好事即将来临，那将是一个惊喜”。预言家说：”如果是坏事，而你又提前知道了，那么在坏事发生之前，你就会遭受巨大的痛苦”。 骆驼夫对预言家说：”我想知道未来，因为我是个男人”。 “而男人总是根据未来来生活”。 预言家是投掷树枝的专家；他把树枝扔在地上，然后根据树枝的落点做出解释。那天，他没有投掷。他用一块布把树枝包起来，放回包里。 “他说：”我靠为人们预测未来为生。”我知道树枝的科学原理，也知道如何用树枝穿透一切被书写的地方。在那里，我可以读懂过去，发现已经被遗忘的东西，了解当下的预兆。 “当人们向我咨询时，我并不是在解读未来，而是在猜测未来。 未来属于上帝，只有上帝才会在特殊情况下揭示未来。我是如何猜测未来的呢？根据现在的预兆。秘密就在当下。如果你关注当下，你就能改善当下。 而且，如果你改善了现在，以后的事情也会变得更好。忘掉未来，按照教诲过好每一天，坚信上帝爱他的孩子。 每一天都是永恒的”。 骆驼夫曾问，在什么情况下，上帝会让他看到未来。 他说：”只有当他自己揭示未来的时候。而上帝很少透露未来。当他揭示未来时，只有一个原因：这是一个写好了可以改变的未来”。 骆驼司机想，上帝已经向男孩展示了未来的一部分。他为什么要让这个男孩充当他的工具呢？ “驼夫说：”去和部落酋长们谈谈。”告诉他们军队正在逼近” “他们会嘲笑我的” “他们是沙漠里的人，而沙漠里的人习惯与预兆打交道”。 “那么，他们可能已经知道了”。 “他们现在不关心这个。他们相信，如果他们必须知道真主希望他们知道的事情，会有人告诉他们的。这种情况以前发生过很多次。但这次，那个人就是你”。 男孩想到了法蒂玛。他决定去见部落首领。 15 男孩走近绿洲中心巨大白色帐篷前的守卫。 “我要见酋长们。我带来了沙漠中的预兆”。 守卫没有回答，走进了帐篷，在里面停留了一段时间。当他出来时，身边多了一个身穿白色和金色衣服的年轻阿拉伯人。男孩把他看到的情况告诉了年轻人，年轻人让他在那里等着。他消失在帐篷里。 夜幕降临，各种战斗人员和商人进出帐篷。 篝火一个接一个地熄灭，绿洲变得像沙漠一样寂静。 只有大帐篷里的灯光还亮着。在这段时间里，男孩一直想着法蒂玛，他仍然无法理解与她的最后一次对话。 终于，经过几个小时的等待，守卫让男孩进去了。男孩被里面的景象惊呆了。他怎么也想不到，在茫茫沙漠中，竟然有这样一个帐篷。地上铺着他走过的最漂亮的地毯，帐篷顶上挂着手工锻造的金灯，每盏灯都点着一支蜡烛。部落首领们围成半圆坐在帐篷后面，靠在绣花精美的丝绸坐垫上。仆人们端着装满香料和茶叶的银盘进进出出。其他仆人维持着水烟袋里的火。现场弥漫着甜美的烟味。 这里有八位酋长，但男孩一眼就能看出哪位是最重要的：一位身着白色和金色衣服的阿拉伯人坐在半圆形的中心。 在他身边的是男孩之前交谈过的那个年轻阿拉伯人。 “这个说预兆的陌生人是谁？”一位酋长盯着男孩问道。 男孩回答说：”是我”。他讲述了自己的所见所闻。 “既然沙漠知道我们世世代代都在这里，为什么还要向一个陌生人透露这些事情呢？”另一个酋长说。 “因为我的眼睛还不适应沙漠”，男孩说。”我能看到习惯了沙漠的眼睛可能看不到的东西”。 还因为我知道世界之魂，他心想。 “绿洲是中立之地。没有人会攻击绿洲”，第三个酋长说。 “我只能告诉你我所看到的。如果你们不愿意相信我，也不必做任何事情”。 这些人陷入了热烈的讨论。他们说的是阿拉伯方言，男孩听不懂，但当他要离开时，警卫让他留下。男孩开始害怕起来，预兆告诉他事情不妙。他后悔对骆驼司机说了他在沙漠里看到的事情。 突然，中心的长者露出了不易察觉的微笑，男孩感觉好多了。这位长者并没有参与讨论，事实上，到目前为止他还没有说过一句话。 但男孩已经习惯了 “世界之语”，他能感觉到整个帐篷里都充满了和平的气息。现在，他的直觉告诉他，他的到来是正确的。 讨论结束了。酋长们听着老人的话，沉默了片刻。然后，他转向男孩：这一次，他的表情冷漠而疏远。 “两千年前，在一个遥远的国度，一个相信梦境的人被扔进了地牢，然后被卖成了奴隶”，老人用男孩听得懂的方言说道。”我们的商人买下了那个人，把他带到了埃及。我们都知道，相信梦的人也知道如何解梦。 老人接着说：”当法老梦见瘦牛和肥牛时，我说的这个人把埃及从饥荒中拯救了出来。他的名字叫约瑟夫。他和你一样，也是一个身在异乡的陌生人，他可能和你差不多大”。 他停顿了一下，眼神依然不友善。 “我们始终遵守传统。在那个年代，传统将埃及从饥荒中拯救出来，使埃及人成为最富有的民族。传统教人如何穿越沙漠，教他们的孩子如何结婚。传统说绿洲是中立地带，因为双方都有绿洲，所以都很脆弱”。 老人继续说道，没有人说话。 “但传统还说，我们应该相信沙漠的信息。我们所知道的一切都是沙漠教给我们的”。 老人示意大家起立。会议结束了。水烟熄灭，卫兵们立正站好。男孩准备离开，但老人又开口了： “明天，我们要打破绿洲上任何人不得携带武器的协议。整整一天，我们都要提防敌人。夕阳西下时，人们将再次向我交出武器。敌人每死十个人 你们就能得到一块金子 “但是，除非武器也投入战斗，否则就无法拔出武器。武器就像沙漠一样反复无常，如果不使用，下一次就可能失灵。如果到明天结束时，至少有一件武器还没用过，就会有一件用在你身上”。 男孩离开帐篷时，绿洲上只有满月的光亮。 他离帐篷还有 20 分钟路程，便开始往帐篷走去。 他对发生的一切感到震惊。他已经成功地与世界之魂取得了联系，而现在，这样做的代价可能是他的生命。这是一个可怕的赌注。但是，自从他卖掉羊群去追寻自己的命运那天起，他就一直在做冒险的赌注。而且，正如骆驼司机所说，明天死去并不比其他任何一天死去更糟糕。每一天都是用来度过的，或者是一个人离开这个世界的标志。一切都取决于一个词：”Maktub”。 走在寂静中，他没有任何遗憾。如果他明天就死了，那是因为上帝不愿改变未来。他至少会在穿越海峡、在水晶店工作、在了解沙漠的寂静和法蒂玛的眼睛之后死去。自从很久以前离开家后，他的每一天都过得很充实。如果他明天就死了，他也会比其他牧羊人见得更多，他为此感到自豪。 突然，他听到一声雷鸣，他被一阵从未有过的狂风吹倒在地。周围尘土飞扬，遮住了月亮。在他面前，有一匹巨大的白马，带着惊天动地的尖叫声向他冲过来。 当刺眼的尘埃稍稍落定后，男孩被眼前的景象吓得浑身发抖。骑在马背上的是一个全身黑衣的骑士，左肩上挂着一只猎鹰。他戴着头巾，除了眼睛之外，整张脸都用黑手帕遮住。他似乎是来自沙漠的信使，但他的气势要比普通信使强大得多。 这位奇怪的骑士从马鞍上的剑鞘中抽出一把巨大的弯刀。在月光的照耀下，剑身的钢铁熠熠生辉。 他大声问道：”谁敢解读鹰飞行的意义？”他的话仿佛在法尤姆的五万棵棕榈树中回荡。 男孩说：”是我敢这么做”。他想起了圣地亚哥-马塔莫罗斯的形象，他骑在白马上，蹄下踩着异教徒。这个人看起来一模一样，只是现在角色颠倒了。 他重复道：”是我敢于这样做”，他低下头，接受剑的一击。”许多生命将得到拯救，因为我能够看穿世界之魂”。 剑没有落下。相反，陌生人将剑缓缓放下，直到剑尖触及男孩的额头。剑尖划出了一滴血。 骑士完全动弹不得，男孩也是如此。男孩甚至没有想到要逃跑。在他的内心深处，他感到一种莫名的喜悦：他即将为追寻自己的命运而死去。也是为了法蒂玛。毕竟，预兆是真的。在这里，他与敌人面对面，但不必担心死亡–世界之魂在等着他，他很快就会成为它的一部分。而明天，他的敌人也将成为灵魂的一部分。 陌生人继续用剑指着男孩的额头。”你为什么要读鸟的飞行？” “我只读到了鸟儿想告诉我的东西。它们想拯救绿洲。明天你们所有人都会死，因为绿洲上的人比你们多。 剑依然留在原地。”你凭什么改变真主的旨意？” “安拉创造了军队，也创造了鹰。安拉教我鸟语。一切都出自同一人之手”，男孩回忆着骆驼司机的话说道。 陌生人收回了男孩额头上的剑，男孩感到无比轻松。但他仍然无法逃走。 “小心你的预言”，陌生人说。”有些事情一旦写下，就无法改变”。 “我只看到了一支军队”，男孩说。”我没有看到战斗的结果”。 陌生人似乎对他的回答很满意。但他一直握着剑 “一个陌生人在陌生的地方做什么？” “我在追寻我的命运。这不是你能理解的事情”。 陌生人把剑放进剑鞘，男孩放松了下来。 陌生人说：”我必须考验你的勇气”。”勇气是理解世界语言最基本的品质”。 男孩很惊讶。这个陌生人说的是很少有人知道的事情。 “他继续说道：”即使已经走了这么远，你也不能松懈。”你必须热爱沙漠，但绝不能完全信任它。因为沙漠考验着所有人：它挑战每一步，并杀死那些分心的人”。 他的话让男孩想起了老国王。 “陌生人说：”如果战士们来到这里，而你的头在日落时分还在肩膀上，那就来找我吧。 挥剑的那只手现在还拿着鞭子。战马再次狂奔，扬起一阵尘土。 “你住在哪里？”男孩喊道，骑士骑马离去。 拿鞭子的手指向南方。 男孩遇到了炼金术士。 16 第二天清晨，两千名武装人员散布在法尤姆的棕榈树下。太阳还没升到最高点，地平线上就出现了五百名部落成员。骑兵们从北面进入绿洲，看似是一次和平的远征，但他们的长袍中都藏着武器。当他们到达位于 Al-Fayoum 中心的白色帐篷时，他们收回了弯刀和步枪。他们袭击了一个空帐篷。 绿洲的男人们包围了这些来自沙漠的骑兵，不到半小时，除了一个人之外，所有入侵者都死了。孩子们被关在棕榈树林的另一边，对发生的一切一无所知。妇女们留在帐篷里，祈祷丈夫平安无事，对战斗也一无所知。 如果不是地上的尸体，绿洲上的这一天似乎很平常。 唯一幸免于难的部落成员是营长。当天下午，他被带到部落酋长面前，酋长们问他为什么要违反传统。 指挥官说，他的部下饥渴难耐，连日征战，疲惫不堪，为了能够重返战场，他们决定拿下绿洲。 部落酋长说，他为部落成员感到遗憾，但 “传统 “是神圣的。他判处指挥官死刑，毫无荣誉可言。他没有被刀或子弹杀死，而是被吊死在一棵枯死的棕榈树上，尸体在沙漠的风中扭曲。 部落酋长叫来了男孩，送给他五十块黄金。他重复了埃及约瑟的故事，并请求男孩成为绿洲的顾问。 17 当太阳落山，第一颗星星出现时，男孩开始向南走去。他最终看到了一顶帐篷，一群路过的阿拉伯人告诉男孩，那是一个精灵居住的地方。但男孩还是坐下来等待。 直到月上中天，炼金术士才骑着马出现在眼前。他肩上扛着两只死鹰。 男孩说：”我在这里” 炼金术士回答说：”你不应该在这里”。”还是你的命运把你带到了这里？” “由于部落之间的战争，不可能穿越沙漠。所以我来到了这里”。 炼金术士下了马，示意男孩和他一起进入帐篷。这个帐篷和绿洲的许多帐篷一样。男孩环顾四周，寻找炼金术用的炉子和其他器具，但一个也没看见。帐篷里只有一堆书、一个小灶台和铺着神秘图案的地毯。 “请坐。我们喝点东西，吃点这些鹰”，炼金术士说。 男孩怀疑这就是他前一天看到的那些鹰，但他什么也没说。炼金术士点燃了火，很快帐篷里就飘满了美味的香气。这比水烟的香味更好闻。 “你为什么要见我？”男孩问。 炼金术士回答说：”因为预兆”。”风告诉我你会来，你需要帮助”。 “风说的不是我。是另一个外国人，那个英国人。是他在找你”。 “他还有其他事情要做 但他的方向是对的。他已经开始尝试了解沙漠了” “那我呢？ 炼金术士说：”当一个人真正渴望得到某样东西时，全宇宙都会合力帮助他实现梦想”，他重复了老国王的话。男孩明白了。又有一个人在帮助他实现他的梦想。 “那你是要指导我吗？” “不，你已经知道了你需要知道的一切。我只是为你指明宝藏的方向”。 “但现在有一场部落战争”，男孩重申道。 “我知道沙漠里发生了什么。 “我已经找到了我的宝藏。我有一头骆驼，我有水晶店的钱，我还有 50 块金币。在我自己的国家，我就是个有钱人”。 “但这些都不是金字塔里的”，炼金术士说。 “我还有法蒂玛。她是比我赢得的任何东西都要珍贵的宝藏”。 “她也不是在金字塔里找到的”。 他们默默地吃着饭。炼金术士打开一个瓶子，把红色的液体倒进男孩的杯子里。这是他喝过的最美味的酒。 “男孩问：”这里不是禁止喝酒吗？ 炼金术士说：”进入人嘴里的东西并不邪恶” “从他们嘴里出来的才是邪恶的”。 炼金术士有点畏惧，但当男孩喝下美酒后，他放松了下来。吃完饭后，他们坐在帐篷外，在一轮皎洁的明月下，星星也变得黯淡无光。 炼金术士说：”喝吧，尽情享受。”他注意到男孩感觉更开心了。 “今晚好好休息，就像战士准备战斗一样。记住，心在哪里，宝藏就在哪里。你一定要找到宝藏，这样你一路上学到的一切才有意义。 “明天，卖掉你的骆驼，买一匹马。骆驼是叛徒：它们行走数千步，似乎永不疲倦。然后突然跪下死去。但是马会一点一点地累。你总是知道你能对它们要求多少，它们什么时候会死”。 18 第二天晚上，男孩牵着一匹马出现在炼金术士的帐篷里。炼金术士已经准备好了，他骑上自己的骏马，把猎鹰放在自己的左肩上。他对男孩说：”告诉我沙漠中哪里有生命。只有能看到生命迹象的人才能找到宝藏。 在月亮的照耀下，他们开始在沙地上骑行。我不知道能否在沙漠中找到生命，男孩想。我还不太了解沙漠。 他想对炼金术士这么说，但他害怕那个人。他们到了男孩看到天空中鹰的岩石地方，但现在只有寂静和风声。 男孩说：”我不知道如何在沙漠中找到生命”。”我知道这里有生命，但我不知道去哪里找”。 炼金术士回答说：”生命吸引生命”。 这时，男孩明白了。他松开了马的缰绳，马儿在岩石和沙地上向前奔跑。炼金术士跟着男孩的马跑了将近半个小时。他们再也看不到绿洲的棕榈树，只能看到头顶巨大的月亮，以及月亮从沙漠的石头上反射出的银色光芒。突然，男孩的马无缘无故地慢了下来。 男孩对炼金术士说：”这里有生命”。”我不懂沙漠的语言，但我的马懂得生命的语言。 他们下了马，炼金术士什么也没说。他们慢慢前进，在石头中寻找。炼金术士突然停了下来，弯下腰趴在地上。石头中间有一个洞。炼金术士把手伸进洞里，然后把整个手臂伸进洞里，一直伸到肩膀。那里有东西在动，炼金术士的眼睛–男孩只能看到他的眼睛–随着他的努力而颤动。他的手臂似乎在与洞里的东西搏斗。然后，他做了一个令男孩惊愕的动作，收回手臂，一跃而起。他的手抓住了一条蛇的尾巴。 男孩也跳了起来，但远离了炼金术士。蛇疯狂地挣扎着，发出嘶嘶声，打破了沙漠的宁静。这是一条眼镜蛇，它的毒液可以在几分钟内杀死一个人。 “小心他的毒液”，男孩说。但是，尽管炼金术士已经把手伸进了洞里，肯定已经被咬了，他的表情却很平静。”英国人告诉他：”炼金术士已经两百岁了。他一定知道如何对付沙漠中的蛇。 男孩看着他的同伴走到马前，抽出一把弯刀。他用刀刃在沙地上画了一个圈，然后把蛇放了进去。大蛇立刻放松了下来。 “炼金术士说：”不用担心。”它不会离开圆圈的。你在沙漠中找到了生命，这就是我需要的预兆”。 “为什么这么重要？ “因为金字塔被沙漠包围着”。 男孩不想谈论金字塔。他的心情很沉重，从前一天晚上开始就一直很忧郁。要继续寻找宝藏，就意味着他必须放弃法蒂玛。 炼金术士说：”我将带你穿越沙漠”。 男孩回答说：”我想留在绿洲”。”我找到了法蒂玛，在我看来，她比宝藏更有价值”。 “法蒂玛是沙漠里的女人”，炼金术士说。”她知道男人必须离开才能回来。她已经有了她的宝藏：那就是你。现在，她希望你能找到你要找的东西”。 “如果我决定留下来呢？ “让我告诉你会发生什么 你将成为绿洲的顾问。你有足够的金子买很多羊和骆驼。你会娶到法蒂玛 你们会幸福地生活一年 你将学会热爱沙漠 你将认识五万棵棕榈树中的每一棵 你会观察它们的生长过程 展示世界是如何不断变化的 你们会越来越了解预兆 因为沙漠是最好的老师. “第二年的某个时候，你会想起宝藏的事。预兆会开始不断地提到它，而你会试着忽略它们。你要用你的知识为绿洲和它的居民谋福利。部落酋长们会感激你所做的一切。你的骆驼会给你带来财富和权力 “在第三年，预兆将继续预示你的宝藏和命运 你会在绿洲上走来走去 夜复一夜 法蒂玛会不高兴 因为她会觉得是她打断了你的探索 但你会爱她，她也会回报你的爱。你会记得她从未要求你留下 因为沙漠中的女人知道 她必须等待她的男人 所以你不会责怪她 但很多时候，你走在沙漠的沙地上，会想也许你本可以离开……你本可以更加相信你对法蒂玛的爱。因为让你留在绿洲的 是你自己的恐惧 你可能再也回不来了 到那时，预兆就会告诉你 你的宝藏已经永远埋葬了 “然后，在第四年的某个时候” “预兆会抛弃你” “因为你已经不听预兆了 部落酋长们会看到这一点，你就会被解除顾问职务。但到那时，你就会成为一个富商，拥有许多骆驼和大量商品。你的余生都会知道，你没有追求自己的命运，而现在一切都太晚了。 “你必须明白，爱情永远不会阻止一个人追求自己的命运。如果他放弃了追求，那是因为那不是真爱……那是说着世界语言的爱”。 炼金术士抹去了沙上的圆圈，蛇在岩石间滑走了。 男孩想起了那个一直想去麦加的水晶商人，想起了那个寻找炼金术士的英国人。他想起了那个在沙漠中深信不疑的女人。他眺望着将他带到心爱女人身边的沙漠。 他们骑上马，这次是男孩跟着炼金术士回到绿洲。风把绿洲的声音带到了他们身边，男孩试图倾听法蒂玛的声音。 但那天晚上，当他看着圈中的眼镜蛇时，那个肩上扛着猎鹰的陌生骑士说起了爱情和宝藏，说起了沙漠中的女人和他的命运。 男孩说：”我和你一起去”。他的内心立刻感到平静。 “我们明天日出前出发”，这是炼金术士唯一的回答。 19 男孩度过了一个不眠之夜。黎明前两小时，他叫醒了睡在帐篷里的一个男孩，让他带自己去看看法蒂玛住在哪里。他们来到法蒂玛的帐篷，男孩给了朋友足够的金子买一只羊。 然后，他让朋友走进法蒂玛睡觉的帐篷，叫醒她并告诉她他在外面等着。年轻的阿拉伯人照做了，他得到了足够的金子再买一只羊。 “男孩对年轻的阿拉伯人说：”现在让我们单独待会儿吧。阿拉伯人回到帐篷里睡觉，他为帮助了绿洲的顾问而感到自豪，也为有足够的钱给自己买几只羊而高兴。 法蒂玛出现在帐篷门口。两人走到棕榈树间。男孩知道这违反了传统，但现在这对他来说并不重要。 他说：”我要走了”。”我想让你知道，我会回来的。我爱你，因为……” “什么都别说”，法蒂玛打断了他。”一个人被爱是因为他被爱。爱不需要理由”。 男孩继续说：”我做了一个梦，梦见了一个国王。我卖掉了水晶，穿越了沙漠。因为部落宣战，我来到井边，寻找炼金术士。所以，我爱你，因为整个宇宙合谋帮我找到了你。 两人拥抱在一起。这是两人第一次接触对方。 男孩说：”我会回来的”。 法蒂玛说：”在此之前，我总是满怀憧憬地望着沙漠”。法蒂玛说，”现在，我将满怀希望。我父亲有一天离开了，但他回到了我母亲身边，从那以后，他总是回来”。 她们没有再说什么。他们在棕榈树间又走了一段路，然后男孩把她留在了帐篷门口。 他说：”我会回来的，就像你父亲回到你母亲身边一样”。 他看到法蒂玛的眼睛里充满了泪水。 “你哭了？” “我是沙漠里的女人”，她转过脸说 “但最重要的是，我是个女人”。 法蒂玛回到她的帐篷，天亮后，她出去做她多年来一直做的家务。但一切都变了。那个男孩已经不在绿洲了，绿洲再也不会有昨天那样的意义了。它不再是一个有五万棵棕榈树和三百口水井的地方，朝圣者结束长途跋涉来到这里，松了一口气。从那天起，绿洲对她来说就是一个空旷的地方。 从那天起，沙漠才是最重要的。她每天都会看着沙漠，猜测男孩是跟着哪颗星星去寻找宝藏的。 她要把她的吻随风飘散，希望风能吹到男孩的脸，告诉他她还活着。她在等他，一个女人在等一个寻找宝藏的勇敢男人。从那天起，沙漠对她来说只代表一件事：希望他回来。 20 炼金术士对男孩说：”不要去想你留下了什么”，他们开始骑马穿越沙漠的沙地。”一切都写在世界之魂里，永远留在那里”。 男孩说：”人的梦想是回家，而不是离开”。他已经习惯了沙漠的寂静。 “如果找到的是纯净的物质，就永远不会变质。而且，人们还可以随时回来。如果你发现的只是一瞬间的光亮，就像恒星的爆炸，那么你回来时将一无所获”。 这个人说的是炼金术的语言。但男孩知道，他指的是法蒂玛。 他很难不去想自己留下了什么。沙漠无边无际，单调乏味，让他魂不守舍。男孩还能看到棕榈树、水井和他心爱的女人的脸。他还能看到那个做实验的英国人，看到那个不知不觉中已经成为老师的骆驼夫。男孩想，也许炼金术士从未恋爱过。 炼金术士骑在前面，肩上扛着猎鹰。猎鹰很熟悉沙漠的语言，每当他们停下来，它就会飞去寻找猎物。第一天，他带着一只兔子回来，第二天带着两只鸟回来。 晚上，他们铺开睡具，把火堆藏起来。沙漠的夜晚非常寒冷，随着月相的变化，夜色越来越深。他们持续了一个星期，只说了为避免部落间的战斗而需要采取的预防措施。战争仍在继续，风中不时飘来甜腻腻的血腥味。附近发生过战斗，风声提醒男孩，这里有预兆的语言，随时准备向他展示他的眼睛未能观察到的东西。 第七天，炼金术士决定提前扎营。猎鹰飞去寻找猎物，炼金术士则把自己的水壶给了男孩。 “炼金术士说：”你的旅程就要结束了。”我祝贺你追寻了自己的命运”。 “一路上你什么都没告诉我”，男孩说。”我以为你会教我一些你知道的东西。前不久，我和一个人骑马穿过沙漠，他有关于炼金术的书。但我什么也没学到”。 “学习的方法只有一个”，炼金术士回答道。”那就是行动。你需要知道的一切，都已经在你的旅程中学到了。你只需要再学一样东西”。 男孩想知道那是什么，但炼金术士正在地平线上寻找猎鹰。 “你为什么叫炼金术士？” “因为我就是炼金术士”。 “当其他炼金术士试图炼金却无法成功时，出了什么问题？” 他的同伴回答说：”他们只是在寻找黄金”。”他们在寻找命运的宝藏，却不想真正实现命运。 “我还需要知道什么？”男孩问道。 但炼金术士继续望着地平线。最后，猎鹰带着他们的食物回来了。他们挖了一个洞，在洞里点燃了火，这样就不会看到火光了。 “我是个炼金术士，因为我是个炼金术士”，他边说边准备食物。”我从祖父那里学到了这门科学，祖父又从他父亲那里学到了这门科学，以此类推，一直追溯到世界诞生之时。在那个时代，大师的作品可以简单地写在翡翠上。但人们开始拒绝简单的东西，开始写小册子、解释和哲学研究。他们也开始觉得自己比别人知道更好的方法。然而，翡翠石板至今仍有生命力”。 “翡翠石板上写了什么？”男孩想知道。 炼金术士开始在沙地上画画，不到五分钟就画完了。画着画着，男孩想起了老国王，想起了那天他们相遇的广场；这一切仿佛发生在多年以前。 “炼金术士说完后说：”这就是写在翡翠石板上的东西。 男孩试着读了读沙子上写的东西。 “男孩有点失望地说：”这是一个密码。”这和我在英国人的书里看到的一样。 “不”，炼金术士回答道。”就像那两只鹰的飞行一样，单凭理性是无法理解的。翡翠石碑是通往世界灵魂的直接通道。 “智者们明白，这个自然世界只是天堂的图像和副本。这个世界的存在只是为了保证存在一个完美的世界。上帝创造这个世界，是为了让人们通过其可见之物，了解他的精神教诲和智慧奇观。这就是我所说的行动”。 “男孩问道：”我应该了解翡翠石碑吗？ “也许，如果你在炼金术的实验室里，现在正是研究了解翡翠碑的最佳方法的时候。但你现在身处沙漠。那就沉浸其中吧。沙漠会让你了解这个世界；事实上，地球上的任何东西都能做到这一点。你甚至不需要了解沙漠：你所要做的只是思考一粒沙子，你就会从中看到所有造物的奇迹”。 “我该如何沉浸在沙漠中？” “倾听你的内心。它知道一切，因为它来自世界的灵魂，总有一天它会回到那里”。 21 他们又沉默地穿越沙漠两天。 炼金术士变得更加谨慎，因为他们已经接近了战斗最为激烈的区域。 当他们继续前行时，男孩试图倾听自己的内心。 这并不容易做到。 早些时候，他的心总是准备好讲述自己的故事，但最近却并非如此。 有时候，他的心会花上几个小时诉说自己的悲伤，而另一些时候，他的心在沙漠日出时变得如此激动，以至于男孩不得不隐藏自己的眼泪。 当他对宝藏男孩说话时，他的心跳得最快；而当男孩出神地凝视着沙漠一望无际的地平线时，他的心跳得更慢。 但他的心却从未平静过，哪怕男孩和炼金术士都陷入了沉默。 “为什么我们要倾听自己的内心？” 那天他们什么时候扎营，男孩问道。 “因为，无论你的心在哪里，你都会在那里找到你的宝藏”。 “但我的心很激动”，男孩说。 “它有它的梦想，它会变得情绪化，它对沙漠中的一个女人充满热情。它向我询问一些事情，当我想起她时，它让我无法入睡”。 “嗯，那很好。你的心还活着。继续听它说什么”。 在接下来的三天里，两名旅行者经过了一些武装的部落成员，并在地平线上看到了其他人。 男孩的心里开始充满恐惧。 它告诉他从世界之魂那里听到的故事，人们试图寻找他们的宝藏却从未成功的故事。 有时，男孩会害怕他可能找不到他的宝藏，或者可能会死在沙漠里。 有时，它告诉男孩它很满意：它找到了爱和财富。 “我的心是个叛徒”，当他们停下来休息马匹时，男孩对炼金术士说道。 “它不想让我继续下去”。 “有道理。”炼金术士回答道。 “自然是担心，在追求梦想的过程中，你可能会失去已经赢得的一切”。 “那么，我为什么要听从自己的内心呢？” “因为你将永远无法再让它保持安静。即使你假装没有听到它告诉你的话，它也会永远存在于你的内心，向你重复你对生活和世界的思考”。 “你的意思是我应该听，即使这是叛国？” “背叛是一种意想不到的打击，如果你了解自己的心，它永远不会对你做出这样的事，因为你会知道它的梦想和愿望，并知道如何应对它们。 “你永远无法逃离你的心。所以最好听听它在说什么。这样，你就永远不必担心意外的打击”。 当他们穿越沙漠时，男孩继续倾听自己的心声。 他开始了解它的诡计和诡计，并接受它的本来面目。 他失去了恐惧，忘记了自己需要回到绿洲，因为，有一天下午，他的心告诉他，这是幸福的。 “尽管我有时会抱怨，”它说，“那是因为我是一个人的心，而人们的心也是如此。人们害怕追求他们最重要的梦想，因为他们觉得自己不值得。 ，或者他们将无法实现这些目标。我们，他们的心，一想到永远离开的亲人，或者本可以美好但没有实现的时刻，或者可能已经找到的宝藏，就会感到恐惧 但永远隐藏在沙子里。因为，当这些事情发生时，我们会遭受极大的痛苦”。 一天晚上，当他们抬头仰望没有月亮的天空时，男孩告诉炼金术士：“我的心害怕它会受苦。” “告诉你的心，对痛苦的恐惧比痛苦本身更糟糕。没有一颗心在追寻梦想时受过痛苦，因为追寻的每一秒都是与上帝和永恒的相遇。” “寻找的每一秒都是与上帝的相遇”，男孩告诉自己的内心。 “当我真正寻找我的宝藏时，每一天都是光明的，因为我知道每一个小时都是我找到它的梦想的一部分。当我真正寻找我的宝藏时，我已经 一路上发现了一些事情，如果我没有勇气去尝试牧羊人似乎不可能实现的事情，我永远不会看到这些事情。” 于是他的心安静了整整一个下午。 那天晚上，男孩睡得很沉，当他醒来时，他的心开始告诉他来自天地之魂的事情。 它说所有幸福的人都有上帝在他们里面。 正如炼金术士所说，这种幸福可以从沙漠中的一粒沙子中找到。 因为一粒沙子是一个创造的瞬间，宇宙创造它需要数百万年的时间。 “地球上的每个人都有一个宝藏在等待着他”，他的心说。 “我们，人们的内心，很少谈论那些宝藏，因为人们不再愿意去寻找它们。我们只对孩子们谈论它们。后来，我们只是让生命继续，按照自己的方向，走向自己的命运。 ……但是，不幸的是，很少有人遵循为他们铺就的道路——通向他们的命运和幸福的道路。大多数人将世界视为一个充满威胁的地方，而且，正因为他们这样做，世界才变得确实如此。 一个有威胁的地方。 “所以，我们，他们的内心，说话越来越轻声。我们从未停止说出来，但我们开始希望我们的话不会被听到：我们不希望人们因为不追随自己的内心而受苦 ”。 “为什么人们的内心不告诉他们继续追寻自己的梦想？” 男孩问炼金术士。 “因为那是最让心受苦的东西，而心不喜欢受苦”。 从那时起，男孩就明白了他的心。 他求求你，永远不要停止和他说话。 他要求，当他远离梦想时，他的心会向他施压并拉响警报。 男孩发誓，每次他听到警报时，他都会注意它的信息。 当晚，他将这一切告诉了炼金术士。 而炼金术士也明白，男孩的心已经回到了世界之魂。 “那我现在该怎么办？” 男孩问道。 “继续朝金字塔的方向走。”炼金术士说道。 “并继续留意预兆。你的心仍然能够告诉你宝藏在哪里”。 “这就是我还需要知道的一件事吗？” “不”，炼金术士回答。 “你还需要知道的是：在梦想实现之前，世界之魂会测试一路上学到的一切。它这样做并不是因为它是邪恶的，而是为了让我们除了实现我们的梦想之外，还可以 梦想，掌握我们在实现梦想的过程中所学到的教训。这是大多数人放弃的时刻。正如我们用沙漠语言所说，在这个时刻，一个人“只是渴死了” 当棕榈树出现在地平线上时。 “每一次探索都以初学者的运气开始，每一次探索都以胜利者的严峻考验而结束”。 男孩想起了他国家的一句古老谚语。 据说黎明前是夜晚最黑暗的时刻。 22 第二天，第一个明显的危险迹象出现了。 三名武装的部落成员走近，询问男孩和炼金术士在那里做什么。 “我正在用我的猎鹰狩猎。”炼金术士回答道。 一名部落成员说：“我们必须对你进行搜身，看看你是否携带武器。” 炼金术士慢慢下了马，男孩也跟着下了马。 “你为什么带着钱？” 部落成员搜查了男孩的包后问道。 “我需要它才能到达金字塔”，他说。 部落成员在搜查炼金术士的物品时，发现了一个装满液体的小水晶瓶，以及一个比鸡蛋稍大的黄色玻璃蛋。 “这些是什么东西？” 他问。 “那是贤者之石，也是长生不老药。这是炼金术士的杰作。吞下这种长生不老药的人将永远不会再生病，而那块石头的碎片可以将任何金属变成黄金”。 阿拉伯人嘲笑他，炼金术士也跟着笑。 他们认为他的回答很有趣，并允许男孩和炼金术士带着他们所有的物品继续前进。 “你疯了？” 当他们继续前进时，男孩问炼金术士。 “你出于什么目的这样做？” “向你展示生命中简单的一课。”炼金术士回答道。 “当你内心拥有巨大的宝藏，并试图告诉别人时，很少有人相信你”。 他们继续穿越沙漠。 日子一天天过去，男孩的心越来越安静。 它不再想知道过去或未来的事情；它不再想知道。 它仅仅满足于凝视沙漠，并与来自世界之魂的男孩一起喝酒。 男孩和他的心已经成为朋友，现在谁都无法背叛对方。 当他的心对他说话时，是为了给男孩带来刺激，给他力量，因为沙漠里寂静的日子令人厌倦。 他的内心告诉男孩，他最优秀的品质是什么：他放弃羊群并努力实现自己命运的勇气，以及他在水晶店工作期间的热情。 他的心告诉了他一些男孩从未注意到的事情：它告诉男孩威胁着他的危险，但他从未意识到。 他的心说，有一次它把男孩从父亲那里夺来的步枪藏了起来，因为男孩可能会伤到自己。 这让男孩想起那天他生病了，在田野里吐了出来，然后就陷入了沉睡。 前面有两个小偷正计划偷走男孩的羊并谋杀他。 但是，由于男孩没有经过，他们以为他改变了路线，决定继续前进。 “男人的心总是对他有帮助吗？” 男孩问炼金术士。 “大多数只是那些试图实现自己命运的人的心。但它们也确实帮助了儿童、酒鬼和老人”。 “也就是说，我永远不会遇到危险？” 炼金术士说：“这仅仅意味着心会尽其所能”。 一天下午，他们路过其中一个部落的营地。 营地的每个角落都有穿着漂亮白袍的阿拉伯人，准备好了武器。 这些人抽着水烟袋，交换着战场上的故事。 没有人注意这两个旅行者。 当他们离开营地时，男孩说：“没有危险。” 炼金术士的声音听起来很愤怒：“相信你的心，但永远不要忘记你身处沙漠。当人类彼此交战时，世界之魂可以听到战斗的尖叫声。没有人会不承受后果。” 阳光下的一切”。 万物皆为一，男孩想。 然后，仿佛沙漠想要证明炼金术士是对的，两名骑兵从旅行者身后出现。 其中一人说：“你不能再走得更远了。” “你正处于部落交战的地区”。 “我不会走太远。”炼金术士回答道，直视着骑兵的眼睛。 他们沉默了一会儿，然后同意男孩和炼金术士可以继续前进。 男孩着迷地看着这场交流。 “你用你看待这些骑兵的方式统治了他们”，他说。 “你的眼睛显示出你灵魂的力量”，炼金术士回答。 确实如此，男孩想。 他注意到，在营地的众多武装人员之中，有一个人正目不转睛地盯着两人。 距离太远了，连他的脸都看不清。 但男孩确信他一直在看着他们。 最后，当他们越过绵延整个地平线的山脉时，炼金术士说，他们距离金字塔只有两天的时间了。 “如果我们很快就要分道扬镳，”男孩说，“那就教我炼金术吧。” “你已经了解炼金术了，它是为了穿透世界之魂，发现为你保留的宝藏”。 “不，我不是这个意思。我说的是把铅变成黄金”。 炼金术士像沙漠一样沉默，直到他们停下来吃饭后才回答了男孩。 “宇宙中的一切都是进化的”，他说。 “而且，对于智者来说，黄金是进化最远的金属。不要问我为什么；我不知道为什么。我只知道传统永远是对的。 “人们永远无法理解智者的话。因此，黄金没有被视为进化的象征，而是成为冲突的基础”。 “事物有很多种语言”，男孩说。 “曾经有一段时间，对我来说，骆驼的哀鸣只不过是哀鸣。然后它变成了危险的信号。最后，它又变成了哀鸣”。 但随后他停了下来。 炼金术士可能已经知道这一切了。 “我认识真正的炼金术士”，炼金术士继续说道。 “他们把自己锁在实验室里，试图像黄金一样进化。他们发现了贤者之石，因为他们明白，当某物进化时，该物周围的一切也会进化。 “其他人是偶然发现这块石头的。他们已经拥有了这种天赋，他们的灵魂比其他人的灵魂更容易接受这种东西。但他们不算数。他们非常罕见。 “然后还有其他人，他们只对黄金感兴趣。他们从未找到秘密。他们忘记了铅、铜和铁都有自己的命运要完成。任何干涉其他事物命运的人永远不会发现 他自己”。 炼金术士的话语如同诅咒一般回荡在耳边。 他伸手从地上捡起一枚贝壳。 “这片沙漠曾经是一片海洋”，他说。 “我注意到了，”男孩回答。 炼金术士让男孩把贝壳放在他的耳朵上。 当他还是个孩子的时候，他就做过很多次这样的事，也听过大海的声音。 “海洋在这个壳里继续生存，因为这就是它的命运。而且它永远不会停止这样做，直到沙漠再次被水覆盖”。 他们骑上马，向埃及金字塔的方向策马而去。 23 太阳快落山的时候，男孩的心里响起了危险的信号。 他们周围都是巨大的沙丘，男孩看向炼金术士，看他是否感应到了什么。 但他似乎没有意识到任何危险。 五分钟后，男孩看到两名骑兵在他们前面等候。 还没等他对炼金术士说什么，两名骑士就已经变成了十人，然后是一百人。 然后它们就遍布沙丘中的各个角落。 他们是身着蓝色衣服、头巾周围有黑色环的部落成员。 他们的脸隐藏在蓝色面纱后面，只露出眼睛。 即使距离很远，他们的眼神也能传达出他们灵魂的力量。 他们的眼睛诉说着死亡。 24 两人被带到附近的一个军营。 一名士兵将男孩和炼金术士推进了一个帐篷，酋长正在帐篷里与他的幕僚们开会。 其中一名男子说：“这些是间谍。” “我们只是旅行者”，炼金术士回答。 “三天前有人看到你在敌军营地。你正在与那里的一名士兵交谈”。 炼金术士说：“我只是一个在沙漠中漫步并认识星星的人。” “我没有关于军队或部落活动的信息。我只是在这里为我的朋友充当向导”。 “谁是你朋友？” 酋长问道。 “炼金术士”，炼金术士说道。 “他了解自然的力量。他想向你展示他非凡的力量”。 男孩静静地听着。 而且很害怕。 “一个外国人在这里做什么？” 另一个人问道。 “他带来了钱要捐给你们的部落。”炼金术士在男孩开口之前说道。 炼金术士抓起男孩的包，把金币交给了酋长。 阿拉伯人一言不发地接受了他们。 那里的钱足够买很多武器了。 “什么是炼金术士？” 最后他问道。 “他是一个了解自然和世界的人。如果他愿意，他可以用风的力量摧毁这个营地”。 男人们笑了。 他们已经习惯了战争的摧残，知道风无法给他们致命一击。 但每个人都感觉自己的心跳加快了一些。 他们是沙漠人，他们害怕巫师。 “我想看到他这么做，”酋长说。 “他需要三天”，炼金术士回答。 “他要把自己变成风，只是为了展示他的力量。如果他做不到，我们谦卑地为你献上我们的生命，为了你部落的荣誉”。 “你不能给我已经属于我的东西”，酋长傲慢地说。 但他给了旅行者三天的时间。 男孩吓得浑身发抖，但炼金术士把他扶出了帐篷。 “别让他们看出你害怕”，炼金术士说道。 “他们是勇敢的人，他们鄙视懦夫”。 但男孩连话都说不出来。 只有当他们穿过营地的中心之后，他才能够这样做。 没有必要监禁他们：阿拉伯人只是没收了他们的马匹。 于是，世界再一次展示了它的多种语言：就在不久前，沙漠还是一望无际、自由自在的，而现在，它已是一堵坚不可摧的墙。 “你给了他们我的一切！” 男孩说。 “我这辈子攒下来的一切！” “好吧，如果你必须死的话，对你有什么好处呢？” 炼金术士回答道。 “你的钱救了我们三天。钱救人的命并不常见”。 但男孩太害怕了，不敢听智慧的话。 他不知道要如何将自己变成风。 他不是炼金术士！ 炼金术士向其中一名士兵要了一些茶，并倒了一些在男孩的手腕上。 一阵松了一口气的感觉涌上心头，炼金术士咕哝了一些男孩听不懂的话。 “不要屈服于你的恐惧”，炼金术士用一种奇怪的温柔的声音说道。 “如果你这样做，你将无法说出自己的内心”。 “但我不知道如何让自己变成风”。 “如果一个人正在实现自己的命运，他就知道他需要知道的一切。只有一件事使梦想无法实现：对失败的恐惧”。 “我不怕失败，只是不知道如何让自己变成风”。 “好吧，你必须学习；你的生活取决于它”。 “但如果我不能呢？” “然后你就会在努力实现自己命运的过程中死去。这比像其他数百万人一样死去要好得多，他们甚至不知道自己的命运是什么。 “但是别担心，”炼金术士继续说道。 “通常死亡的威胁会让人们更加意识到自己的生活”。 25 第一天过去了。 附近发生了一场大战，一些伤员被带回了营地。 死去的士兵被其他人取代，生活还在继续。 死亡并不能改变任何事情，男孩想。 “你以后可能会死”，一名士兵对着他的一名同伴的尸体说道。 “在宣布和平后，你可能已经死了。但是，无论如何，你都会死”。 一天结束时，男孩去寻找炼金术士，炼金术士把他的猎鹰带到了沙漠中。 “我还是不知道如何把自己变成风”，男孩重复道。 “记住我告诉过你的话：世界只是上帝可见的一面。炼金术所做的就是将精神完美与物质层面联系起来”。 “你在干什么？” “喂我的猎鹰”。 “如果我不能把自己变成风，我们就会死。”男孩说。 “为什么要喂你的猎鹰？” 炼金术士说：“你可能会死。” “我已经知道如何把自己变成风了”。 26 第二天，男孩爬到了营地附近的悬崖顶上。 哨兵放他走了。 他们已经听说过那个能把自己变成风的巫师了，他们不想靠近他。 无论如何，沙漠是无法通行的。 第二天的整个下午，他都在眺望沙漠，倾听自己的内心。 男孩知道沙漠感受到了他的恐惧。 他们都说同一种语言。 27 第三天，酋长会见了他的军官。 他把炼金术士叫到了会场，说道：“我们去看看那个把自己变成风的男孩吧”。 “我们走吧”，炼金术士回答道。 男孩带着他们去了前一天他去过的悬崖。 他吩咐大家坐下。 男孩说：“这需要一段时间。” “我们不着急”，酋长回答道。 “我们是沙漠里的人”。 男孩看着地平线。 远处有山。 还有沙丘、岩石和植物，它们坚持生活在看似不可能生存的地方。 那是他流浪了好几个月的沙漠； 尽管这么长时间，他只知道其中的一小部分。 在那一小块地方，他发现了一个英国人、商队、部落战争，以及一片拥有五万棵棕榈树和三百口井的绿洲。 “你今天来这里想做什么？” 沙漠问他。 “你昨天看我的时间还不够多吗？” “你在某个地方抱着我爱的人”，男孩说。 “所以，当我眺望你的沙子时，我也在看着她。我想回到她身边，我需要你的帮助，这样我才能把自己变成风”。 “什么是爱？” 沙漠问道。 “爱是猎鹰在你的沙滩上飞翔。因为对他来说，你是一片绿色的田野，他总是带着猎物从那里回来。他了解你的岩石、你的沙丘和你的山脉，而你对他很慷慨”。 “猎鹰的喙承载着我的一部分，我自己”，沙漠说道。 “多年来，我一直关心他的比赛，用我仅有的一点水喂它，然后我向他展示比赛的情况。 有一天，当我享受他的游戏在我的表面蓬勃发展的事实时，猎鹰从天空中俯冲而下，带走了我所创造的东西”。 “但这就是你创造这个游戏的初衷”，男孩回答道。 “滋养猎鹰。然后猎鹰滋养人类。最终，人类将滋养你的沙子，那里的游戏将再次蓬勃发展。这就是世界的发展方式”。 “那么，这就是爱情吗？” “是的，这就是爱。它让游戏变成了猎鹰，猎鹰变成了人，而人又变成了沙漠。它让铅变成了金子，又让金子回归了大地”。 “我听不懂你在说什么”，沙漠说道。 “但你至少可以明白，在你的沙子里的某个地方，有一个女人在等我。这就是为什么我必须把自己变成风”。 沙漠有一会儿没有回答他。 然后它告诉他：“我会给你我的沙子来帮助风吹，但是，我一个人什么也做不了。你必须向风求助”。 一阵微风吹起。 部落成员远远地看着这个男孩，用男孩听不懂的语言互相交谈。 炼金术士笑了。 风靠近男孩，抚摸着他的脸。 它知道男孩与沙漠的对话，因为风知道一切。 他们飘遍世界，没有出生地，也没有死亡地。 “帮帮我，”男孩说。 “有一天，你把我所爱之人的声音传给了我”。 “是谁教你说沙漠和风的语言的？” “我的心”，男孩回答。 风有很多名字。 在世界的那个地区，它被称为西罗科，因为它将海洋的水分带到了东方。 在男孩来自的遥远的土地上，他们称之为黎凡特，因为他们相信它带来了沙漠的沙子和摩尔人战争的尖叫声。 也许，在他的羊居住的牧场以外的地方，人们认为风来自安达卢西亚。 但实际上，风根本不来自任何地方，也不去任何地方； 这就是为什么它比沙漠更强大。 也许有人有一天会在沙漠里种树，甚至在那里养羊，但他们永远不会利用风。 风说：“你不可能是风。” “我们是两个截然不同的人”。 “这不是真的，”男孩说。 “我在旅行中学到了炼金术士的秘密。我的体内有风、沙漠、海洋、星星和宇宙中创造的一切。我们都是由同一只手创造的，我们有相同的灵魂。我 想要像你一样，能够到达世界的每一个角落，漂洋过海，吹散覆盖我宝藏的风沙，带着我爱的女人的声音”。 “那天你和炼金术士说的话我都听到了。”风说道。 “他说，万物有其命运，但人不能将自己变成风”。 “只要教我成为一阵风就好了”，男孩说。 “这样你我就可以谈论人与风的无限可能”。 风的好奇心被勾起，这是从未有过的事情。 它想谈论那些事情，但它不知道如何将一个人变成风。 看看风已经知道了多少事情！ 它创造了沙漠，沉没了船只，砍伐了整个森林，吹过充满音乐和奇怪噪音的城市。 感觉它没有任何限制，但有一个男孩说风应该还能做其他事情。 “这就是我们所说的爱”，男孩说道，看到风即将实现他的要求。 “当你被爱的时候，你可以在创造中做任何事情。当你被爱的时候，根本不需要了解正在发生的事情，因为一切都发生在你的内心，甚至男人也可以把自己变成风。只要风有帮助 ， 当然”。 风是一个骄傲的存在，它对男孩的话感到恼火。 风开始吹得更猛烈，吹起了沙漠的沙子。 但最终它必须认识到，即使环游世界，它也不知道如何将人变成风。 它对爱一无所知。 “在我环游世界的旅行中，我经常看到人们谈论爱并仰望天空”，风说道，因为不得不承认自己的局限性而感到愤怒。 “也许还是问天比较好。” “那么，帮我做吧”，男孩说。 “用强烈的沙尘暴填满这个地方，遮住太阳。然后我就可以仰望天堂而不会弄瞎自己”。 于是，狂风猛烈地刮起来，天空中布满了沙子。 太阳变成了一个金色的圆盘。 在营地里，很难看到任何东西。 沙漠里的人们已经熟悉了那股风。 他们称之为“simum”，它比海上的风暴还要糟糕。 他们的马匹惨叫着，所有的武器都被沙子填满了。 在高地上，一名指挥官转向酋长说道：“也许我们最好结束这一切！” 他们几乎看不到那个男孩。 他们的脸上都蒙着蓝色的布，眼中流露出恐惧。 “让我们阻止这一切”，另一名指挥官说。 “我想亲眼目睹安拉的伟大”，酋长满怀敬意地说。 “我想看看一个人如何将自己变成风”。 但他在心里记下了表达恐惧的两个人的名字。 风一停，他就要解除他们的命令，因为真正的沙漠之人并不害怕。 “风告诉我，你懂得爱。”男孩对太阳说。 “如果你了解爱，你也必须了解世界之魂，因为它是由爱构成的”。 “从我所在的地方，”太阳说，“我可以看到世界的灵魂。它与我的灵魂沟通，我们一起让植物生长，让羊群寻找阴凉处。从我所在的地方——我 离地球很远——我学会了如何去爱。我知道，如果我再靠近地球一点点，那里的一切都会死去，世界的灵魂将不复存在。所以我们沉思着每一个 彼此，我们彼此想要，我赋予它生命和温暖，它给了我活下去的理由”。 “所以你懂得什么是爱”，男孩说。 “而且我了解世界之魂，因为我们在这无尽的宇宙之旅中彼此进行了很长的交谈。它告诉我，它最大的问题是，到目前为止，只有矿物质和植物明白 事物是一体的。铁不必与铜相同，铜也不必与金相同。每一种都作为独特的存在发挥着自己的确切功能，如果书写这一切的手，一切都将是一首和平的交响乐 在创造的第五天就停止了。 “但是还有第六天”，太阳继续说道。 “你很聪明，因为你从远处观察一切。”男孩说。 “但你不知道什么是爱。如果没有第六天，人类就不会存在；铜永远只是铜，铅永远只是铅。诚然，一切都有它的命运，但有一天，命运 都会实现的。所以每一个事物都必须将自己转变为更好的事物，并获得新的命运，直到有一天，世界之魂变成唯一的事物”。 太阳想了想，决定发出更明亮的光芒。 正在享受谈话的风开始吹得更大了，这样阳光就不会遮住男孩的眼睛。 “这就是炼金术存在的原因”，男孩说。 “这样每个人都会寻找他的宝藏，找到它，然后想要比他以前的生活更好。铅将发挥其作用，直到世界不再需要铅；然后铅将不得不自行转变 变成黄金。 “这就是炼金术士所做的。他们表明，当我们努力变得比现在更好时，我们周围的一切也会变得更好。” “那你凭什么说我不懂爱情？” 太阳问男孩。 “因为爱不是像沙漠一样静止的爱，也不是像风一样漫游世界的爱。也不是像你那样从远处看一切的爱。爱是改变和提高灵魂的力量。” 世界。当我第一次接触它时，我认为世界之魂是完美的。但后来，我发现它就像造物的其他方面一样，有自己的激情和战争。是我们滋养了世界之魂。 世界之魂，我们生活的世界会变得更好还是更坏，取决于我们变得更好还是更坏。这就是爱的力量发挥作用的地方。因为当我们爱的时候，我们总是努力变得比我们更好 是”。 “那你想要我做什么？” 太阳问道。 “我要你帮我把自己变成风”，男孩回答。 太阳说：“大自然知道我是造物中最聪明的存在。” “但我不知道如何把你变成风”。 “那我该去问谁呢？” 太阳想了一会儿。 风仔细地听着，想要告诉世界的每一个角落，太阳的智慧也有其局限性。 它无法对付这个会说世界语言的男孩。 “对写下一切的手说话”，太阳说。 风高兴地呼啸着，而且刮得比以前更猛烈了。 帐篷与地面的连接被炸断，动物也被从系带中解救出来。 在悬崖上，人们紧紧抓住对方，以免被风吹走。 男孩转向写下这一切的手。 当他这样做的时候，他感觉到宇宙陷入了沉默，他决定不再说话。 一股爱的电流从他的心中涌出，男孩开始祈祷。 这是他以前从未说过的祈祷，因为这是一个没有言语或恳求的祈祷。 他的祷告并没有感谢他的羊找到了新的牧场；而是感谢他的羊找到了新的牧场。 它并没有要求男孩能够卖出更多的水晶； 并不恳求他所遇见的那个女人继续等待他的归来。 在寂静中，男孩明白，沙漠、风和太阳也在试图理解手写的符号，并试图追随它们的路径，理解单颗祖母绿上写下的内容。 他看到预兆散布在整个地球和太空中，而且它们的出现没有任何原因或意义。 他可以看到，沙漠、风、太阳、人们都不知道它们为何被创造。 但这一切都是有手的原因的，只有手才能创造奇迹，或者把大海变成沙漠……或者把人变成风。 因为只有手才明白，这是一个更大的设计，将宇宙移动到了六天的创造演化为杰作的地步。 少年伸手触及世界之魂，发现那是神之魂的一部分。 而他看到，神魂就是他自己的灵魂。 他，一个男孩，可以创造奇迹。 28 那天，simum 刮了，这是以前从未刮过的。 此后的几代人中，阿拉伯人都讲述了一个男孩的传说，他不顾沙漠中最有权势的酋长的命令，将自己变成了风，几乎摧毁了一个军营。 当西穆姆停止吹气时，每个人都看向男孩刚才所在的地方。 但他已经不在了。 他站在营地另一边一个浑身是沙的哨兵旁边。 人们都被他的巫术吓坏了。 但有两个人在微笑：一个是炼金术士，因为他找到了完美的弟子；另一个是酋长，因为那个弟子明白了神的荣耀。 第二天，将军告别了男孩和炼金术士，并为他们安排了一支护卫队，护送他们去尽可能远的地方。 29 他们骑了一整天。 下午快结束时，他们来到了一座科普特修道院。 炼金术士下了马，告诉护卫们可以返回营地了。 “从现在开始，你将孤独一人”，炼金术士说道。 “你距离金字塔只有三个小时”。 “谢谢你”，男孩说。 “你教了我世界语言”。 “我只是引用了你已经知道的东西”。 炼金术士敲响了修道院的大门。 一名身穿黑衣的修士来到了门口。 他们用科普特语交谈了几分钟，炼金术士请男孩进去。 “我请求他让我使用一下厨房。”炼金术士微笑道。 他们去了修道院后面的厨房。 炼金术士点燃了火，和尚给他带来了一些铅，炼金术士将其放入铁锅中。 当铅变成液体时，炼金术士从袋子里取出了奇怪的黄色鸡蛋。 他从上面刮下一根像头发一样细的条子，用蜡包裹起来，然后将其放入已熔化铅的锅中。 混合物呈微红色，几乎是血的颜色。 炼金术士把锅从火上移开，放在一边冷却。 一边这样做，他一边和僧人谈论部落战争。 “我认为它们会持续很长时间”，他对和尚说。 和尚恼怒了。 商队已经在吉萨停留了一段时间，等待战争结束。 “但上帝的旨意将会实现”，僧侣说。 “完全正确”，炼金术士回答。 当锅冷却后，和尚和男孩看着它，眼花缭乱。 铅已经干燥成锅的形状，但它不再是铅了。 那是金子。 “有一天我能学会这样做吗？” 男孩问道。 “这是我的命运，不是你的。”炼金术士回答道。 “但我想告诉你这是可能的”。 他们又回到了寺院门口。 在那里，炼金术士将圆盘分成四部分。 “这是给你的，”他说着，把其中一个零件递给了和尚。 “这是为了您对朝圣者的慷慨”。 “但是这笔钱远远超出了我的慷慨范围”，僧人回答道。 “别再说了。生活可能会倾听，下次给你的就会少一些”。 炼金术士转向男孩。 “这是给你的，作为你给将军的补偿”。 男孩正要说，这比他给将军的要多得多。 但他保持沉默，因为他听到了炼金术士对和尚所说的话。 “这是给我的，”炼金术士说，保留了其中一个零件。 “因为我必须回到沙漠，那里正在发生部落战争”。 他接过第四部分，递给了和尚。 “这是给男孩的。如果他需要的话”。 “但我要去寻找我的宝藏”，男孩说。 “我现在已经非常接近了”。 “我确信你会找到它”，炼金术士说道。 “那这是为什么？” “因为你已经两次失去积蓄了。一次是小偷，一次是将军。我是一个古老而迷信的阿拉伯人，我相信我们的谚语。有句话说，‘发生一次的事情就永远不会发生’ 再次发生。但是发生两次的事情肯定会发生第三次’”。 他们骑上马。 30 “我想给你讲一个关于梦想的故事。”炼金术士说道。 男孩把他的马拉近了一些。 “在古罗马，提比略皇帝时代，有一个好人，他有两个儿子。其中一个在军队，被派往帝国最偏远的地区。 另一个儿子是一位诗人，他优美的诗句让整个罗马都为之高兴。 “一天晚上，父亲做了一个梦。一位天使出现在他面前，告诉他，他的一个儿子的话将被全世界的子孙后代学习和重复。父亲从梦中醒来，感激不已，哭了。 ，因为生活是慷慨的，并且向他揭示了任何父亲都会自豪地知道的事情。 “不久之后，父亲在拯救一个即将被车轮碾压的孩子时去世了。由于他一生都过着正确、公正的生活，所以他直接去了天堂。 他遇见了梦中出现的天使。 “‘你一直是个好人，’天使对他说。‘你以一种充满爱的方式生活，并有尊严地死去。现在我可以满足你任何愿望。’ “‘生活对我来说很好，’男人说，‘当你出现在我的梦里时，我觉得我所有的努力都得到了回报，因为我儿子的诗将被子孙后代传诵。我不想 但任何一位父亲都会为自己小时候所照顾、成长过程中接受教育的人所取得的名声感到自豪。 在遥远的将来的某个时候，我希望看到我儿子的话。” “天使触碰了男人的肩膀，他们两人都被投射到了遥远的未来。 他们身处一个巨大的环境中，周围有成千上万的人讲着奇怪的语言。 “那个男人高兴得哭了。 “‘我知道我儿子的诗是不朽的，’他流着泪对天使说。‘你能告诉我这些人在重复我儿子的哪首诗吗？’ “天使走近那个人，温柔地把他带到附近的一张长凳上，他们在那里坐下。 “‘你的诗人儿子的诗句在罗马很受欢迎，’天使说。 “每个人都喜欢它们并享受它们。 但当提比略的统治结束时，他的诗被遗忘了。 你现在听到的话是你在军队的儿子说的。” ”男子惊讶地看着天使。 “‘你的儿子到远方去侍奉，做了百夫长。他为人正义又善良。一天下午，他的一个仆人得了病，眼看就要死了。你的儿子听说有一位拉比， 他能治愈疾病，他日复一日地骑马寻找这个人。一路上，他得知他要找的人是上帝的儿子。他遇到了其他被他治愈的人，他们指示他 “他在那个人的教义中找到了你的儿子。因此，尽管他是罗马百夫长，他还是皈依了他们的信仰。不久之后，他就到达了他要找的那个人正在拜访的地方。” “‘他告诉那个人，他的一个仆人病得很重，拉比准备和他一起去他家。但是百夫长是一个有信心的人，看着拉比的眼睛，他知道 他肯定是在神的儿子面前。 “‘这就是你的儿子所说的，’天使告诉那个人。‘这些是他当时对拉比说的话，他们永远不会被忘记：“我的主，我不值得你来 在我的屋檐下。 但只要说一句话，我的仆人就会痊愈。” 炼金术士说：“无论他做什么，地球上的每个人都在世界历史上发挥着核心作用。而通常他不知道这一点”。 男孩笑了。 他从来没有想到，关于生命的问题对于一个牧羊人来说是如此重要。 “再见”，炼金术士说道。 “再见”，男孩说。 31 男孩在沙漠中骑行了几个小时，热切地倾听着他内心的声音。 他的心会告诉他他的宝藏藏在哪里。 “你的宝藏在哪里，你的心也在那里”，炼金术士告诉他。 但他的心里却在说着别的事情。 它自豪地讲述了一个牧羊人离开羊群去追随他在两个不同场合实现的梦想的故事。 它讲述了命运，讲述了许多男人为了寻找遥远的土地或美丽的女人而流浪，以他们先入为主的观念面对当时的人们。 它讲述了旅程、发现、书籍和变化。 当他即将攀登另一个沙丘时，他的心低声说道：“注意一下让你流泪的地方。那是我所在的地方，那是你的宝藏所在的地方。” 男孩慢慢地爬上沙丘。 星空中，一轮圆月再次升起：他离开绿洲已经一个月了。 月光透过沙丘投下阴影，营造出波涛汹涌的大海的外观。 这让男孩想起那匹马在沙漠里长大的那一天，他认识了炼金术士。 月亮落在了沙漠的寂静上，落在了一个人寻找宝藏的旅程上。 当他到达沙丘顶时，他的心狂跳起来。 在那里，在月光和沙漠的光辉的照耀下，矗立着庄严雄伟的埃及金字塔。 男孩跪倒在地哭泣。 他感谢上帝让他相信自己的命运，让他遇见了国王、商人、英国人和炼金术士。 最重要的是，他遇到了一位来自沙漠的女人，她告诉他，爱情永远不会阻止一个男人摆脱自己的命运。 如果他愿意，他现在就可以回到绿洲，回到法蒂玛，过上一个简单的牧羊人的生活。 毕竟，炼金术士继续生活在沙漠中，尽管他了解世界语言，并且知道如何将铅变成金。 他不需要向任何人展示他的科学和艺术。 男孩告诉自己，在实现自己命运的路上，他已经学会了他所需要知道的一切，也经历了他所梦想的一切。 但他就在这里，在寻找他的宝藏的时刻，他提醒自己，只有实现目标，任何项目才算完成。 男孩看着周围的沙子，发现在他的眼泪落下的地方，有一只圣甲虫正在沙子里爬行。 在沙漠中的那段时间里，他了解到，在埃及，圣甲虫是上帝的象征。 另一个预兆！ 男孩开始挖沙丘。 当他这样做的时候，他想到了水晶商人曾经说过的话：任何人都可以在他的后院建造一座金字塔。 男孩现在明白了，如果他一辈子都把石头放在石头上，他就无法做到这一点。 男孩在他选定的地方挖了整整一夜，但什么也没找到。 金字塔建成以来几个世纪的时间让他感到沉重。 但他没有停下来。 他奋力顶着风继续挖掘，风经常把沙子吹回坑里。 他的双手磨损又疲惫，但他倾听自己的内心。 它告诉他去挖他眼泪掉下来的地方。 当他试图取出遇到的岩石时，他听到了脚步声。 几道人影向他靠近。 他们背对着月光，男孩既看不到他们的眼睛，也看不到他们的脸。 “你在这里做什么？” 其中一位人物要求道。 因为害怕，男孩没有回答。 他找到了他的宝藏在哪里，并对可能发生的事情感到害怕。 另一位人士表示，“我们是部落战争的难民，我们需要钱”。 “你藏在那里做什么？” “我没有隐瞒任何事情”，男孩回答。 但其中一人抓住了男孩，把他从洞里拉了出来。 另一个人在搜查男孩的包时发现了那块金子。 “这里有黄金”，他说。 月亮照在抓住他的阿拉伯人的脸上，在那个人的眼里，男孩看到了死亡。 “他可能在地下藏有更多的黄金”。 他们让男孩继续挖掘，但他什么也没找到。 当太阳升起时，这些人开始殴打男孩。 他遍体鳞伤，流血不止，衣服被撕成碎片，他感觉死亡已经临近了。 炼金术士说：“如果你快要死了，钱对你来说有什么用呢？钱很少能救人的命。” 最后，男孩对着男人们尖叫：“我在挖宝藏！”。 尽管他的嘴巴流血肿胀，但他告诉袭击者，他曾两次梦见埃及金字塔附近藏有宝藏。 看起来是这群人的领导者的男子对其中一人说道：“放开他。他没有别的东西了。他一定是偷了这些金子”。 男孩倒在沙地上，几乎失去知觉。 领导摇摇他说：“我们走了”。 但在他们离开之前，他回到男孩身边，说道：“你不会死。你会活下去，你会明白一个人不应该这么愚蠢。两年前，就在此时 在这里，我也做了一个反复出现的梦。我梦见我应该去西班牙的田野里，寻找一座破败的教堂，那里有牧羊人和他们的羊睡觉。在我的梦里，有一棵梧桐树从教堂的废墟中长出来。 “圣器收藏室，有人告诉我，如果我挖梧桐树的根部，我会发现隐藏的宝藏。但我不会愚蠢到仅仅因为一个反复出现的梦就穿越整个沙漠”。 然后他们就消失了。 男孩摇摇晃晃地站起来，再次看向金字塔。 他们似乎在嘲笑他，他也笑了，心里充满喜悦。 因为现在他知道他的宝藏在哪里了。","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"炼金术士","slug":"炼金术士","permalink":"http://example.com/tags/%E7%82%BC%E9%87%91%E6%9C%AF%E5%A3%AB/"}]},{"title":"炼金术士3-第一章","slug":"认知-修行-平衡/炼金术士3-第一章","date":"2024-04-03T03:01:30.000Z","updated":"2024-04-08T01:46:55.336Z","comments":true,"path":"2024/04/03/认知-修行-平衡/炼金术士3-第一章/","link":"","permalink":"http://example.com/2024/04/03/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/%E7%82%BC%E9%87%91%E6%9C%AF%E5%A3%AB3-%E7%AC%AC%E4%B8%80%E7%AB%A0/","excerpt":"","text":"Paulo Coelho 保罗·科埃略 1 男孩名叫圣地亚哥。黄昏时分，男孩带着他的牛群来到一座废弃的教堂。屋顶早已坍塌，圣器室曾经所在的地方长出了一棵巨大的梧桐树。 他决定在那里过夜。他让所有的羊都从被毁坏的大门进去，然后在门上铺上一些木板，防止羊群在夜间走失。这一带没有狼，但有一次，一只动物在夜里走失了，男孩不得不花了一整天的时间去寻找它。 他用外套扫了扫地面，然后躺下，用刚读完的书当枕头。他告诉自己，他得开始读厚一点的书：这样能看得更久，做枕头也更舒服。 当他醒来时，天还是黑的，抬头仰望，他可以透过半毁的屋顶看到星星。 他想，我还想再睡一会儿。那天晚上，他做了一个和一周前一样的梦，他又一次在梦结束之前醒了过来。 他站起来，拿起羊角锤，开始唤醒还在熟睡的羊群。他注意到，只要他一醒来，他的大多数动物也开始躁动起来。仿佛有一种神秘的能量将他的生命与羊群的生命紧紧联系在一起，在过去的两年里，他一直与羊群在一起，带领它们在乡间寻找食物和水。他喃喃自语道：”它们已经习惯了我，知道我的日程安排”。想了一会儿，他意识到事情可能恰恰相反：是他习惯了羊群的作息时间。 但其中有些人需要更长的时间才能醒来。小男孩用羊角棒挨个戳它们，叫着每只羊的名字。他一直相信，羊能听懂他说的话。因此，有时他会给羊儿们读自己书中给他留下深刻印象的部分，或者给它们讲牧羊人在田野里的孤独或快乐。有时，他会向羊儿们讲述他在经过的村庄里看到的事物。 但在过去的几天里，他只和他们谈了一件事：那个女孩，她是一个商人的女儿，住在他们大约四天后要到达的村子里。他只去过那个村子一次，是在前年。这位商人是一家干货店的老板，他总是要求当着他的面剪羊毛，以免上当受骗。一个朋友向男孩介绍了这家店，他就把羊带到了那里。 2 “男孩对商人说：”我要卖一些羊毛。 店里很忙，商人让牧羊人等到下午再去。于是，男孩坐在商店的台阶上，从包里拿出一本书。 “我不知道牧羊人还识字”，他身后传来一个女孩的声音。 女孩是典型的安达卢西亚人，一头飘逸的黑发，一双眼睛让人依稀想起摩尔征服者。 他回答说：”嗯，通常我从羊群中学到的东西比从书本上学到的多”。在他们交谈的两个小时里，她告诉他自己是商人的女儿，并谈到了村里的生活，每天都过得和往常一样。牧羊人告诉她安达卢西亚乡村的情况，并讲述了他停留过的其他城镇的消息。 与羊群的谈话相比，这真是一种令人愉快的改变。 “有一次，女孩问：”你是怎么学会读书的？” 他说：”就像每个人学的一样”。”在学校”。 “好吧，如果你识字，为什么你只是个牧羊人？”。 “男孩喃喃自语地回答，以此逃避回答女孩的问题。他相信女孩永远不会明白。他继续讲述他的旅行故事，而她那双明亮的摩尔人眼睛则因恐惧和惊讶而瞪得大大的。随着时间的流逝，男孩发现自己希望这一天永远不要结束，希望她的父亲能一直忙下去，让他等上三天。他意识到自己正在感受着一种从未有过的体验：渴望永远生活在一个地方。有了这个乌发姑娘，他的日子就再也不会一样了。 但是，商人终于出现了，他让男孩剪四只羊的毛。他付了羊毛的钱，并请牧羊人来年再来。 3 而现在，离他回到那个村庄只有四天了。他很兴奋，同时也很不安：也许那个女孩已经把他忘了。许多牧羊人经过这里，出售羊毛。 “没关系”，他对羊群说。”我在别的地方也认识别的女孩。 但他心里明白，这并不重要。他知道，牧羊人就像海员和旅行推销员一样，总能找到一个小镇，那里有一个能让他们忘记无忧无虑的流浪乐趣的人。 天亮了，牧羊人催促着羊群向着太阳的方向前进。他想，他们从来不需要做任何决定。也许这就是为什么它们总是跟在我身边。 羊只关心食物和水。只要小男孩知道如何找到安达卢西亚最好的牧场，它们就是他的朋友。是的，它们的日子千篇一律，从日出到黄昏的时间似乎没有尽头；它们年轻的时候从未读过一本书，当男孩向它们介绍城市的风景时，它们也听不懂。它们只满足于食物和水，作为交换，它们慷慨地奉献出自己的羊毛、陪伴和偶尔的肉食。 男孩想，如果我今天变成了怪物，决定一个接一个地杀死它们，只有在大部分羊群被屠杀之后，它们才会有所察觉。他们信任我，他们已经忘记了如何依靠自己的本能，因为我带领他们找到了食物。 男孩对自己的想法感到惊讶。也许，那座长着梧桐树的教堂曾经闹过鬼。这让他第二次做了同样的梦，也让他对忠实的同伴感到愤怒。他喝了一点前一晚晚餐剩下的酒，把外套拢得更紧了。他知道，再过几个小时，当太阳升至顶点时，热量会非常大，他将无法带领羊群穿过田野。这是西班牙夏季一天中最热的时候。炎热的天气一直持续到夜幕降临，在这段时间里，他不得不带着外套。但当他想抱怨夹克太重时，他又想起，因为有了夹克，他才抵御住了黎明的寒冷。 他想，我们必须做好应对变化的准备，他对夹克的重量和温暖表示感谢。 夹克有它的用途，男孩也有它的用途。他的人生目标就是旅行，在安达卢西亚的土地上行走了两年之后，他对该地区的所有城市都了如指掌。这次来，他打算向女孩解释，一个普通的牧羊人怎么会识字。他曾在神学院学习到 16岁。他的父母希望他成为一名牧师，从而成为这个普通农家的骄傲。他们像羊群一样辛勤劳作，只为有饭吃有水喝。他学习过拉丁语、西班牙语和神学。但他从小就想了解这个世界，这对他来说比认识上帝和了解人类的罪孽更重要。 一天下午，在一次探亲途中，他鼓起勇气告诉父亲，他不想当神父。他想去旅行。 4 “来自世界各地的人都经过这个村子，儿子”，父亲说。 “他们来这里寻找新事物，但当他们离开时，他们基本上还是来时的样子。他们爬上山顶去看城堡，最后却认为过去的一切都比现在的好。他们或金发碧眼，或肤色黝黑，但基本上和生活在这里的人没什么两样”。 “但我想看看他们居住的城镇里的城堡”，男孩解释道。 父亲接着说：”那些人看到我们的土地后，说他们想永远住在这里”。 “儿子说：”嗯，我也想看看他们的土地，看看他们是怎么生活的。 “父亲说：”来这里的人有很多钱花，所以他们有能力旅行。”在我们中间，只有牧羊人会旅行”。 “好吧，那我就当牧羊人！”。 父亲不再多说。第二天，他给了儿子一个小袋，里面装着三枚古老的西班牙金币。 “有一天，我在田野里发现了这些金币。我想把它们作为你遗产的一部分。用它们来买你的羊群，到田里去，总有一天你会知道，我们的乡村是最好的，我们的女人是最美的”。 他向男孩表达了祝福。男孩从父亲的目光中看到了他自己能够周游世界的愿望–尽管他的父亲不得不将这种愿望埋葬在数十载的岁月中，在为水喝、为食物吃、为每天晚上在同一个地方睡觉而挣扎的重担下，这种愿望依然存在。 5 地平线被染成了红色，太阳突然出现了。小男孩回想起与父亲的那次谈话，感到非常高兴；他已经见过许多城堡，也见过许多女人（但没有一个能与几天后等待他的女人相提并论）。 他拥有了一件夹克、一本可以交换的书和一群羊。但最重要的是，他每天都能实现自己的梦想。如果他厌倦了安达卢西亚的田野，他可以卖掉羊群出海。等他在海上玩够了，他就已经认识了其他城市、其他女人和其他幸福的机会。他看着日出想，我不可能在神学院找到上帝。 只要有机会，他就会寻找新的道路。他从未去过那座被毁坏的教堂，尽管他曾多次走过那些地方。世界之大，无穷无尽；他只需让羊群暂时设定路线，就会发现其他有趣的事物。问题是，他们甚至没有意识到自己每天都在走一条新路。它们看不到田野是新的，季节是变化的。他们只想着食物和水。 也许我们都是这样，男孩喃喃自语。即使是我–自从遇到商人的女儿后，我就再也没想过其他女人了。看着太阳，他计算着中午之前就能到达塔里法。在那里，他可以把书换成更厚的，把酒瓶装满，刮刮胡子，理理头发；他必须为与女孩的会面做好准备，他不想去想是否会有其他牧羊人，带着更多的羊群，比他先到，并向他求婚。 他想，正是梦想成真的可能性让生活变得有趣，他又看了看太阳的位置，加快了脚步。他突然想起，在塔里法，有一位会解梦的老妇人。 6 老妇人把男孩领到她家后面的一个房间，房间与客厅之间用彩色珠帘隔开。房间里有一张桌子、一尊耶稣圣心像和两把椅子。 女人坐了下来，并让他也坐下。然后，她握住他的双手，开始静静地祈祷。 听起来像是吉普赛人的祈祷。男孩已经有过和吉普赛人一起上路的经历；他们也旅行，但他们没有羊群。人们说吉普赛人一生都在欺骗别人。人们还说，他们与魔鬼有约定，他们绑架孩子，把他们带到神秘的营地，让他们成为自己的奴隶。小男孩从小就害怕被吉普赛人抓走，当老妇人握住他的双手时，这种童年的恐惧又回来了。 但她的手上有耶稣圣心，他想，试图安慰自己。他不想让自己的手开始颤抖，让老妇人知道他在害怕。他默默地念了一句 “我们的父亲”。 “非常有趣”，女人说，眼睛一直没有离开男孩的手，然后她沉默了。 男孩开始紧张起来。他的手开始颤抖，女人也感觉到了。 他赶紧把手抽了出来。 “我不是来让你给我看手相的”，他说，他已经后悔来了。 他想了一会儿，觉得还不如付了钱就走，什么也不学，他太看重自己反复出现的梦了。 “老妇人说：”你来是为了了解你的梦。”梦是上帝的语言。当他用我们的语言说话时，我能解释他说的话。但如果他用灵魂的语言说话，只有你能听懂。 不过，不管是哪一种，我都要向你收取咨询费。 男孩想，这又是一个骗局。但他决定冒险一试。牧羊人总是要冒着狼群和干旱的危险，而这正是牧羊人生活的精彩之处。 “我做过两次同样的梦”，他说。”我梦见自己和羊群在田野里，一个孩子出现了，开始和动物们玩耍。我不喜欢别人这样做，因为羊害怕陌生人。但孩子们似乎总能和它们一起玩耍，而不会吓到它们。我也不知道为什么。我不知道动物怎么知道人类的年龄”。 “再给我讲讲你的梦吧”，女人说。”我得回去做饭了，因为你没有多少钱，所以我不能给你太多时间”。 “孩子继续和我的羊玩了好一会儿”，男孩继续说，有点不高兴。”突然，孩子双手拉着我，把我带到了埃及金字塔。 他停顿了一会儿，想看看女人是否知道埃及金字塔是什么。但她什么也没说。 “然后，在埃及金字塔”–为了让老太太明白，他把最后三个字说得很慢–”那个孩子对我说：’如果你到这里来，就会找到隐藏的宝藏’。就在她要告诉我具体位置时，我醒了过来。两次都是这样”。 女人沉默了一会儿。然后，她再次握住他的手，仔细地研究起来。 “她说：”我现在不会向你收取任何费用。”但如果你找到了宝藏，我想要十分之一。 男孩开心地笑了。因为做了一个关于宝藏的梦，他可以省下他仅有的一点钱了！ 他说：”好吧，解梦吧”。 “首先，向我发誓。发誓你会把你宝藏的十分之一给我，以换取我要告诉你的东西”。 牧羊人发誓他愿意。老妇人让他看着耶稣圣心像再次发誓。 她说：”这是用世界语言做的梦”。”我可以解释它，但解释起来非常困难。这就是为什么我觉得我应该从你们的发现中分一杯羹。 “这就是我的解释：你必须去埃及的金字塔。我从未听说过它们，但是，如果是一个孩子向你展示了它们，那么它们是存在的。在那里，你会找到让你成为富翁的宝藏”。 男孩很惊讶，然后又很恼火。他不需要为此去找那个老妇人！但他转念一想，自己又不用付钱。 “他说：”我没必要为此浪费时间。 “我告诉过你，你的梦想很难实现。生活中简单的事情才是最不平凡的；只有智者才能理解它们。因为我没有智慧，所以我不得不学习其他技艺，比如看手相”。 “那我怎么去埃及呢？”。 “我只会解梦。我不知道如何把梦变成现实。所以我只能靠女儿们给我的钱生活”。 “如果我永远到不了埃及呢？” “那我就拿不到钱了。这又不是第一次了”。 女人让男孩离开，说她已经在他身上浪费了太多时间。 男孩很失望，他决定再也不相信梦了。他想起自己还有很多事情要处理：他去市场买了些吃的，他用自己的书换了一本更厚的书，他在广场上找了一张长椅，在那里他可以品尝他买的新酒。天气炎热，葡萄酒沁人心脾。羊群在城门口一个朋友的马厩里。男孩在城里认识很多人。这正是旅行吸引他的地方–他总能交到新朋友，而且他不需要把所有时间都花在他们身上。 当一个人每天都见到同样的人，就像他在神学院时那样，他们就会成为这个人生活的一部分。然后他们就会希望这个人有所改变。如果一个人不是其他人想要的样子，其他人就会生气。 似乎每个人都对别人的生活方式有清晰的认识，但对自己的生活方式却一无所知。 他决定等到太阳在天空中沉得更低一些时，再跟着羊群穿过田野回去。三天后，他将和商人的女儿在一起。 他开始读他买的那本书。书的第一页描述了一个葬礼仪式。其中涉及的人名非常难念。他想，如果他能写一本书的话，他会一次介绍一个人，这样读者就不用担心记住很多名字了。 当他终于能够集中精力阅读时，他更喜欢这本书了；埋葬的地点是在一个雪天，他欢迎这种寒冷的感觉。当他读下去的时候，一位老人在他身边坐下，试图和他搭讪。 “他们在做什么？”老人指着广场上的人们问道。 “工作”，男孩干巴巴地回答，看起来似乎想专心读书。 其实，他想的是当着商人女儿的面剪羊毛，让她看看他是个能干难事的人。他已经想象过很多次这样的场景了；每次，当他解释必须从后往前剪羊毛时，女孩都会被吸引住。在剪羊毛的过程中，他还努力回忆一些好故事。这些故事大多是他在书上读到的，但他会把它们说成是自己的亲身经历。她永远不会知道其中的差别，因为她不识字。 与此同时，老人继续试图搭讪。他说自己又累又渴，问是否可以喝一口男孩的酒。男孩拿出自己的酒瓶，希望老人不要再打扰他。 但老人还想说话，他问男孩在读什么书。男孩很想不客气地搬到另一张长椅上，但父亲教导他要尊敬老人。于是，他把书递给老人–原因有二：第一，他自己也不知道书名该怎么念；第二，如果老人不识字，他可能会感到羞愧，并主动决定换凳子。 “嗯…… “老人说，他看着书的四面八方，好像它是什么奇怪的东西。”这是一本重要的书，但它真的很烦人”。 男孩吓了一跳。老人会读书，而且已经读过这本书了。 如果真像老人说的那样，这本书令人讨厌，男孩还有时间把它换成另一本书。 老人接着说：”这本书说的和世界上几乎所有其他书说的都一样”。”它描述了人们无法选择自己的命运。它最后说，每个人都相信世界上最大的谎言”。 “什么是世界上最大的谎言？”男孩惊讶地问。 “这就是：在我们生命中的某个时刻，我们失去了对发生在我们身上的事情的控制，我们的生活被命运控制。这是世界上最大的谎言”。 男孩说：”我从没遇到过这种事”。”他们想让我当牧师，但我决定当牧羊人”。 “这样好多了”，老人说。”因为你很喜欢旅行”。 “他知道我在想什么”，男孩自言自语道。与此同时，老人正在翻阅那本书，似乎根本不想把书还回去。男孩注意到老人的衣着很奇怪。他看起来像个阿拉伯人，这在当地并不罕见。非洲距离塔里法只有几个小时的路程，人们只需乘船穿过狭窄的海峡。阿拉伯人经常出现在城市里，他们一边购物，一边念叨着他们奇怪的祷文，一天要念好几遍。 “你从哪里来？”男孩问。 “来自很多地方”。 “男孩说：”没有人可以来自很多地方。”我是一个牧羊人，我去过很多地方，但我只来自一个地方–来自一座古城堡附近的城市。那就是我出生的地方”。 “那么，我们可以说我出生在塞勒姆”。 男孩不知道塞勒姆在哪里，但他不想问，怕显得自己无知。他看了一会儿广场上的人们，他们来来往往，似乎都很忙。 “那么，塞勒姆是个什么样的地方呢？”他问道，试图从中得到一些线索。 “还是老样子”。 还没有线索 但他知道塞勒姆不在安达卢西亚。如果是的话，他早就听说过了。 “那你在塞勒姆做什么？”他坚持问。 “我在塞勒姆做什么？”。老人笑了 “我是塞勒姆的国王！” 男孩想，人们总是说奇怪的话。有时候和羊在一起会更好 因为他们什么都不会说 最好还是一个人看书。在你想听故事的时候，它们就会讲出令人难以置信的故事。但当你与人交谈时，他们会说一些奇怪的话，让你不知如何继续交谈。 老人说：”我叫麦基洗德”。”你有几只羊？”。 男孩说：”够多了”。他看得出，老人想更多地了解他的生活。 “好吧，那我们就有麻烦了。如果你觉得自己的羊够多，我就帮不了你。 男孩被激怒了。他不是在寻求帮助。是老人要喝他的酒，挑起了谈话。 “把我的书给我”，男孩说。”我得去收羊，然后出发”。 “老人说：”给我十分之一的羊，我就告诉你如何找到宝藏”。 男孩想起了自己的梦，突然间一切都明白了。那个老妇人没有向他收取任何费用，但那个老人–也许是她的丈夫–会想办法用更多的钱来换取一些根本不存在的东西的信息。这个老人可能也是个吉普赛人。 但还没等男孩开口，老人就俯下身，拿起一根棍子，开始在广场的沙地上写字。他的胸前反射出明亮的光芒，强烈得让男孩瞬间睁不开眼。老人用他的斗篷遮住了那东西，动作之快不像他这个年纪的人。当他的视力恢复正常后，男孩才看清了老人在沙上写的字。 在那个小城市广场的沙地上，男孩读到了他父亲和母亲的名字，以及他曾经就读的神学院的名字。他读到了商人女儿的名字，而他甚至不知道这个名字，他还读到了一些他从未告诉过别人的事情。 7 老人说：”我是撒冷的国王”。 “国王为什么要和一个牧羊人说话？”男孩又惊又窘地问道。 “有几个原因。但最重要的原因是，你成功地发现了自己的命运。” 男孩不知道一个人的 “命运”是什么。 他说：”这就是你一直想要完成的事情。每个人在年轻时都知道自己的命运是什么。” “在他们的人生中，一切都很清晰，一切都有可能。他们无所畏惧，敢于梦想，渴望自己一生中希望实现的一切。但是，随着时间的流逝，一种神秘的力量开始让他们相信，他们不可能实现自己的命运”。 老人说的话对男孩来说没有什么意义。但他想知道那股 “神秘的力量 “是什么，如果他告诉商人的女儿，她一定会印象深刻！ “这是一种看似消极的力量，但实际上它告诉你如何实现自己的命运。它让你的精神和意志做好准备，因为在这个星球上有一个伟大的真理：无论你是谁，无论你做什么，当你真正想要什么的时候，那是因为这种欲望源自宇宙的灵魂。这是你在地球上的使命”。 “即使你只想旅行？或者娶一个纺织品商人的女儿？ “是的，甚至是寻找宝藏。人们的幸福滋养着世界的灵魂。不快乐、羡慕和嫉妒也会滋养它。实现自己的命运是一个人唯一真正的义务。万物一体。 “当你想要某样东西时，全宇宙都会合力帮助你实现它。 两人都沉默了一会儿，观察着广场和镇上的人们。还是老人先开口了。 “你为什么要放羊？ “因为我喜欢旅行。 老人指了指站在广场一角橱窗里的面包师。 “他小时候也想去旅行。但他决定先买下自己的面包店，把钱存起来。等他老了，他要去非洲待一个月。他从未意识到，人在一生中的任何时候都有能力去做自己梦想的事情”。 男孩说：”他应该决定成为一名牧羊人”。 “嗯，他想过这个问题”，老人说。”但面包师比牧羊人更重要。面包师有家，而牧羊人露宿街头。父母宁愿看到自己的孩子嫁给面包师，也不愿意看到他们嫁给牧羊人”。 想到商人的女儿，男孩心里一阵酸楚。她的镇上肯定有一个面包师。 老人接着说：”从长远来看，人们对牧羊人和面包师的看法比他们自己的命运更重要。 老人翻了翻书，翻到一页就坐下来读。男孩等待着，然后打断了老人的话，就像他自己被打断一样。”你为什么要告诉我这些？ “因为你正在努力实现自己的命运。而你正处于即将放弃这一切的时刻”。 “那你总是在这个时候出现？” “并不总是这样，但我总是以这样或那样的形式出现。有时我以解决方案或好主意的形式出现。其他时候，在关键时刻，我让事情更容易发生。 我还做了其他一些事情，但大多数时候人们没有意识到我已经做了这些”。 老人说，一周前，他被迫出现在一名矿工面前，并变成了一块石头。 矿工放弃了一切去开采祖母绿。 五年来，他一直在某条河流工作，检查了数十万块石头，寻找祖母绿。 矿工正要放弃一切，就在此时，如果他再检查一块石头——再检查一块——他就会找到他的祖母绿。 由于矿工为了自己的命运牺牲了一切，老人决定参与其中。 他把自己变成了一块石头，滚到了矿工的脚边。 矿工带着五年毫无结果的愤怒和沮丧，捡起石头扔到一边。 但他扔出的力道太大了，以至于它击碎了落在上面的石头，而破碎的石头中镶嵌着世界上最美丽的祖母绿。 “人们在生命的早期就知道自己存在的理由是什么”，老人带着某种苦涩的语气说道。 “也许这就是他们这么早就放弃的原因。但事实就是这样”。 男孩提醒老人，他说过一些关于隐藏宝藏的事情。 “宝藏被流水的力量发掘出来，也被同样的水流埋葬”，老人说。 “如果你想了解你自己的宝藏，你就必须给我你羊群的十分之一”。 “那我的宝物十分之一呢？”。 老者一脸失望。 “如果你一开始就承诺你还没有得到的东西，你就会失去努力实现它的欲望”。 男孩告诉他，他已经答应将十分之一的宝藏送给吉普赛人。 “吉普赛人是让人们这样做的专家”，老人叹了口气。 “无论如何，很高兴你了解到生活中的一切都是有代价的。这就是光之战士试图教导的内容”。 老人把书还给了男孩。 “明天，同时，给我带来十分之一的羊群。我会告诉你如何找到隐藏的宝藏。下午好”。 然后他就消失在广场的拐角处。 男孩又开始看书，但他再也无法集中注意力了。 他既紧张又不安，因为他知道老人是对的。 他走到面包店买了一条面包，想着要不要告诉面包师老人对他的评价。 有时候，保持现状会更好，他心里想，然后决定什么也不说。 如果他要说什么，面包师会花三天的时间考虑放弃这一切，尽管他已经习惯了这种情况。 这个男孩当然可以抵制给面包师带来这种焦虑。 于是他开始在城里闲逛，发现自己已经到了城门口。 那里有一栋小楼，有一个窗口，人们可以在那里购买去非洲的机票。 他知道埃及位于非洲。 “我可以帮你吗？” 窗后的男人问道。 “也许明天，”男孩说着就走开了。 如果他只卖掉一只羊，就足够他到达海峡对岸了。 这个想法让他感到害怕。 “又一个梦想家”，售票员看着男孩走开，对他的助手说道。 “他没有足够的钱去旅行”。 当站在售票窗口时，男孩想起了他的羊群，并决定他应该回去当牧羊人。 两年的时间里，他学会了关于牧羊的一切：他知道如何剪羊毛，如何照顾怀孕的母羊，以及如何保护羊免受狼的侵害。 他熟悉安达卢西亚的所有田野和牧场。 他知道他的每一只动物的合理价格是多少。 他决定尽可能走最长的路返回朋友的马厩。 当他走过城市的城堡时，他中断了返回，爬上了通向城墙顶部的石坡。 从那里，他可以看到远处的非洲。 有人曾经告诉他，摩尔人就是从那里来的，占领了整个西班牙。 从他坐的地方，他几乎可以看到整个城市，包括他和老人谈话的广场。 诅咒我见到那个老人的那一刻，他想。 他来到小镇只是为了寻找一个能够解梦的女人。 无论是女人还是老人，对于他是牧羊人这一事实都没有留下深刻的印象。 他们是孤独的人，不再相信任何事物，也不明白牧羊人会依恋他们的羊。 他了解羊群中每个成员的一切：他知道哪些是跛子，哪些是两个月后就要生孩子的，哪些是最懒的。 他知道如何剪它们，也知道如何宰杀它们。 如果他决定离开他们，他们就会受苦。 风开始刮起来。 他了解那种风：人们称之为黎凡特风，因为摩尔人是乘风从地中海东端的黎凡特而来的。 黎凡特的强度增加了。 我就在这里，在我的羊群和我的宝藏之间，男孩想。 他必须在他已经习惯的东西和他想要拥有的东西之间做出选择。 还有商人的女儿，但她没有他的羊群那么重要，因为她不依赖他。 也许她根本就不记得他了。 他确信他出现的哪一天对她来说没有什么区别：对她来说，每一天都是一样的，当每一天都与下一天一样时，那是因为人们无法认识到生活中发生的美好事情 太阳升起的每一天。 我把父亲、母亲和城镇的城堡抛在了身后。 它们已经习惯了我的离开，我也是。羊也会习惯我的不在，男孩想。 从他坐的地方，可以眺望整个广场。 人们继续从面包店进进出出。 一对年轻夫妇坐在他与老人谈话的长凳上，他们接吻了。 “那个面包师……”他自言自语，但没有完成这个想法。 黎凡特的力量还在增强，他感觉到它的力量打在了他的脸上。 是的，那股风带来了摩尔人，但它也带来了沙漠和蒙着面纱的女人的气味。 它带来了那些曾经离开去寻找未知、黄金和冒险——以及金字塔的人们的汗水和梦想。 男孩嫉妒风的自由，也看到自己也能拥有同样的自由。 除了他自己，没有什么能阻止他。 羊、商人的女儿和安达卢西亚的田野只是他通往命运的几步之遥。 第二天中午，男孩遇见了老人。 他带来了六只羊。 “我很惊讶，”男孩说。 “我的朋友立即买下了所有其他的羊。他说他一直梦想成为一名牧羊人，这是一个好兆头”。 “一直都是这样，”老人说。 “这就是所谓的好感度原则，第一次打牌的时候，几乎肯定会赢，新手的运气”。 “这是为什么？”。 “因为有一种力量要你实现自己的命运，它吊着你的胃口，让你尝到成功的滋味”。 然后老人开始检查羊群，发现其中一只是跛脚的。 男孩解释说，这并不重要，因为那只羊是羊群中最聪明的，产的羊毛最多。 “宝藏在哪里？” 他问。 “它在埃及，靠近金字塔”。 男孩吓了一跳。 老妇人也说过同样的话。 但她没有向他收取任何费用。 “为了找到宝藏，你必须遵循预兆。上帝为每个人准备了一条道路，你只需要阅读他为你留下的预兆”。 还没等男孩回答，一只蝴蝶就出现在他和老人之间。 他想起祖父曾经告诉他的一句话：蝴蝶是好兆头。 喜欢蟋蟀，喜欢期待； 像蜥蜴和四叶草。 “没错。”老人说，他能读懂男孩的想法。 “就像你祖父教你的那样。这些都是好兆头”。 老人掀开斗篷，男孩被眼前的景象震惊了。 老人穿着一件重金胸甲，上面镶满了宝石。 男孩回想起前一天他注意到的光彩。 他真的是一个国王！ 他必须乔装打扮以避免遭遇小偷。 “拿着这些。”老者说道，同时拿出了镶嵌在胸甲中央的一块白色石头和一块黑色石头。 “它们被称为乌陵和土明。黑色表示‘是’，白色表示‘否’。当你无法解读预兆时，它们会帮助你做到这一点。始终提出客观的问题。 “但是，如果可以的话，尝试自己做决定。宝藏在金字塔里；你已经知道了。但我不得不坚持支付六只羊，因为我帮助你做出了决定”。 男孩把石头放进了他的袋子里。 从此以后，他将自己做决定。 “不要忘记，你所面对的一切都只是一件事，别无其他。不要忘记预兆的语言。而且，最重要的是，不要忘记跟随你的命运直到结局。 但在我走之前 ，我想给你讲一个小故事。 “某位店主派他的儿子去向世界上最聪明的人学习幸福的秘密。这个小伙子在沙漠中徘徊了四十天，终于来到了高高的山顶上一座美丽的城堡。就在那里， 然而，我们的英雄并没有找到一位圣人，而是在进入城堡的主厅时，看到了一片忙碌的景象：商人来来去去，人们在角落里交谈，一个小管弦乐队正在演奏轻柔的音乐。 ，桌子上摆满了世界上那个地方最美味的食物。智者与每个人交谈，男孩不得不等待两个小时才轮到他的注意。 智者认真地听着男孩解释自己来的原因，但告诉他现在没有时间解释幸福的秘密，建议男孩在宫殿里看看，两个小时后回来。 “我想请你做一件事。”智者说道，递给男孩一把装有两滴油的茶匙。 “当你四处走动时，随身携带这把勺子，不要让油溢出”。 男孩开始在宫殿的许多楼梯上爬上爬下，眼睛一直盯着勺子。 两个小时后，他回到了智者所在的房间。 “那么，”智者问道，“你看到挂在我餐厅里的波斯挂毯了吗？ 你看到园丁大师花了十年时间打造的花园了吗？ 你注意到我图书馆里漂亮的羊皮纸了吗？ 男孩很尴尬，承认他什么也没看到。 他唯一关心的是不要把智者托付给他的油洒出来。 “然后回去观察我的世界的奇迹吧。”智者说道。 “如果你不了解一个人的房子，你就无法信任他。” 男孩松了口气，拿起勺子，继续探索宫殿，这一次观察了天花板和墙壁上的所有艺术品。 他看到了花园、周围的群山、美丽的花朵以及挑选一切的品味。 回到智者身边后，他详细地讲述了他所看到的一切。 “但是我托付给你的那滴油在哪里呢？”智者问道。 男孩低头看了看手里的勺子，发现油已经不见了。 “好吧，我只能给你一条建议。”最聪明的智者说道。 “幸福的秘诀就是看到世界上所有的奇迹，并且永远不会忘记勺子上的油滴”。 牧羊人什么也没说。 他已经听懂了老国王给他讲的故事。 牧羊人可能喜欢旅行，但他永远不应该忘记他的羊。 老人看着男孩，双手合十，在男孩的头顶上做了几个奇怪的手势。 然后，他带着他的羊走开了。 8 塔里法的最高点有一座古老的堡垒，由摩尔人建造。 从城墙顶上，人们可以一睹非洲的风采。 那天下午，塞勒姆王麦基洗德坐在堡垒的墙上，感觉黎凡特风吹在他脸上。 羊群在附近坐立不安，对新主人感到不安，并对如此多的变化感到兴奋。 他们想要的只是食物和水。 麦基洗德看着一艘小船正驶出港口。 他再也见不到这个男孩了，就像他在向亚伯拉罕收取了十分之一的费用后再也没有见过亚伯拉罕一样。 那是他的工作。 神不应该有欲望，因为他们没有命运。 但塞勒姆国王迫切希望这个男孩能够成功。 可惜他很快就会忘记我的名字，他想。 我应该为他重复一遍。 然后当他谈到我时，他会说我是麦基洗德，撒冷王。 他仰望天空，有些羞愧地说道：“我知道，正如您所说，大人，这是虚荣中的虚荣。但是，一个老国王有时也必须为自己感到骄傲。” 9 非洲是多么奇怪啊，男孩想。 他坐在一家酒吧里，和他在丹吉尔狭窄的街道上见过的其他酒吧很像。 一些人正在用一根巨大的烟斗抽烟，他们将烟斗从一个烟斗传递到另一个烟斗。 在短短几个小时内，他看到男人们手拉手行走，女人们遮住脸，牧师们爬上塔顶吟诵圣歌——而他周围的每个人都跪下来，把额头放在地上。 “异教徒的做法”，他对自己说。 当他还是个孩子的时候，在教堂里，他总是看着圣地亚哥·马塔莫罗斯骑着白马、剑出鞘的图像，以及跪在他脚下的人物。 男孩感到很不舒服，而且非常孤独。 异教徒看上去很邪恶。 除此之外，在他匆忙的旅行中，他忘记了一个细节，只是一个细节，这可能会让他在很长一段时间内失去他的宝藏：这个国家只说阿拉伯语。 酒吧老板走近他，男孩指着邻桌提供的一杯饮料。 原来是苦茶。 这个男孩更喜欢酒。 但他现在不需要担心这个。 他要关心的是他的宝藏，以及他要如何得到它。 卖掉羊后，他的口袋里有了足够的钱，男孩知道金钱是有魔力的；他知道钱是有魔力的。 有钱的人永远不会真正孤独。 不久之后，也许仅仅几天，他就会到达金字塔。 一个戴着黄金胸甲的老人不会为了得到六只羊而撒谎。 老人谈到了征兆和预兆，而当男孩过海峡时，他也想到了预兆。 是的，老人知道他在说什么：男孩在安达卢西亚的田野里度过的那段时间，他已经习惯了通过观察地面和天空来了解自己应该走哪条路。 他发现某种鸟的存在意味着附近有蛇，而某种灌木则表明该地区有水。 羊教会了他这一点。 他想，如果上帝能如此有效地引导羊群，他也会引导一个人，这让他感觉好多了。 茶似乎不那么苦了。 “你是谁？” 他听到一个声音用西班牙语问他。 男孩松了口气。 他正想着预兆，有人出现了。 “你怎么会说西班牙语？” 他问。 新来的人是一名身穿西服的年轻人，但从他的肤色来看，他是这座城市的人。 他的年龄和身高与男孩差不多。 “这里几乎每个人都会说西班牙语。我们距离西班牙只有两个小时”。 男孩说道：“请坐，我请你吃点东西。” “帮我要一杯酒。我讨厌这茶”。 “这个国家没有酒”，年轻人说。 “这里的宗教禁止这样做”。 男孩当时告诉他，他需要去金字塔。 他几乎要开始讲述他的宝藏，但决定不这样做。 如果他这样做了，阿拉伯人可能会想要一部分作为带他去那里的报酬。 他记得老人说过要提供一些你还没有的东西。 “如果可以的话，我希望你带我去那里。我可以付钱给你当我的向导”。 “你知道怎么去那里吗？” 新人问道。 男孩注意到酒吧老板站在附近，聚精会神地听着他们的谈话。 他对这个男人的出现感到不安。 但他已经找到了向导，不想错过这个机会。 “你必须穿越整个撒哈拉沙漠”，年轻人说。 “要做到这一点，你需要钱。我需要知道你是否有足够的钱”。 男孩觉得这个问题很奇怪。 但他相信老人，老人说过，当你真心想要某样东西时，宇宙总会对你有利。 他从袋子里掏出钱给年轻人看。 酒吧老板也过来看了看。 两人用阿拉伯语交谈了几句，酒吧老板似乎很生气。 “我们离开这里吧。”新来的人说道。 “他要我们离开”。 男孩松了口气。 他起身去付账，但店主抓住了他，开始愤怒地对他说话。 男孩很坚强，想要报复，但他身在异国他乡。 他的新朋友把主人推到一边，把男孩拉到外面。 “他想要你的钱”，他说。 “丹吉尔和非洲其他地方不一样。这是一个港口，每个港口都有小偷”。 这个男孩信任他的新朋友。 他在危险的情况下帮助了他。 他拿出钱来数了数。 “我们明天就可以到达金字塔”，另一个人接过钱说道。 “但我必须买两只骆驼”。 他们一起走过丹吉尔狭窄的街道。 到处都有出售物品的摊位。 他们到达了一个举办集市的大广场的中心。 那里有成千上万的人，争论着，卖着，买着。 蔬菜在匕首中出售，地毯与烟草一起展示。 但男孩的目光始终没有离开他的新朋友。 毕竟，他已经拥有了所有的钱。 他考虑过要求他归还，但觉得这样不太友好。 他对异国他乡的风俗习惯一无所知。 “我只会看着他”，他对自己说。 他知道自己比他的朋友更强。 突然，在一片混乱之中，他看到了一把他所见过的最美丽的剑。 刀鞘上有银色浮雕，刀柄是黑色的，上面镶嵌着宝石。 男孩向自己保证，当他从埃及回来时，他会买那把剑。 “问问那个摊位的老板，这把剑多少钱”，他对他的朋友说。 然后他意识到自己有一会儿心不在焉地看着那把剑。 他的心一紧，仿佛胸口突然被压住了。 他不敢环顾四周，因为他知道会发现什么。 他又盯着那把美丽的剑看了一会儿，直到鼓起勇气转身。 周围都是集市，人来人往，叫卖声，买菜声，各种奇怪食物的香味……却找不到他的新同伴。 男孩想要相信他的朋友只是因为意外而与他分开。 他决定留在原地，等待他回来。 在他等待的过程中，一位牧师爬上附近一座塔顶并开始诵经。 市场上的所有人都跪倒在地，用额头触地，开始吟唱。 然后，像一群工蚁一样，他们拆除了摊位并离开了。 太阳也开始离去。 男孩沿着它的轨迹观察了一会儿，直到它隐藏在广场周围的白色房子后面。 他回忆起那天早上太阳升起的时候，他在另一个大陆，仍然是一个带着六十只羊的牧羊人，期待着与一个女孩的见面。 那天早上，当他走过熟悉的田野时，他就知道将会发生在他身上的一切。 但现在，当太阳开始落山时，他身处另一个国家，一个陌生土地上的陌生人，他甚至不会说当地的语言。 他不再是牧羊人，他一无所有，连回去重新开始的钱都没有。 这一切都发生在日出和日落之间，男孩想。 他为自己感到难过，并感叹自己的生活可能会如此突然、如此剧烈地改变。 他羞得想哭。 他甚至从未在自己的羊面前哭泣过。 但市场空无一人，又远离家乡，他就哭了。 他哭是因为上帝不公平，因为这就是上帝报答那些相信梦想的人的方式。 当我拥有我的羊时，我很高兴，我也让周围的人感到高兴。 人们看到我来了就欢迎我，他想。 但现在我感到悲伤和孤独。 我会因为一个人背叛了我而变得痛苦和不信任别人。 我会恨那些找到了宝藏的人，因为我从未找到过我的宝藏。 我会紧紧抓住我所拥有的一切，因为我太渺小了，无法征服世界。 他打开袋子，看看还剩下什么东西。 也许他在船上吃的三明治还剩下一点。 但他只找到了那本厚重的书、他的夹克和老人给他的两块石头。 看着这些石头，他不知道为什么心里松了口气。 他用六只羊换了两块从金胸甲上取下的宝石。 他可以卖掉石头，买回程票。 但这一次我会更聪明，男孩想，把它们从袋子里拿出来，这样他就可以把它们放进口袋里。 这是一个港口城镇，他的朋友告诉他的唯一真实的事情就是港口城镇充满了小偷。 现在他明白酒吧老板为何如此不高兴了：他是想告诉他不要相信那个人。 “我和其他人一样——我根据我希望看到发生的事情来看待世界，而不是实际发生的事情”。 他用手指慢慢地抚过石头，感受它们的温度和表面。 他们是他的宝藏。 光是处理它们就让他感觉好多了。 他们让他想起了那个老人。 他曾说过：“当你想要某样东西时，整个宇宙都会齐心协力帮助你实现它”。 男孩试图理解老人所说的话的真相。 他在空荡荡的市场里，身无分文，也没有一只羊可以守夜。 但这些石头证明他曾见过一位国王——一位知道男孩过去的国王。 “他们被称为乌陵和土明，他们可以帮助你解读预兆”。 男孩把石头放回袋子里，决定做一个实验。 老人说要问非常明确的问题，要做到这一点，男孩必须知道他想要什么。 于是，他询问老人的福气还在吗？ 他取出了其中一颗石头。 答案是“是”。 “我能找到我的宝藏吗？” 他问。 他把手伸进袋子里，摸索着寻找其中一颗石头。 当他这样做的时候，他们俩都从袋子上的一个洞里钻了出去，跌倒在地上。 这个男孩甚至从未注意到他的育儿袋上有一个洞。 他跪下来找到乌陵和土明，把它们放回袋子里。 但当他看到躺在地上的他们时，他的脑海里又浮现出另外一句话。 老国王曾说过：“学会识别预兆，并遵循它们”。 一个预兆。 男孩对自己笑了笑。 他捡起两块石头，放回自己的袋子里。 他没有考虑修补这个洞——石头随时都可能掉进去。 他知道，有些事情不应该过问，以免逃避自己的命运。 “我答应过我会自己做决定”，他对自己说。 但石头告诉他，老人还在他身边，这让他更有信心了。 他再次环顾四周空荡荡的广场，感觉不像以前那么绝望了。 这并不是一个奇怪的地方；这是一个奇怪的地方。 这是一件新的。 毕竟，他一直想要的只是：认识新的地方。 即使他从未到达金字塔，他也已经比他认识的任何牧羊人走得更远了。 哦，如果他们知道距离他们所在的地方只有两个小时的船程有多么不同，他想。 虽然现在他的新世界只是一个空荡荡的市场，但生机勃勃的时候他已经见过了，他永远不会忘记。 他想起了那把剑。 想到这里他就有点心痛，但他以前从未见过这样的人。 当他沉思这些事情时，他意识到自己必须在将自己视为小偷的可怜受害者和寻找宝藏的冒险家之间做出选择。 “我是一个冒险家，正在寻找宝藏”，他对自己说。 10 他被某人摇醒了。 他在市场中央睡着了，广场上的生活即将恢复。 他环顾四周，寻找他的羊，然后意识到自己来到了一个新世界。 但他非但没有悲伤，反而感到高兴。 他不再需要为羊寻找食物和水； 相反，他可以去寻找他的宝藏。 他口袋里一分钱都没有，但他有信心。 前一天晚上，他就决定要像他在书中所崇拜的那样，成为一名冒险家。 他慢慢地穿过市场。 商人们正在布置他们的摊位，男孩帮助一个糖果摊贩布置他的摊位。 卖糖的小贩脸上挂着笑容：他很高兴，知道自己的生活是什么，准备开始一天的工作。 他的笑容让男孩想起了那个老人——他见过的神秘的老国王。 “这个糖果商人生产糖果不是为了以后他可以旅行或娶店主的女儿。 他这样做是因为这是他想做的事，”男孩想。他意识到他可以做老人做过的同样的事情——感知一个人离他的命运是否接近或遥远。只要看着他们。 这很容易，但我以前从未这样做过，他想。 当摊位收拾完毕后，糖果小贩给了男孩他当天做的第一块糖果。 男孩谢过他，吃了它，然后继续上路。 走了没多远，他就发现，他们摆摊的时候，一个说阿拉伯语，另一个说西班牙语。 他们彼此非常了解。 一定有一种不依赖于文字的语言，男孩想。 我已经在我的羊身上经历过这种经历，现在它也发生在人们身上。 他正在学习很多新东西。 有些是他已经经历过的事情，并不是什么新鲜事，但他以前从未察觉过。 他没有察觉到它们，因为他已经习惯了它们。 他意识到：如果我能学会理解这种无需文字的语言，我就能学会理解世界。 他轻松而从容地决定步行穿过丹吉尔狭窄的街道。 只有这样，他才能解读预兆。 他知道这需要很大的耐心，但牧羊人都知道耐心。 他再次看到，在那片陌生的土地上，他正在应用他在羊身上学到的同样的教训。 老人说：“万物皆一”。 11 水晶商人随着白天的醒来，感受到了每天早晨同样的焦虑。 他已经在同一个地方呆了三十年了：一家位于山街顶上的商店，很少有顾客经过。 现在改变任何事情都为时已晚——他唯一学会做的就是买卖水晶玻璃器皿。 曾经有一段时间，很多人都知道他的店：阿拉伯商人、法国和英国地质学家、总是富有的德国士兵。 那时候，卖水晶是一件很美好的事，他想过随着年龄的增长，自己会变得有钱，身边会有美女相伴。 但随着时间的推移，丹吉尔已经发生了变化。 附近的休达市的发展速度比丹吉尔快，但生意却在下滑。 邻居们都搬走了，山上只剩下几家小商店。 没有人会为了逛几家小商店而爬上山。 但水晶商人也没有办法。 他一生中三十年都在买卖水晶，现在做其他事已经太晚了。 他花了整个上午的时间观察街上稀有的人来人往。 他这样做已经很多年了，知道每个经过的人的日程安排。 但是，就在午餐时间之前，一个男孩停在了商店门前。 他的穿着很平常，但水晶商人老练的眼睛却看出这男孩没有钱花。 尽管如此，商人还是决定推迟几分钟吃午餐，直到男孩继续前进。 12 门口挂着一张卡片，上面写着店里有多种语言。 男孩看到一个男人出现在柜台后面。 “如果你愿意的话，我可以清理窗户上的玻璃，”男孩说。 “从它们现在的样子来看，没有人会想买它们”。 男人看着他，没有回应。 “作为交换，你可以给我一些吃的。” 男人仍然没有说话，男孩感觉到他必须做出决定。 他的袋子里有他的夹克——他在沙漠里肯定不需要它。 他脱下外套，开始擦眼镜。 半个小时的时间，他就把橱窗里的玻璃都擦干净了，正当他这样做的时候，店里进来了两个顾客，买了一些水晶。 打扫完后，他向那人要吃的。 “走吧，去吃午饭吧。”水晶商人说道。 他在门上贴了一个牌子，然后他们去了附近的一家小咖啡馆。 当他们在唯一一张桌子坐下时，水晶商人笑了。 “你不需要做任何清洁工作”，他说。 “《古兰经》要求我喂饱饥饿的人”。 “那你为什么让我这么做呢？” 男孩问道。 “因为水晶很脏。你和我都需要清除我们头脑中的消极想法”。 吃完饭后，商人对男孩说：“我想让你到我的店里工作。今天你工作的时候进来了两个顾客，这是个好兆头。” 人们经常谈论预兆，牧羊人想。 但他们真的不知道自己在说什么。 正如我没有意识到，这么多年以来，我一直在对我的羊说一种没有文字的语言。 “你愿意去为我工作吗？” 商人问道。 “今天剩下的时间我可以工作”，男孩回答。 “我会工作一整夜，直到天亮，我会清理你们店里的每块水晶。作为回报，我需要明天去埃及的钱”。 商人笑道。 “即使你清理我的水晶一整年……即使你卖掉每件水晶都能赚到不错的佣金，你仍然需要借钱才能去埃及。这里和那里之间有数千公里的沙漠”。 片刻的寂静如此深沉，整个城市似乎都睡着了。 集市上没有任何声音，商人之间没有争论，没有人爬上塔楼吟诵。 没有希望，没有冒险，没有古老的国王或命运，没有宝藏，也没有金字塔。 世界仿佛因为男孩的灵魂而变得寂静。 他坐在那里，呆呆地看着咖啡馆的门外，希望自己已经死了，一切都在那一刻永远结束。 商人焦急地看着男孩。 那天早上他所看到的所有喜悦突然消失了。 “我可以给你回国所需的钱，我的孩子，”水晶商人说道。 男孩什么也没说。 他起身，整理了一下衣服，拿起了袋子。 “我会为你工作”，他说。 经过长时间的沉默，他补充道，“我需要钱买一些羊”。","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"炼金术士","slug":"炼金术士","permalink":"http://example.com/tags/%E7%82%BC%E9%87%91%E6%9C%AF%E5%A3%AB/"}]},{"title":"炼金术士2-序幕","slug":"认知-修行-平衡/炼金术士2-序幕","date":"2024-04-03T02:55:30.000Z","updated":"2024-04-07T01:23:28.734Z","comments":true,"path":"2024/04/03/认知-修行-平衡/炼金术士2-序幕/","link":"","permalink":"http://example.com/2024/04/03/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/%E7%82%BC%E9%87%91%E6%9C%AF%E5%A3%AB2-%E5%BA%8F%E5%B9%95/","excerpt":"","text":"Paulo Coelho 保罗·科埃略 炼金术士拿起商队中有人带来的一本书。翻开书，他发现了一个关于水仙的故事。 炼金术士知道水仙的传说，水仙是一个每天跪在湖边思考自己的美丽的青年。他被自己深深吸引，一天早晨，他掉进湖里淹死了。在他掉下去的地方，诞生了一朵花，人们称它为水仙。 但书的作者并没有这样结束故事。 他说，水仙死后，森林女神出现了 发现淡水湖变成了咸泪湖 “你为什么哭泣？”女神问。 湖水回答说：”我为水仙哭泣”。 “啊，你为水仙哭泣并不奇怪”，他们说，”虽然我们总是在森林里追逐他，但只有你能近距离欣赏他的美”。 “可是……水仙美吗？”湖水问道。 “有谁比你更清楚呢？”女神们惊奇地说。”毕竟，他每天都跪在你的河畔沉思！”。 湖水沉默了一会儿。最后，它说： “我为水仙哭泣，但我从未注意到水仙的美丽。我哭泣是因为，每当他跪在我的河岸旁，我都能从他的眼睛深处看到我自己的美丽”。 炼金术士想：”多么可爱的故事啊”。","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"炼金术士","slug":"炼金术士","permalink":"http://example.com/tags/%E7%82%BC%E9%87%91%E6%9C%AF%E5%A3%AB/"}]},{"title":"炼金术士1-前言","slug":"认知-修行-平衡/炼金术士1-前言","date":"2024-04-03T02:49:30.000Z","updated":"2024-04-08T01:49:18.069Z","comments":true,"path":"2024/04/03/认知-修行-平衡/炼金术士1-前言/","link":"","permalink":"http://example.com/2024/04/03/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/%E7%82%BC%E9%87%91%E6%9C%AF%E5%A3%AB1-%E5%89%8D%E8%A8%80/","excerpt":"","text":"Paulo Coelho 保罗·科埃略 “一天晚上，当他们仰望无月的天空时，男孩对炼金术士说：”我的心害怕受苦”。告诉你的心，对苦难的恐惧比苦难本身更可怕。没有一颗心在追寻梦想的过程中受过苦难”。 每隔几十年，就会出版一本永远改变读者生活的书。《炼金术士》就是这样一本书。《炼金术士》已在全球售出一百五十多万册，成为举世推崇的现代经典。保罗-科埃略这本迷人的寓言故事现在首次以英文面世，它将使更多的读者为之着迷，并激励他们世世代代继续阅读下去。 《炼金术士》讲述了一个神奇的故事：安达卢西亚牧羊少年圣地亚哥渴望旅行，寻找前所未有的世间珍宝。他从西班牙的家出发，前往丹吉尔的市场，穿越埃及沙漠，与炼金术士进行了一次命运的邂逅。 圣地亚哥沿途发现宝藏的故事告诉我们，倾听内心的声音、学会解读散落在人生道路上的预兆，以及最重要的是追随梦想，这些都是至关重要的智慧。","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"炼金术士","slug":"炼金术士","permalink":"http://example.com/tags/%E7%82%BC%E9%87%91%E6%9C%AF%E5%A3%AB/"}]},{"title":"停一停 心呼吸 每日銘言 202404","slug":"认知-修行-平衡/心青年-202404","date":"2024-04-01T00:31:33.000Z","updated":"2024-04-08T01:01:22.278Z","comments":true,"path":"2024/04/01/认知-修行-平衡/心青年-202404/","link":"","permalink":"http://example.com/2024/04/01/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/%E5%BF%83%E9%9D%92%E5%B9%B4-202404/","excerpt":"","text":"日期 銘言 4月8号 4月7号 4月5号 4月4号 4月3号 4月2号 4月1号","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"佛学","slug":"佛学","permalink":"http://example.com/tags/%E4%BD%9B%E5%AD%A6/"}]},{"title":"Notes on Chainlink Bootcamp 2024 (10 Days)","slug":"Web3/chainlink_bootcamp2024","date":"2024-03-12T05:55:30.000Z","updated":"2024-03-16T08:07:46.072Z","comments":true,"path":"2024/03/12/Web3/chainlink_bootcamp2024/","link":"","permalink":"http://example.com/2024/03/12/Web3/chainlink_bootcamp2024/","excerpt":"","text":"| Chainlink Bootcamp 2024 Agenda PPT Bootcamp 2024&#x2F;01 Day 1-","categories":[{"name":"技能-修行-进步-Web3","slug":"技能-修行-进步-Web3","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Web3/"}],"tags":[{"name":"chainlink","slug":"chainlink","permalink":"http://example.com/tags/chainlink/"}]},{"title":"人生建立系统，而不是目标","slug":"认知-修行-平衡/build-system-not-goal","date":"2024-03-10T08:32:30.000Z","updated":"2024-03-14T08:09:17.337Z","comments":true,"path":"2024/03/10/认知-修行-平衡/build-system-not-goal/","link":"","permalink":"http://example.com/2024/03/10/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/build-system-not-goal/","excerpt":"","text":"人生建立系统，而不是目标| 目标有助于确定你的方向，而系统最有助于取得进展。- James Clear 《原子习惯》作者 什么是系统？ 什么是目标？ 参考资料 一个将改变你生活的观点，建立系统而不是目标-Neula PKM 豆瓣笔记-强烈推荐我的改命之书：《我的人生样样稀松照样赢》","categories":[{"name":"技能-修行-平衡","slug":"技能-修行-平衡","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"建立系统","slug":"建立系统","permalink":"http://example.com/tags/%E5%BB%BA%E7%AB%8B%E7%B3%BB%E7%BB%9F/"}]},{"title":"fundme dapp开发","slug":"Web3/solidity/03-fundme_dapp","date":"2024-03-06T02:02:30.000Z","updated":"2024-03-06T02:16:08.546Z","comments":true,"path":"2024/03/06/Web3/solidity/03-fundme_dapp/","link":"","permalink":"http://example.com/2024/03/06/Web3/solidity/03-fundme_dapp/","excerpt":"","text":"项目背景 在学习完solidity的基础知识后的第一个实践项目。 捐款项目主要功能 任何人可以进行捐款，捐款有最低额度限制 只有合约部署者能进行提款 使用的是ETH&#x2F;USD，需要导入chainlink预言机查找eth实时价格 本项目中涉及的solidity知识： 库（library）的使用 接口（interface）的使用 关键字payable的使用, transfer, send, call三种方法的区别，receive() external payable{} 和 fallback() external payable{} 关键字internal和external的用法 address(this).balance，msg.sender msg.value 如何优化gas，例如使用constant，immutable等关键字定义相关变量，custom error emit日志使用方法 chainlink预言机的调用 项目UML图 chainlink预言机的调用 chainlink学习","categories":[{"name":"技能-修行-进步-Web3","slug":"技能-修行-进步-Web3","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Web3/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"http://example.com/tags/solidity/"}]},{"title":"认识塔罗牌","slug":"taro_cards/00_认识塔罗牌","date":"2024-03-01T04:22:30.000Z","updated":"2024-03-16T05:57:16.468Z","comments":true,"path":"2024/03/01/taro_cards/00_认识塔罗牌/","link":"","permalink":"http://example.com/2024/03/01/taro_cards/00_%E8%AE%A4%E8%AF%86%E5%A1%94%E7%BD%97%E7%89%8C/","excerpt":"","text":"","categories":[{"name":"技能-修行-塔罗","slug":"技能-修行-塔罗","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E5%A1%94%E7%BD%97/"}],"tags":[{"name":"塔罗牌","slug":"塔罗牌","permalink":"http://example.com/tags/%E5%A1%94%E7%BD%97%E7%89%8C/"}]},{"title":"chainlink学习","slug":"Web3/solidity/chainlink_study","date":"2024-03-01T04:22:30.000Z","updated":"2024-03-16T02:19:18.521Z","comments":true,"path":"2024/03/01/Web3/solidity/chainlink_study/","link":"","permalink":"http://example.com/2024/03/01/Web3/solidity/chainlink_study/","excerpt":"","text":"chainlink official ChatGPT生成： Chainlink 是一个去中心化的预言机网络，旨在连接区块链智能合约与外部数据源、API 和传统金融市场。它的目标是解决区块链智能合约无法直接获取外部数据的问题，从而使得智能合约能够更加智能和功能丰富。 主要特点和功能包括： 外部数据接入： Chainlink 允许区块链智能合约访问外部的数据源，包括网络 API、传感器数据、天气数据、金融市场数据等。这些数据可以用于触发智能合约的执行或影响其状态。 数据验证和可信性： Chainlink 提供了一套机制来验证外部数据的真实性和可信度，以确保数据的准确性和安全性。这包括使用多个数据源、数据签名、可信执行环境等技术。 可编程性和灵活性： Chainlink 允许开发人员根据自己的需求定义和部署预言机网络，从而实现各种不同类型的数据访问和验证。它提供了灵活的合约编程接口和工具，使开发人员能够根据应用场景定制预言机网络。 安全和去中心化： Chainlink 采用去中心化的设计和安全机制，确保数据访问和验证的安全性和可靠性。它使用区块链技术和密码学算法来保护数据的安全，并通过分散化的节点网络来提供服务。 可扩展性和互操作性： Chainlink 的设计具有良好的可扩展性和互操作性，可以与各种不同的区块链平台和智能合约系统集成，实现跨链数据访问和交互。 总的来说，Chainlink 是一个重要的基础设施项目，为区块链智能合约提供了可靠的外部数据访问和验证机制，推动了区块链技术在金融、保险、供应链等领域的应用和发展。 让我们开始吧 官网开发者文档6大板块功能 Chainlink Web3 服务可分为三大类 数据 data data feeds data streams functions 计算 compute VRF Automation 跨链 cross-chain CCIP Data Feeds 喂价 业务流程 技术架构 用户案例 Functions 函数 业务流程 用户案例 VRF 随机数 业务流程 CCIP 跨链 业务流程 reference Chainlink产品讲解-Frank","categories":[{"name":"技能-修行-进步-Web3","slug":"技能-修行-进步-Web3","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Web3/"}],"tags":[{"name":"chainlink","slug":"chainlink","permalink":"http://example.com/tags/chainlink/"}]},{"title":"openzeppelin学习","slug":"Web3/solidity/openzepplin_study","date":"2024-03-01T04:22:30.000Z","updated":"2024-03-01T04:41:47.297Z","comments":true,"path":"2024/03/01/Web3/solidity/openzepplin_study/","link":"","permalink":"http://example.com/2024/03/01/Web3/solidity/openzepplin_study/","excerpt":"","text":"openzeppelin official ChatGPT生成： OpenZeppelin 是一个开源的智能合约库和开发框架，它提供了一系列已经经过安全审计和测试的通用智能合约，帮助开发人员构建安全、可靠的去中心化应用（DApps）和智能合约。 主要功能和特点包括： 安全的智能合约： OpenZeppelin 提供了一系列经过审计和测试的智能合约，涵盖了代币标准（如 ERC-20、ERC-721）、众筹合约、权限管理、多重签名钱包等常用的智能合约模块。这些合约已经被广泛使用，并得到了社区的认可和信任。 模块化设计： OpenZeppelin 的智能合约库采用了模块化的设计，使得开发人员可以根据自己的需求选择性地使用其中的部分功能。这样可以提高代码的可重用性和可维护性。 安全审计： OpenZeppelin 的智能合约经过了严格的安全审计和测试，以确保合约的安全性和可靠性。它们经过了专业的安全团队的审查，并且经过了时间的验证，已被广泛应用于生产环境中。 社区支持： OpenZeppelin 拥有一个庞大的开发者社区，其中包括了来自世界各地的开发者、安全专家和区块链爱好者。开发者可以在社区中分享经验、提出问题、提交问题报告和贡献代码。 开发工具和文档： OpenZeppelin 提供了丰富的开发工具和文档，包括代码示例、开发指南、安全建议等，帮助开发人员快速入门和使用 OpenZeppelin 的智能合约库。 总的来说，OpenZeppelin 是一个功能丰富、安全可靠的智能合约库和开发框架，为开发人员提供了构建安全、可靠的去中心化应用的重要工具和资源。 让我们开始吧","categories":[{"name":"技能-修行-进步-Web3","slug":"技能-修行-进步-Web3","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Web3/"}],"tags":[{"name":"openzeppelin","slug":"openzeppelin","permalink":"http://example.com/tags/openzeppelin/"}]},{"title":"停一停 心呼吸 每日銘言 202403","slug":"认知-修行-平衡/心青年-202403","date":"2024-03-01T01:01:33.000Z","updated":"2024-04-01T00:32:03.210Z","comments":true,"path":"2024/03/01/认知-修行-平衡/心青年-202403/","link":"","permalink":"http://example.com/2024/03/01/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/%E5%BF%83%E9%9D%92%E5%B9%B4-202403/","excerpt":"","text":"日期 銘言 3月31号 3月30号 3月29号 3月28号 3月27号 3月26号 3月25号 3月24号 3月23号 3月22号 3月21号 3月20号 3月19号 3月18号 3月17号 3月16号 3月15号 3月14号 3月13号 3月12号 3月11号 3月10号 3月9号 3月8号 3月6号 3月5号 3月4号 3月3号 3月2号 3月1号","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"佛学","slug":"佛学","permalink":"http://example.com/tags/%E4%BD%9B%E5%AD%A6/"}]},{"title":"solidity高级主题","slug":"Web3/solidity/02-solidity高级主题","date":"2024-02-28T07:01:30.000Z","updated":"2024-03-19T00:55:48.087Z","comments":true,"path":"2024/02/28/Web3/solidity/02-solidity高级主题/","link":"","permalink":"http://example.com/2024/02/28/Web3/solidity/02-solidity%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/","excerpt":"","text":"高级主题目录继承 inheritance Solidity继承 关键字is，合约继承父合约 对于变量和函数，如果父合约中的权限是private则不能被子合约继承 对于变量，如果父合约中的权限是internal和public，则能被子合约继承，而如果是external时就不能继承 对于函数，如果父合约中的权限是internal和public, 则能被子合约继承，而如果是external时也能继承，但是在调用时使用的是：this.functionName() ChatGPT生成： Internal Protected： Solidity 0.8.0 版本引入了 internal protected 关键字修饰符，用于在派生合约中继承父合约的 internal 变量。这样的变量在父合约中是 internal 访问权限，但在派生合约中则是 protected 访问权限。 示例：internal protected uint256 myVariable; 抽象合约 abstract Solidity抽象合约 抽象合约是不能被实例化的合约，只能被继承 抽象合约中的函数不能有实现 抽象合约中的函数不能是private 抽象合约中的函数不能是external 抽象合约中的函数不能是pure 抽象合约中的函数不能是view 抽象合约中的函数不能是payable 抽象合约中的函数不能是internal 抽象合约中的函数不能是public 抽象合约中的函数不能是final 抽象合约中的函数不能是override 抽象合约中的函数不能是virtual 抽象合约中的函数不能是external 抽象合约中的函数不能是constant 抽象合约中的函数不能是immutable 抽象合约中的函数不能是stateMutability 抽象合约中的函数不能是returns 接口 interface Solidity接口 无法实现任何功能 可以继承其他接口 所有声明的函数必须是外部的 无法声明构造函数, 无法声明状态变量 库函数 library Solidity库函数，一种函数集合-library 库与合约类似，但你不能声明任何状态变量，也不能发送以太币。 库的目的是重用代码，库的函数可以被其他合约调用。 如果所有库函数都是内部的，则库将嵌入到合约中。否则，必须在部署合约之前部署并链接库。 多态 polymorphism Solidity多态 异常处理 exception Solidity异常处理 安全性 security Solidity安全性 日志 log event(), emit()","categories":[{"name":"技能-修行-进步-Web3","slug":"技能-修行-进步-Web3","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Web3/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"http://example.com/tags/solidity/"}]},{"title":"什么是视觉语言？","slug":"技能-修行-进步-影视图像/视觉模式","date":"2024-02-27T11:43:30.000Z","updated":"2024-02-29T10:23:49.165Z","comments":true,"path":"2024/02/27/技能-修行-进步-影视图像/视觉模式/","link":"","permalink":"http://example.com/2024/02/27/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-%E5%BD%B1%E8%A7%86%E5%9B%BE%E5%83%8F/%E8%A7%86%E8%A7%89%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"视觉语言-Visual Language 定义：视觉语言和书面语言一样，是一种传达信息的方式，是一种视觉传达的方式。 人们常说没有既定的规则，因为通常规则都是用来打破的。(“Rules are meant to be broken.”)，但这是一个谎言，因为在视觉语言中，有很多规则是可以遵循的，这就是所谓的模式(pattern)。 Patterns have implied meanings. 模式是有隐含意义的。 视觉模式的本质就是拍摄的规则的组合。 视觉语言的基本元素Frame - 框架 正方形，三角形，圆形等各种框框用来突出主题，这就是框架。 Negative Space - 负空间 既然有负空间，那么就有正空间，positive space，正空间是指画面中有主题的地方。 负空间是指画面中除了主题以外的地方，有空白空间(empty space)和填充空间(fulfill space)2种，负空间可以用来辅助突出主题，这就是负空间。 Leading lines - 引导线 定义：引导线是指画面中的线条，用来引导观众的视线，这就是引导线。(Elements in your image that direct the viewer’s eye to where you want them to look.) Color Theory - 颜色理论 Hue Saturation Luminosity Temperature (HSL) - 色相 饱和度 亮度 冷暖色 color model - 色彩模型 YMCK 通常在打印时使用 - 黄 青 洋红 黑 RGB 通常在数位显示器上使用 - 红 绿 蓝 sRGB 标准RGB 由于不同文化对颜色的理解不同，所以颜色的意义也不同。以下是一些常见的颜色的意义： Color harmoney - 色彩和谐 adobe color Analogous - 相似色 Complementary - 互补色 Monochromatic - 单色 Constract - 对比度 tonal contrast - 色调对比 color contrast - 色彩对比 conceptual contrast - 概念对比 Visual hierarchy - 视觉层次 内容异常的主观 Scale - 尺度 参考点 Composition and position - 构图和位置 the rule of thirds - 三分法 angle - 角度 golden ratio - 黄金比例 Balance - 平衡 可以令人放松的组合 Pattern Analysis - 模式分析-","categories":[{"name":"技能-修行-进步-影视图像","slug":"技能-修行-进步-影视图像","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-%E5%BD%B1%E8%A7%86%E5%9B%BE%E5%83%8F/"}],"tags":[{"name":"摄影","slug":"摄影","permalink":"http://example.com/tags/%E6%91%84%E5%BD%B1/"},{"name":"视觉语言","slug":"视觉语言","permalink":"http://example.com/tags/%E8%A7%86%E8%A7%89%E8%AF%AD%E8%A8%80/"}]},{"title":"拍照原理 Photography Theory","slug":"技能-修行-进步-影视图像/拍照原理","date":"2024-02-24T02:41:30.000Z","updated":"2024-02-27T14:11:56.546Z","comments":true,"path":"2024/02/24/技能-修行-进步-影视图像/拍照原理/","link":"","permalink":"http://example.com/2024/02/24/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-%E5%BD%B1%E8%A7%86%E5%9B%BE%E5%83%8F/%E6%8B%8D%E7%85%A7%E5%8E%9F%E7%90%86/","excerpt":"","text":"拍照的核心：对光线的控制和管理，就是曝光的程度。 曝光-Exposure 曝光越多，进光量越大，画面越亮。 曝光越少，进光量越小，画面越暗。 曝光的单位是EV，EV&#x3D;光圈值+快门值+ISO值。 曝光三要素-Exposure Triangle快门-Shutter Speed 光线通过镜头进入相机的过程中，经过3个部分：镜头-&gt;快门-&gt;感光元件，而控制快门就是控制感光元件接收光线的时间。 快门越快，进光量越小，运动越清晰。 快门越慢，进光量越大，运动越模糊。 快门速度的单位是秒，1&#x2F;1000秒是快门速度，1秒是慢门速度。 光圈-Aperture “景深”是指当焦距对准某一点时，其前后都仍可清晰的范围。通常肖像需要小景深，风景需要大景深。 光圈越大，进光量越大，景深越小。 光圈越小，进光量越小，景深越大。 光圈大小的单位是F，F越小，光圈越大。 光圈大小的单位是F，F越大，光圈越小。 光圈大小的单位是F，F&#x3D;焦距&#x2F;光圈直径。 感光度-ISO ISO越高，进光量越大，画质越差。 ISO越低，进光量越小，画质越好。 ISO的单位是ISO，100是低感光度，1600是高感光度。 三要素的关系 在快门和光圈都调正确的情况下，ISO越低，画质越好。所以通常情况下，先调快门和光圈，再调ISO。 拍照通常考虑问题的顺序： 首先确定拍摄画面是动态的还是静态的，调节快门。 然后考虑景深的问题，如果需要大景深，就调小光圈，如果需要小景深，就调大光圈。 最后考虑画质的问题，调节ISO。 Trouble Shooting 如果光线太暗，可以调大光圈，调慢快门，调高ISO。 如果光线太亮，可以调小光圈，调快快门，调低ISO。 参考资料 镜头的基础知识系列：光圈和景深-sony China","categories":[{"name":"技能-修行-进步-影视图像","slug":"技能-修行-进步-影视图像","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-%E5%BD%B1%E8%A7%86%E5%9B%BE%E5%83%8F/"}],"tags":[{"name":"摄影","slug":"摄影","permalink":"http://example.com/tags/%E6%91%84%E5%BD%B1/"},{"name":"影像","slug":"影像","permalink":"http://example.com/tags/%E5%BD%B1%E5%83%8F/"}]},{"title":"停一停 心呼吸 每日銘言 202402","slug":"认知-修行-平衡/心青年-202402","date":"2024-02-23T01:01:33.000Z","updated":"2024-03-02T12:27:32.320Z","comments":true,"path":"2024/02/23/认知-修行-平衡/心青年-202402/","link":"","permalink":"http://example.com/2024/02/23/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/%E5%BF%83%E9%9D%92%E5%B9%B4-202402/","excerpt":"","text":"日期 銘言 2月29号 2月28号 2月27号 2月26号 2月23号 2月22号","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"佛学","slug":"佛学","permalink":"http://example.com/tags/%E4%BD%9B%E5%AD%A6/"}]},{"title":"我的情绪为何总被他人左右-读书笔记","slug":"books/2024/first-half/我的情绪为何总被他人左右","date":"2024-02-22T09:37:30.000Z","updated":"2024-02-22T10:11:29.604Z","comments":true,"path":"2024/02/22/books/2024/first-half/我的情绪为何总被他人左右/","link":"","permalink":"http://example.com/2024/02/22/books/2024/first-half/%E6%88%91%E7%9A%84%E6%83%85%E7%BB%AA%E4%B8%BA%E4%BD%95%E6%80%BB%E8%A2%AB%E4%BB%96%E4%BA%BA%E5%B7%A6%E5%8F%B3/","excerpt":"","text":"一个人一直在重复3件事：thinking思考，feeling感受，acting行为，3者互相影响 人的认知决定思考的高度，思考会产生情绪感受，同时影响人的行为。 一个被忽略的事实：人的焦虑抑郁或者不开心并不是当前发生的事情，而是发生的事情给你带来的感受feeling情绪，所以通常人是容易被自己的不好的感受和情绪勒索，困住自己的通常是自己的内心。 通常对人产生负面的feelings包含以下四种，被称为“致命四人组”： 它们有一个共同的副词：过分，过分是极端主义的代表。不理智的人儿都容易从一个极端走到另一个极端。 诱因ABC’s 编号 具体 解析 A 触发事件 诱因 B 3种病态思维方式（screw ball thinking）1. 第一种叫灾难性思维方式（catastrophic thinking）；2. 第二种病态思维方式被称作绝对论者思维方式（absolutist thinking）；3. 第三种类型的神经病想法恰好是另一个极端：合理化（rationalization）合理化就是弱反应。 过程 C 失当的感受和行为 结果 10中疯狂的非理性信条 编号 非理性信条 1 我太在乎别人怎么看待你。 2 我决不能在重要任务上失败（生意上，学业，体育项目，性生活，关系等），否则太可怕了，我无法忍受。 3 人和事都应该总是朝我要他们去的方向发展，如果不是，那就太糟糕、太可怕、太恐怖了，我无法忍受！ 4 如果前面三种坏事中的任何一种出现了（如果我不讨喜或不被尊重，如果我失败了，或结果不像我想的那样好或至少过得去），我总要找个人骂骂才痛快！他们做错了，早就不该这么做，事情做得那么糟糕，一帮烂人！ 5 假如我对即将发生的事或别人对我的看法抱有挥之不去的忧虑，当事情真发生时，定会比我想象的要好。 6 每个问题都有完美的解决方法，我必须立即找到这些方法！ 7 逃避困境和责任比正视它们要容易得多。 8 如果我事事不投入，只保持若即若离的关注，我会永远开心。 9 我的过去、小时候、最近恋情和最近工作中发生的所有可怕的事造成了我此时的感觉和行为。 10 坏人坏事应该存在，当它们的确存在时，我真不知道该怎么办才好！ 解决问题的框架REBT(Rational Emotive Behavior Therapy)，理性情绪行为疗法","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"自愈, 情绪管理","slug":"自愈-情绪管理","permalink":"http://example.com/tags/%E8%87%AA%E6%84%88-%E6%83%85%E7%BB%AA%E7%AE%A1%E7%90%86/"}]},{"title":"区块链白皮书与轶事","slug":"Web3/区块链轶事","date":"2023-09-04T04:04:30.000Z","updated":"2023-09-16T06:40:22.329Z","comments":true,"path":"2023/09/04/Web3/区块链轶事/","link":"","permalink":"http://example.com/2023/09/04/Web3/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%BD%B6%E4%BA%8B/","excerpt":"","text":"比特币白皮书 比特币白皮书-中文 以太坊白皮书 以太坊白皮书-中文 比特币“冤大头”Laszlo Hanyecz与披萨的故事 2010年5月22日，著名比特币“冤大头”Laszlo Hanyecz为表父爱，用1万个比特币给女儿买了两个披萨，披萨价值41美元。这是比特币第一次实现价值转移，也是比特币史上的第一次真实交易。这些比特币如果留到现在，价值约为4.5亿美元。 Mt.Gox交易所的故事2023 Web3 HK峰会 1月份：POW’ER 2023 香港 Web3 创新者峰会（1月9-10日） 内容链接：https://www.marsbit.cc/live/24313621 4月份：Foresight 2023 HK (4月10日) 内容链接：https://as.alltuu.com/album/1455240419/1350344075/ https://foresightnews.pro/event/event2023 4月份：HK Web3 festival 2023(香港web3嘉年华)（4月12-15日） 内容链接：https://group.hashkey.com/cn/newsroom/hong-kong-web3-festival-2023-event-summary","categories":[{"name":"技能-修行-进步-Web3","slug":"技能-修行-进步-Web3","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Web3/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"3天回顾web3学习3周(8/7-8/27)","slug":"Web3/3day-renew-web3-august","date":"2023-08-25T03:49:30.000Z","updated":"2023-08-29T02:48:34.694Z","comments":true,"path":"2023/08/25/Web3/3day-renew-web3-august/","link":"","permalink":"http://example.com/2023/08/25/Web3/3day-renew-web3-august/","excerpt":"","text":"Day 1为什么我会学习这门课程？-《moledao基建之周8周课程》 因为我目前身处自我转型，我想学习Web3相关知识，加上自己AI的相关工作经验，为自己的未来做准备。以我在AI工作的经验中，越是基础的就越有话语权，越是基础的就越能够在未来的发展中有更多的选择。所以我入门web3首选的是基础设施，但是基础设施是一个很大的范畴，所以我希望从这门课程入手，了解web3的基础设施是什么，以及如何搭建基础设施。 整个web3圈子的分类 矿圈：寻求基础算力的突破 币圈：资本的操作 链圈：寻求基础设施的突破 鄙视链：链圈（技术清高）-&gt; 矿圈（算力清高）-&gt; 币圈（资本清高），但是现实世界资本话语权最高，哈哈😄 web3存在的不可能三角关系 去中心化 高性能 高安全性 web3的系统架构 区块链基础 区块链有下列特征： 去中心化，分布式，数据库，账本 区块链的本质是一个分布式的记账本 分布式P2P协议 密码学：数字签名，哈希函数 共识算法：POW，POS，DPOS，PBFT，RAFT，POA，POE，POI，POB 分叉 &#x2F; 双花 区块链有下列用途： 信任 自治性 去中介化 智能合约 什么是智能合约 一段代码，部署到区块链上，可以实现自动化的执行，不可篡改，不可停止，不可拦截 代码部署到区块链上，就是智能合约 智能合约是一种特殊的账户，可以接收交易，可以发送交易，可以存储数据，可以执行代码 智能合约的代码是不可篡改的，一旦部署，就不可修改 以太坊 以太坊是第一个支持智能合约的区块链 以太坊的运作原理：以太坊虚拟机EVM，以太坊账户，以太坊交易，以太坊区块 Day 2 do nothing,be happy ! Day 3以太坊学习框架以太坊白皮书 以太坊是对比特币区块链的拓展，它支持在链上运行智能合约，智能合约是一段代码，可以自动执行，不可篡改，不可停止，不可拦截，它可以实现更多的功能。 以太坊内置的加密货币是以太币（ETH）。 以太坊运行在一个去中心化的虚拟机上，这个虚拟机叫做以太坊虚拟机（EVM），EVM是一个图灵完备的虚拟机，它可以运行任何代码。 以太坊的共识算法是POS，它的区块时间是15秒，区块大小是1M，每个区块的gas限制是8M，gas是以太坊的计价单位，每个操作都需要消耗一定的gas，gas的价格是由矿工决定的，矿工可以自由决定每个gas的价格，矿工会优先打包gas价格高的交易。 上海升级：以太坊的拓展方案，创建了一个“上海分叉”，允许用户转移他们的ETH和通过解绑获得的奖励。简而言之，就是要让以太坊更加灵活、易用和用户友好。 智能合约部署的过程： 1.编写智能合约代码sol 2.编译智能合约代码 byte code + abi 3.ether.js &#x2F; web3.js 编写包装和运行程序 4.运行在EVM的实例中，部署并广播到以太坊网络中 EVM的运行原理 EVM &#x3D; 运行交易、执行操作和更新区块链状态的虚拟机，所有操作的通货是gas fee。 EVM 使用基于堆栈的虚拟机架构，这意味着它将数据存储在堆栈中，并使用堆栈中的数据执行指令。 EVM 有一组 256 位寄存器，用于存储当前程序计数器、堆栈指针和内存指针等数据。 EVM 使用一种名为 EVM bytecode 的字节码语言，这是一种专为 EVM 设计的高度优化的低级语言。 An Ethereum Virtual Machine Opcodes Interactive Reference 总结来说，我们编写的智能合约代码最终会变成一串opcode，每个opcode指定EVM的一种操作，EVM会根据这些操作来执行智能合约代码。 学习solidity编程语言，ehther.js&#x2F; web3.js实践 just do it and give birth a new production.","categories":[{"name":"技能-修行-进步-Web3","slug":"技能-修行-进步-Web3","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Web3/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"http://example.com/tags/solidity/"}]},{"title":"solidity study by ChatGPT","slug":"Web3/solidity/solidity101","date":"2023-08-22T02:22:30.000Z","updated":"2024-03-01T04:19:31.948Z","comments":true,"path":"2023/08/22/Web3/solidity/solidity101/","link":"","permalink":"http://example.com/2023/08/22/Web3/solidity/solidity101/","excerpt":"","text":"chenyuqing: 请生成一个学习solidity的目录。GitHub Copilot: 好的，以下是一个学习Solidity的目录，供您参考： Solidity学习笔记基础知识 Solidity简介 Solidity开发环境搭建 Solidity数据类型 Solidity运算符 Solidity控制结构 Solidity函数 Solidity事件 Solidity修饰器 高级主题 Solidity面向对象编程 Solidity库 Solidity接口 Solidity继承 Solidity多态 Solidity异常处理 Solidity安全性 智能合约开发 智能合约开发流程 智能合约部署 智能合约调用 智能合约测试 智能合约优化 智能合约安全 DApp开发 DApp开发流程 DApp前端开发 DApp后端开发 DApp测试 DApp部署 DApp安全 Solidity生态系统 Solidity工具 Solidity框架 Solidity库 Solidity应用 我想学的 openzeppelin chainlink 希望这个目录能够帮助您更好地学习Solidity。如果您有任何问题或需要进一步的帮助，请随时告诉我。 What are smart contracts ? A smart contract is a computer program or a transaction protocol which is intended to automatically execute, control or document legally relevant events and actions according to the terms of a contract or an agreement.","categories":[{"name":"技能-修行-进步-Web3","slug":"技能-修行-进步-Web3","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Web3/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"http://example.com/tags/solidity/"}]},{"title":"EVM硬核底层原理","slug":"Web3/evm-core","date":"2023-08-16T10:54:30.000Z","updated":"2023-08-17T07:35:28.747Z","comments":true,"path":"2023/08/16/Web3/evm-core/","link":"","permalink":"http://example.com/2023/08/16/Web3/evm-core/","excerpt":"","text":"一问：智能合约是怎么部署到链上的？ 字节码 bytecode：智能合约通过编译器编译后生成的二进制代码，它是一种中间代码，可以被EVM虚拟机执行。 操作码&#x2F;指令码 opcode：操作码是一种特殊的字节码，它是EVM虚拟机的指令集，用于执行智能合约的逻辑。 GitHub Copilot的回答： GitHub Copilot: 您好！智能合约是通过将其编译为字节码(bytecode)，然后将字节码发送到区块链网络上的节点来部署的。一旦节点接收到字节码，它将创建一个合约地址，并将字节码存储在该地址下。这样，其他用户就可以通过调用该地址上的函数来与合约进行交互。 ChatGPT的回答： opcode的分类 GitHub Copilot: 您好！EVM虚拟机的操作码可以分为以下几类：GitHub Copilot: 以下是EVM操作码按类分类的列表： 栈操作（Stack Operations）17个 0x80 - 0x8f: DUP1-DUP16 0x90 - 0x9f: SWAP1-SWAP16 0x58: POP 0x59: MLOAD 0x5a: MSTORE 0x5b: MSTORE8 0x50: PUSH1 0x51: PUSH2 … 0x5f: PUSH32 PUSH1 - PUSH32共32个 流程控制（Flow Control）3个 0x56: JUMP 0x57: JUMPI 0x5b: JUMPDEST 环境信息（Environmental Information）15个 0x30: ADDRESS 0x31: BALANCE 0x32: ORIGIN 0x33: CALLER 0x34: CALLVALUE 0x35: CALLDATALOAD 0x36: CALLDATASIZE 0x37: CALLDATACOPY 0x38: CODESIZE 0x39: CODECOPY 0x3a: GASPRICE 0x3b: EXTCODESIZE 0x3c: EXTCODECOPY 0x3d: RETURNDATASIZE 0x3e: RETURNDATACOPY 存储和内存（Storage and Memory）4个 0x54: SLOAD 0x55: SSTORE 0x5a: MSTORE 0x5b: MSTORE8 数学运算（Mathematical Operations）11个 0x01: ADD 0x02: MUL 0x03: SUB 0x04: DIV 0x05: SDIV 0x06: MOD 0x07: SMOD 0x08: ADDMOD 0x09: MULMOD 0x0a: EXP 0x0b: SIGNEXTEND 比较和逻辑运算（Comparison and Bitwise Logic Operations）15个 0x10: LT 0x11: GT 0x12: SLT 0x13: SGT 0x14: EQ 0x15: ISZERO 0x16: AND 0x17: OR 0x18: XOR 0x19: NOT 0x1a: BYTE 0x1b: SHL 0x1c: SHR 0x1d: SAR 加载和存储（Loading and Storing）14个 0x32: ORIGIN 0x33: CALLER 0x34: CALLVALUE 0x35: CALLDATALOAD 0x36: CALLDATASIZE 0x37: CALLDATACOPY 0x38: CODESIZE 0x39: CODECOPY 0x3a: GASPRICE 0x3b: EXTCODESIZE 0x3c: EXTCODECOPY 0x3d: RETURNDATASIZE 0x3e: RETURNDATACOPY 合约调用（Contract Calls）10个 0xf0: CREATE 0xf1: CALL 0xf2: CALLCODE 0xf3: RETURN 0xf4: DELEGATECALL 0xf5: CREATE2 0xfa: STATICCALL 0xfd: REVERT 0xff: SELFDESTRUCT 杂项（Miscellaneous）11个 0x00: STOP 0x0f: BREAKPOINT 0x3f: BLOCKHASH 0x40: COINBASE 0x41: TIMESTAMP 0x42: NUMBER 0x43: DIFFICULTY 0x44: GASLIMIT 0x45: CHAINID 0x46: SELFBALANCE 0x47: BASEFEE 了解这些操作码的分类可以帮助开发者更好地理解EVM虚拟机的指令集，从而更好地编写和优化智能合约的代码。 二问：如何写智能合约才能更省gas费用？ GitHub Copilot: 在Solidity中，通常有以下几种省费用的操作码： 使用view和pure关键字：在Solidity中，如果一个函数不修改合约状态并且不访问合约存储，那么可以使用view或pure关键字来标记该函数。这样可以避免在执行函数时进行状态变更和存储访问，从而减少gas费用。 使用memory关键字：在Solidity中，如果一个函数需要使用临时内存来存储数据，那么可以使用memory关键字来标记该数据。这样可以避免在执行函数时将数据存储到合约存储中，从而减少gas费用。 使用bytes32类型：在Solidity中，如果一个变量需要存储一个固定长度的字节序列，那么可以使用bytes32类型来存储。这样可以避免使用动态数组或映射类型，从而减少gas费用。 避免重复计算和存储：在Solidity中，如果一个变量的值可以通过其他变量计算得出，那么可以避免重复计算和存储该变量的值。这样可以减少gas费用。 避免使用循环：在Solidity中，循环语句的执行会消耗大量的gas费用。因此，如果可以使用其他方式来实现相同的功能，那么应该避免使用循环语句。 这些操作码可以帮助开发者减少智能合约的gas费用，从而提高智能合约的性能和可用性。","categories":[{"name":"技能-修行-进步-Web3","slug":"技能-修行-进步-Web3","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Web3/"}],"tags":[{"name":"EVM","slug":"EVM","permalink":"http://example.com/tags/EVM/"}]},{"title":"solidity导语","slug":"Web3/solidity/00-导语-solidity","date":"2023-08-16T02:32:30.000Z","updated":"2024-03-01T02:20:38.167Z","comments":true,"path":"2023/08/16/Web3/solidity/00-导语-solidity/","link":"","permalink":"http://example.com/2023/08/16/Web3/solidity/00-%E5%AF%BC%E8%AF%AD-solidity/","excerpt":"","text":"Github库地址： solidity-by-example solidity是一门编译性语言，需要经过编译器编译成字节码，然后再部署到区块链上，所以需要安装编译器，推荐使用remix在线编译器，也可以使用truffle本地编译器，但是truffle需要安装nodejs，npm，ganache等环境，比较麻烦，所以推荐使用remix。 solidity是一门面向合约的语言，所以需要有合约的概念，合约是一种特殊的类，合约中可以定义状态变量，函数，事件，修饰器，结构体，枚举等。 Remix-IDE remix 面板介绍 Hello World123456// SPDX-License-Identifier: MITpragma solidity ^0.8.18;contract helloWorld&#123; string public _str = &quot;hello world&quot;;&#125; 代码解释 // SPDX-License-Identifier: MIT：开源协议 pragma solidity ^0.8.18;：版本声明 contract helloWorld：合约声明 string public _str = &quot;hello world&quot;;：状态变量声明 Solidity基础知识 solidity基础知识 Solidity高级主题 solidity高级主题 参考资料 以太坊白皮书 极力推荐入门教程，配合食用更佳！写智能合约，节省gas费用永远放在第一位。 solidity中文网 僵尸打怪-Solidity: Beginner to Intermediate Smart Contracts WTF-Solidity 101 入门 Solidity8.0全面精通-B站崔棉大师 理想区块链 Fred带你学solidity","categories":[{"name":"技能-修行-进步-Web3","slug":"技能-修行-进步-Web3","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Web3/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"http://example.com/tags/solidity/"}]},{"title":"solidity基础知识","slug":"Web3/solidity/01-solidity基础知识","date":"2023-08-16T02:32:30.000Z","updated":"2024-03-25T11:03:49.053Z","comments":true,"path":"2023/08/16/Web3/solidity/01-solidity基础知识/","link":"","permalink":"http://example.com/2023/08/16/Web3/solidity/01-solidity%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"基础知识目录 Solidity数据类型 Solidity运算符 Solidity控制结构 Solidity函数 Solidity事件 Solidity修饰器 类型和值 所有的数据类型都有默认值，如果没有赋值，就是默认值。也有一定的数值范围。 它们通常还包含增、删、改、查4个操作中的其中一个或者几个。(set&#x2F;get, push&#x2F;pop, delete) 数据类型也包含基础类型和复合类型两种。 基础类型：整数，浮点数，布尔值，地址，字节。 复合类型：数组，枚举，结构体，映射。 123456789101112131415// SPDX-License-Identifier: MITpragma solidity ^0.8.18;contract dataType&#123; uint public uint_min = type(uint).min; uint public uint_max = type(uint).max; uint public uint_def; int public int_min = type(int).min; int public int_max = type(int).max; int public int_def; address public addr; bool public bol;&#125; 点我查看图片：solidity数据类型大小范围 - 有符号整数，无符号整数 类型 默认值 最小值 最大值 int(默认: int256) 0 -2**255 2**255-1 int128 0 -2**127 2**127-1 int64 0 -2**63 2**63-1 int32 0 -2**31 2**31-1 int16 0 -2**15 2**15-1 int8 0 -2**7 2**7-1 uint(默认: uint256) 0 0 2**256-1 uint128 0 0 2**128-1 uint64 0 0 2**64-1 uint32 0 0 2**32-1 uint16 0 0 2**16-1 uint8 0 0 2**8-1 字节，布尔值 类型 默认值 address 0x0…(total 40 zeros) ｜bool false 数组 - array（增、删、改、查） Copilot生成： 在memory中不能定义动态数组，不能使用push()和pop()方法 动态数组只能存在于状态变量中,stableVariable 固定数组可以存在于memory中，也可以存在于状态变量中 固定数组的长度是固定的，不能改变；动态数组的长度是动态的，可以改变 固定数组的长度是在编译时确定的，动态数组的长度是在运行时确定的 固定数组的长度是在定义数组的时候确定的，动态数组的长度是在定义数组的时候确定的，也可以在运行时确定 枚举 - enum（改、查） 枚举：是对一个对象的所有可能取到的值的集合。 set的时候，传入的参数是数字0，1，2…，如果不在枚举定义的范围内，会报错。 delete会重置默认值，默认值是枚举定义中的第一个值0。 结构体 - struct （增、删、改、查） 结构体：是对一个对象的所有属性的集合。 push()方法 映射 - mapping （增、删、改、查） delete map[key]，不会删除value，而是把value重置为默认值了 函数返回值 - returns Copilot生成： 函数返回值可以有多个，也可以没有返回值 函数返回值可以是任何类型，包括自定义的类型 函数返回值可以是内部函数，也可以是外部函数 函数返回值可以是可见的，也可以是不可见的 函数返回值可以是常量，也可以是变量 函数返回值可以是单个值，也可以是数组，映射，结构体等复合类型 pure view 关键字 view &gt; pure ChatGPT生成： 在 Solidity 中，pure 和 view 关键字用于标识函数的状态修改行为，以便在编译时进行优化和验证。它们之间的主要区别在于函数对合约状态的访问和修改： pure 函数： pure 函数声明表示函数不访问合约的状态变量，也不修改状态。它是一个纯函数，仅通过输入参数来计算并返回结果。 pure 函数不会访问合约的存储区域，也不会调用其他合约或发送以太币。 使用 pure 关键字声明的函数对于调用者和其他合约的状态都是完全透明的，可以保证函数的执行结果不受外部环境的影响。 view 函数： view 函数声明表示函数只读取合约的状态变量，而不修改状态。它也是一个纯函数，因为它不会改变合约的状态。 view 函数可以访问合约的存储区域，但不能对其进行修改。它也不能调用其他修改状态的函数。 使用 view 关键字声明的函数可以在不消耗 gas 的情况下被调用，因为它们不会改变区块链的状态。 总的来说，pure 和 view 关键字都用于标识函数的纯度和对状态的访问和修改行为，但pure 函数不允许访问状态变量，而 view 函数允许读取状态变量但不允许修改。 异常报错 - error gas费用：require &gt; assert &gt; error asser()：断言，不能带说明信息，如果断言失败，会消耗所有的gas，所有的状态变量都会被重置，所以不要使用断言。一般不会用，通常在调试的时候使用。 修饰器 - modifier 类似于java中的注解，可以在函数前面加修饰器，修饰器可以用来检查函数的输入，比如检查函数的调用者是否是合约的拥有者，是否是合约的管理员，是否是合约的成员等等。 123456789101112131415161718192021222324252627// SPDX-License-Identifier: MITpragma solidity ^0.8.18;contract PauseFuncion&#123; bool public paused; uint public num; function setPause(bool _paused) external &#123; paused = _paused; &#125; modifier whenNotPaused()&#123; require(!paused, &quot;paused&quot;); _; // _;代表被调用的代码块如果符合条件会在这里继续运行 &#125; function inc() external whenNotPaused&#123; // require(!paused, &quot;paused&quot;); num += 1; &#125; function dec() external whenNotPaused&#123; // require(!paused, &quot;paused&quot;); num -= 1; &#125;&#125; payable关键字 ChatGPT生成： 在 Solidity 中，payable 是一个关键字，用于标记函数或变量可以接收以太币。它通常用于两个地方： 函数修饰符： 使用 payable 修饰符标记的函数可以接收以太币。这些函数可以被其他账户发送以太币调用，并且可以执行向其他账户发送以太币的操作。 合约构造函数： 在合约构造函数中，如果你想要合约在部署时接收以太币，你可以将构造函数标记为 payable。 以下是使用 payable 的两个示例： 函数修饰符：12345678pragma solidity ^0.8.0;contract MyContract &#123; // 接收以太币的函数，标记为 payable function receiveEther() public payable &#123; // 函数逻辑 &#125;&#125; 在这个示例中，receiveEther 函数被标记为 payable，表示它可以接收以太币。调用这个函数时，可以通过 msg.value 获取发送的以太币数量。 构造函数：12345678pragma solidity ^0.8.0;contract MyContract &#123; // 合约构造函数，标记为 payable constructor() payable &#123; // 构造函数逻辑 &#125;&#125; 在这个示例中，合约的构造函数被标记为 payable，这意味着在部署合约时可以发送以太币。在构造函数中，可以通过 msg.value 获取发送的以太币数量。 payable 中transfer(), send(), call()的区别 ChatGPT生成： 在 Solidity 中，payable 关键字用于标记合约函数，以表示该函数可以接收以太币。当一个合约需要处理以太币时，通常会使用 transfer、send 或 call 函数之一来执行支付操作。这些函数之间有一些区别，下面是它们的简要比较： transfer： transfer 是 Solidity 中最简单的发送以太币的方法。 它是 address 类型的成员函数，只能发送固定的 2300 gas，并且在失败时会抛出异常（即抛出异常后所有状态改变都会被回滚）。 它被认为是比较安全的发送以太币的方式，因为它不允许发生回调（也就是说，接收方不能执行代码以影响交易的结果）。 send： send 函数与 transfer 函数相似，但它返回一个布尔值来指示发送是否成功，而不是抛出异常。 send 函数会发送所有可用的 gas（最多 2300 gas），但是在发送失败时不会抛出异常，而是返回 false。 这个函数通常用于与外部地址进行简单的支付操作，但不建议在需要确保交易原子性的情况下使用。 call： call 函数是最通用的发送以太币的方法，它允许发送任意数量的 gas，并且返回一个布尔值来指示调用是否成功。 call 函数可以传递额外的数据和设置 gas 限制，也可以捕获执行过程中的异常。 这个函数通常用于与合约进行交互，或者需要更复杂逻辑的支付操作。 总的来说，transfer 是最简单且最安全的发送以太币的方法，适用于大多数情况。send 函数在需要检查支付是否成功时比较有用，但在复杂场景下不够灵活。call 函数是最通用的方法，可以满足各种需求，但需要更小心地处理异常情况和 gas 的使用。 public internal external private关键字修饰变量：internal public private 权限开放程度：public &gt; internal &gt; private public：公开的，自动生成getter()函数，可以在合约内部外部访问。 private: 私有的，只能在当前合约中访问，不会生成getter()函数，也不能被子合约继承。 internal：只能在当前合约或子合约中访问 适用情况 ChatGPT生成： internal 关键字通常用于需要在当前合约及其派生合约中共享和访问的状态变量。它提供了一种在合约内部实现继承和代码重用的方式，并且可以限制对变量的访问权限，以提高合约的安全性和封装性。 以下是一些常见的情况下使用 internal 修饰变量的示例： 共享状态数据： 如果你希望在当前合约及其派生合约中共享和访问某个状态变量的值，但不希望它被合约外部的调用者直接访问，你可以将该状态变量声明为 internal。 内部状态追踪： 在复杂的合约中，可能会有一些状态需要在多个函数之间共享和更新。使用 internal 修饰的状态变量可以确保这些状态只能在合约内部被访问和修改，从而降低了出错的可能性。 继承和重用： 在使用继承的合约结构中，internal 修饰的状态变量可以在父合约和子合约之间共享，从而实现代码的重用和扩展。子合约可以直接访问父合约中的 internal 变量，而不需要重新定义相同的变量。 总的来说，使用 internal 修饰变量可以在合约内部提供数据共享和封装的能力，同时限制对变量的访问权限，使得合约更加安全和可靠。 修饰函数: internal external public private 权限开放程度：public &gt; internal &gt; external &gt; private public：公开的，可以在合约内部外部访问。 private: 私有的，只能在当前合约中访问，不能被子合约继承。 internal：只能在当前合约或子合约中访问. external：外部函数，只能在外部调用，不能在合约内部调用。 ChatGPT生成： 在 Solidity 中，internal 和 external 是用于修饰函数的访问权限的关键字，它们在修饰函数时有以下区别： Internal（内部）： 使用 internal 关键字修饰的函数只能在当前合约及其派生合约内部调用，无法被合约外部的调用者访问。这种访问权限对于实现合约内部逻辑提供了保护和封装。 示例：123456contract MyContract &#123; // 内部函数 function internalFunction() internal &#123; // 函数逻辑 &#125;&#125; External（外部）： 使用 external 关键字修饰的函数只能通过外部调用方式来访问，不能在合约内部被直接调用。这种访问权限通常用于合约的接口函数，供合约外部的调用者调用。 示例：123456contract MyContract &#123; // 外部函数 function externalFunction() external &#123; // 函数逻辑 &#125;&#125; 总的来说，internal 修饰的函数适用于合约内部调用和继承，而 external 修饰的函数适用于合约外部调用。这两种修饰符的选择取决于你希望函数被调用的方式以及对函数的访问权限的要求。 msg 关键字 ChatGPT生成： 在 Solidity 中，msg 是一个全局预定义变量，用于提供有关当前交易或消息的信息。它是一个包含以下属性的特殊对象： msg.sender：返回当前交易或消息的发送者（即合约调用者的地址）。 msg.value：返回当前交易发送的以太币数量（以 wei 为单位）。 msg.data：返回当前消息的数据。 msg.gas：返回当前交易还剩余的 gas 数量。 这些属性可以在合约的函数中使用，以便根据当前交易或消息的上下文进行逻辑判断或处理。 以下是一个简单的示例，演示了如何在 Solidity 中使用 msg： 12345678910111213141516171819202122232425pragma solidity ^0.8.0;contract MyContract &#123; address public owner; uint256 public valueReceived; // 构造函数，在部署合约时设置合约的拥有者 constructor() &#123; owner = msg.sender; &#125; // 接收以太币的函数 receive() external payable &#123; // 更新接收到的以太币数量 valueReceived = msg.value; &#125; // 提取合约中的以太币的函数 function withdraw() external &#123; require(msg.sender == owner, &quot;Only the owner can withdraw&quot;); // 向合约拥有者发送合约中的所有以太币 payable(owner).transfer(address(this).balance); &#125;&#125; 在这个示例中，我们使用了 msg.sender 和 msg.value 属性： 在构造函数中，owner 变量被设置为部署合约的账户地址，即 msg.sender。 在 receive 函数中，接收到的以太币数量被记录在 valueReceived 变量中，并且该函数被标记为 external 和 payable，表示它可以接收以太币。 在 withdraw 函数中，我们检查调用者是否是合约的拥有者（即 msg.sender == owner），然后将合约中的所有以太币发送给拥有者地址。 address(this) ChatGPT生成： 在 Solidity 中，address(this) 是一个特殊的表达式，用于获取当前合约的地址。它通常用于以下场景： 合约内部调用： 当合约需要获取自身的地址时，可以使用 address(this) 表达式来获取。例如，合约可以在部署时记录自己的地址，或者在与其他合约进行交互时将自己的地址传递给它们。 支付操作： 当合约需要将自己的地址作为收款地址进行支付操作时，可以使用 address(this) 表达式来获取。例如，在向其他地址发送以太币或者接收以太币时，合约可以使用 address(this) 表达式作为收款地址。 以下是一些示例，演示了 address(this) 的用法： 12345678910111213141516pragma solidity ^0.8.0;contract MyContract &#123; address public contractAddress; // 构造函数，在部署时记录合约地址 constructor() &#123; contractAddress = address(this); &#125; // 向指定地址发送以太币 function sendEther(address payable receiver) external payable &#123; // 发送以太币给指定地址 receiver.transfer(msg.value); &#125;&#125; 在这个示例中，合约在构造函数中使用 address(this) 表达式来获取自身的地址，并将其记录在 contractAddress 变量中。在 sendEther 函数中，合约可以使用 address(this) 表达式作为收款地址来接收以太币。","categories":[{"name":"技能-修行-进步-Web3","slug":"技能-修行-进步-Web3","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Web3/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"http://example.com/tags/solidity/"}]},{"title":"近代史大事件","slug":"认知-修行-平衡/中国近代史大事件","date":"2023-08-07T07:47:30.000Z","updated":"2023-08-07T10:07:03.041Z","comments":true,"path":"2023/08/07/认知-修行-平衡/中国近代史大事件/","link":"","permalink":"http://example.com/2023/08/07/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%E5%A4%A7%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"Part 1 从鸦片战争开始Part 2 辛亥革命来了 1911年10月10号，武昌起义来开辛亥革命序幕，清皇朝濒于灭亡 1912年1月1号晚10点，中华民国宣告成立，孙文宣誓就任临时大总统 1912年2月12日，溥仪宣布退位，孙文领导的辛亥革命推翻了清王朝 1912年2月15日，孙文宣布辞去临时大总统职务 1912年3月10日，袁世凯出任临时大总统 1913年3月20号晚10点45分，宋教仁在上海火车站被刺杀 1913年12月23日，袁世凯在天坛举行仪式，妄想称帝 1916年6月6日，袁世凯在举国声讨中死去 1917年6月14日，张勋在保皇党策动下入京 1917年7月12日，张勋复辟12天即告失败，孙文在广州发起护发运动 Part 3 新中国成立了","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"从历史中进行学习","slug":"从历史中进行学习","permalink":"http://example.com/tags/%E4%BB%8E%E5%8E%86%E5%8F%B2%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%AD%A6%E4%B9%A0/"}]},{"title":"成瘾始于痛苦，戒瘾终于平衡！","slug":"books/2024/first-half/addition","date":"2023-08-07T04:39:30.000Z","updated":"2023-08-09T02:55:18.170Z","comments":true,"path":"2023/08/07/books/2024/first-half/addition/","link":"","permalink":"http://example.com/2023/08/07/books/2024/first-half/addition/","excerpt":"","text":"read a book with me, 听第一遍总结： 目录 对快乐成瘾源自于痛苦的驱使 成瘾以及难以戒瘾的底层原理 利用多巴胺机制恢复身体平衡Part 1 人的痛苦是一种常态。痛苦和快乐是天平两边的对手，我们终将要找到一种平衡。 很多成瘾者在重复成瘾行为的时候，已经感受不到快乐，但如果不重复成瘾行为，他们会感觉非常痛苦。 在完成成瘾行为后得到短暂的多巴胺快乐，但快乐过后痛苦还在原地等着你，而且前后落差会让你觉得更痛苦。这样的痛苦反过来又促使你再次成瘾，这就是成瘾的恶性循环。 身体本身就是一个系统，根据系统思考的原理，我们可以通过调节回路来恢复身体的平衡。但同时如果我们放手不管，身体就会记着某种快乐的源泉，并且不断的去重复这种行为。 多巴胺有一种奖赏预测误差机制，就是每一次的快乐需要比上一次的快乐要的更多才能满足。这也是人所说的，欲望是越来越难以满足的。Part 2 成瘾的底层原理其实就是多巴胺作祟。因为人的痛苦是一种常态，而痛苦又是驱使你去寻找快乐的动力。 人的快乐是由脑中的多巴胺分泌决定的，人们会追求多巴胺分泌的行为； 多巴胺的分泌是有限的，一旦分泌完了，由于落差你就会感觉到更痛苦； 多巴胺有一种奖赏预测误差机制，就是每一次的快乐需要比上一次的快乐要的更多才能满足，所以人就会不断的重复某种成瘾的行为。 Part 3 应对方法 以痛制痛 物理阻断 激进诚实 听第二遍总结： 为什么你会没有动力？因为你没有目标，也没有奖励回路。有了目标，把目标切割成一小段一小段，然后通过奖励来推动你一步一步完成目标。奖励就是一种动力。 重置大脑奖赏回路的时间最短需要一个月。也就是系统思考中的调节回路，通过调节回路来恢复身体的平衡。 痛苦是我们为快乐付出的代价，而快乐是我们从痛苦中获得的回报。 人都是求生的，从我们受精开始的那一刻，我们就具备了竞争力和求生的本能。 时间是最能代表民主，自由，平等的东西。有些东西是随着时间增值，有些东西是随着时间而贬值的。 坐而论道容易，要找到出路很难，也许要一生一世。 所有的系统都需要一个激励机制，来驱动系统的运转。","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"成瘾戒瘾","slug":"成瘾戒瘾","permalink":"http://example.com/tags/%E6%88%90%E7%98%BE%E6%88%92%E7%98%BE/"}]},{"title":"web3基础设施八周课程","slug":"Web3/web3基础设施八周课程","date":"2023-08-04T02:52:30.000Z","updated":"2023-08-04T04:17:00.939Z","comments":true,"path":"2023/08/04/Web3/web3基础设施八周课程/","link":"","permalink":"http://example.com/2023/08/04/Web3/web3%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%85%AB%E5%91%A8%E8%AF%BE%E7%A8%8B/","excerpt":"","text":"课程总览 week1a-基础知识 关键字 中心化&#x2F;去中心化 区块链 共识机制 分叉&#x2F;之链 web3的商业：合作共赢，而是大小通吃。Inter-Operation。常言道：赢者垄断（Apple），输者竞争（卷起来） web3的工作方式：多数是远程，以结果为导向，员工需要更多的自主性，沟通很重要 web3的运营：online，多人参与，DAO，抱着“信仰”而前进的。 week1b-加密 全同态加密，FHE，Fully Homomorphic Encryption zkPass，zk：zero knowledge，零知识证明 week1c-chainlink预言机 关键字 oracle，区块链上的智能合约","categories":[{"name":"技能-修行-进步-Web3","slug":"技能-修行-进步-Web3","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Web3/"}],"tags":[{"name":"web3基础设施","slug":"web3基础设施","permalink":"http://example.com/tags/web3%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"}]},{"title":"停一停 心呼吸 每日銘言 202308","slug":"认知-修行-平衡/心青年-202308","date":"2023-08-03T03:01:33.000Z","updated":"2024-02-23T01:01:59.710Z","comments":true,"path":"2023/08/03/认知-修行-平衡/心青年-202308/","link":"","permalink":"http://example.com/2023/08/03/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/%E5%BF%83%E9%9D%92%E5%B9%B4-202308/","excerpt":"","text":"日期 銘言 8月30号 8月29号 8月25号 8月23号 8月21号 8月19号 8月18号 8月17号 8月16号 8月15号 8月14号 8月14号 8月12号 8月11号 8月10号 8月9号 8月8号 8月5号 8月4号 8月3号","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"佛学","slug":"佛学","permalink":"http://example.com/tags/%E4%BD%9B%E5%AD%A6/"}]},{"title":"We become what we think about.","slug":"认知-修行-平衡/we_become_what_we_think_about","date":"2023-07-27T05:48:30.000Z","updated":"2023-08-06T02:33:04.325Z","comments":true,"path":"2023/07/27/认知-修行-平衡/we_become_what_we_think_about/","link":"","permalink":"http://example.com/2023/07/27/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/we_become_what_we_think_about/","excerpt":"","text":"关键总结 一段对话引入：和博士医生的对话，我问：请问博士，今天的人是怎么了？博士沉默了一会儿，说道：今天的人就是不思考。 例子：100个人从25岁到65岁，100个在25岁时都相信自己会成为一个成功的人。当他们65岁时，有1个人会变成富翁，4个人在经济上独立，5个人还在工作，54个破产了。在这个100个人当中只有5个人成功了，这是为什么呢？为什么大部分人都是失败的呢？为什么人与人之间的差距会这个巨大的？ 成功的定义：成功就是你清楚自己的目标并且朝着目标循序渐进的前进，直到最好。问题是大部分人都是没有目标的，他们都是从众的活着，因为别人都是早上起床上班，所以我也是早上起床上班。 有志者事竟成，we become what we think about。和佛学中所说的：信，愿，行。信就是相信自己能够成功，愿就是有一个目标，行就是朝着目标前进。 一位伟大的医生说过六个步骤助你成功：1. 给自己确定一个明确的目标；2. 对成功保持乐观；3. 别再想你为什么不能成功，而是思考你怎么才能成功；4. 回想过去你的态度，甚至是童年，寻找你当时不成功的原因；5. 改变对自己的印象，写出你想成为的那个人的印象；6. 扮演那个你想成为的人，直到你真的成为那个人。 Start today, you have nothing to loose, but you have a life to win. 想要和得到之间还有一个做到。因和果之间还有一个愿。 提升觉察能力，人生就是不断的做选择，觉察能力高的可以帮助做出更明智的选择。 对抗你的惯性。你越习惯什么，但是你又觉得你是必须去打破的，那你就学习对抗这个惯性，尽量多的去做你认为正确的事。 你的生活就是你的思想的产物。你的思想就是你的生活的产物。 要相信相信的力量。你相信什么，你就会得到什么。所以你要永远保持乐观。 经济建设决定上层建筑，经济独立很重要，很重要，若果你要实现自我，首先你必须要经济独立。 核心观点 做一个有目标的人，知道你需要什么很重要。 建立自己的生命之树。 功利主义讲究的是效率，以结果为导向的“法家”思想。 人控制不了自己的欲望，控制不了自己的人，有可能走向“自废”的人生。 不是所有人都拥有思想的，普通没有思想的人也可以活的的不错，但是有思想就是一条分界线。 野蛮征服文明，劣币驱逐良币，这是自然界的规律，也是人类社会的规律。 兴趣就是你会废寝忘食去做的事情。迷茫是人生的常态，你可以去选择一些你感兴趣和有挑战性的事情坚持去做，你会找到自己的答案的。 人生就是不断的做选择，觉察能力高的可以帮助做出更明智的选择。 拥有了觉察能力，你需要去学会控制自己，自律，take action。","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"心想事成","slug":"心想事成","permalink":"http://example.com/tags/%E5%BF%83%E6%83%B3%E4%BA%8B%E6%88%90/"}]},{"title":"Steve Jobs' 2005 Stanford Commencement Address","slug":"认知-修行-平衡/SJobs_speech2005","date":"2023-07-20T08:28:38.000Z","updated":"2023-07-20T08:30:49.833Z","comments":true,"path":"2023/07/20/认知-修行-平衡/SJobs_speech2005/","link":"","permalink":"http://example.com/2023/07/20/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/SJobs_speech2005/","excerpt":"","text":"【BibiGPT】AI 课代表一键总结：Steve Jobs’ 2005 Stanford Commencement Address Summary这篇演讲是斯蒂夫·乔布斯在2005年斯坦福大学毕业典礼上的演讲，他分享了生活中的三个故事，讲述了连接点、爱与失去以及死亡对他人生的影响。 Highlights 🧩 斯蒂夫·乔布斯分享了自己在大学期间的经历，强调了在人生中寻找兴趣和跟随内心的重要性。 放弃大学对乔布斯来说是一个重要的决定，让他有机会追随自己的兴趣并最终成功创办苹果公司。 他强调了人们要相信生活中的各个点会在未来连接起来，要相信自己的直觉和命运。 💔 乔布斯分享了自己被苹果公司开除的经历，但这一打击成为他生命中的转折点。 这次挫折让他重新开始，创办了NeXT和Pixar，成功走上创业之路，并找到了真正热爱的事业和妻子。 他认为被开除是最好的事情，因为它使他从成功的重压中解放出来，重新成为一个创业者，实现了人生的突破。 ⏳ 乔布斯谈到了死亡的重要性，他说面对死亡能够帮助人们做出人生中重要的选择。 死亡是生命中不可避免的事实，但乔布斯认为它是生活中最好的发明，它清除旧有，为新事物让路。 死亡的意识能够使人们摆脱外界的影响和束缚，追随内心和直觉，去做自己热爱的事情。 🌟 乔布斯引用了《全地球目录》的后封面，给新毕业生们留下了鼓舞的寄语。 “Stay hungry, stay foolish”（保持渴望，保持愚蠢）成为乔布斯的人生座右铭，鼓励人们在生活中保持好奇心和冒险精神。 乔布斯希望毕业生","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"Steven Jobs","slug":"Steven-Jobs","permalink":"http://example.com/tags/Steven-Jobs/"},{"name":"GPT视频总结","slug":"GPT视频总结","permalink":"http://example.com/tags/GPT%E8%A7%86%E9%A2%91%E6%80%BB%E7%BB%93/"}]},{"title":"Ray Dalio： Principles, the Economic Machine, AI & the Arc of Life","slug":"认知-修行-平衡/raydalio-interview","date":"2023-07-20T08:20:38.000Z","updated":"2023-07-20T08:25:12.715Z","comments":true,"path":"2023/07/20/认知-修行-平衡/raydalio-interview/","link":"","permalink":"http://example.com/2023/07/20/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/raydalio-interview/","excerpt":"","text":"Summary Ray Dalio, founder of Bridgewater Associates, discusses the importance of truth, experimentation, and adaptation in achieving goals and success. Highlights 🚀 Truth and Experimentation: Truth is essential for success, and one must experiment to discover it, especially when pursuing new and groundbreaking ideas. 🎯 The 5-Step Process: Dalio describes a five-step process for success: setting goals, identifying problems, diagnosing root causes, designing solutions, and following through with experimentation. 🌟 Shapers: Dalio highlights individuals like Elon Musk and Marc Benioff as “shapers” who visualize unique ideas and execute them, changing the world. 💼 Balancing Vision and Detail: Shapers balance their audacious visions with a practical understanding of the details required to achieve their goals. 👥 Concern for Others: Successful leaders prioritize the mission over personal concerns and hold high standards for their team members. 🤝 Embracing Different Perspectives: Great leaders appreciate diverse perspectives and learn from others to create a successful and harmonious team. 🤔 Confidence and Open-mindedness: Successful leaders possess both supreme confidence in their vision and the openness to consider different viewpoints.(Note: The provided transcript has been edited for brevity and clarity to fit the bullet points template.)","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"Ray Dalio","slug":"Ray-Dalio","permalink":"http://example.com/tags/Ray-Dalio/"},{"name":"活出真我","slug":"活出真我","permalink":"http://example.com/tags/%E6%B4%BB%E5%87%BA%E7%9C%9F%E6%88%91/"}]},{"title":"markdown书写规则","slug":"小而美-工具/markdown-usage","date":"2023-07-20T04:00:30.000Z","updated":"2023-08-16T04:52:52.488Z","comments":true,"path":"2023/07/20/小而美-工具/markdown-usage/","link":"","permalink":"http://example.com/2023/07/20/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/markdown-usage/","excerpt":"","text":"Markdown是一个清亮的书写文章的小工具。 tabel表格 日期 銘言 8月12号 不计回报的付出，最终得益的是自己！","categories":[{"name":"小而美-工具","slug":"小而美-工具","permalink":"http://example.com/categories/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"markdown用法","slug":"markdown用法","permalink":"http://example.com/tags/markdown%E7%94%A8%E6%B3%95/"}]},{"title":"何为系统思考？","slug":"认知-修行-平衡/system_thinking","date":"2023-07-20T03:53:30.000Z","updated":"2023-07-20T03:54:03.233Z","comments":true,"path":"2023/07/20/认知-修行-平衡/system_thinking/","link":"","permalink":"http://example.com/2023/07/20/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/system_thinking/","excerpt":"","text":"read a book with me, 听第一遍总结：增强回路：因果关系，正反馈调节回路： 我们终将找到一个平衡点 听第二遍总结： 为什么我们需要系统思考？ 系统思考可以改变我们的单向思维模式，从全局看待问题； 透过现象看本质； 看清事物之间存在的延迟现象。 如何掌握系统思考的能力？ 有且仅有2种回路：增强回路和调节回路； 回路是一种闭合的因果循环； 增强回路：事物之间的关系是正反馈的关系； 调节回路：调节因素，是一种解决问题的机制； 延迟：不能忽略时间延迟的因素，效果存在延迟性。 工具：系统循环图 拿出纸和笔 列出当前的问题 找原因 找后果 找回路 注意：使用名词，不实用动词，箭头是单向的","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"系统思考","slug":"系统思考","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83/"}]},{"title":"任正非：让工程师成为技术商人","slug":"认知-修行-平衡/be-a-bussinessman","date":"2023-07-20T03:01:26.000Z","updated":"2023-07-20T03:43:48.937Z","comments":true,"path":"2023/07/20/认知-修行-平衡/be-a-bussinessman/","link":"","permalink":"http://example.com/2023/07/20/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/be-a-bussinessman/","excerpt":"","text":"第一节：概述 进入21世纪以来，市场导向已经成为绝大多数企业尤其是高科技企业的共识。但是，正如赵本山在央视春晚的小品里的表演一样：“感谢CCTV，感谢MTV，感谢TV……”然而他并不知道他嘴里说的这一大堆TV到底是什么？就像很多企业并不知道真正的市场导向是什么一样，因此，市场导向无法真正落实，空喊口号就成了大多数中国高科技企业的通病。 例如，由于缺乏真正了解市场的职能和手段，无法找到充分了解市场状况和客户需求的集成的市场营销方法，很多企业只能照顾到眼前的利益，企业经营是远远落后于市场的，客户不断流失，满意度日益降低，甚至犯了方向性的错误。 又如，随着企业的不断成长和业务的多元化，不可避免的使得产品组合和业务模型变得愈加复杂。这导致很多企业在产品开发方面反应开始变得迟缓，日益与市场脱节，运作效果和效率明显降低。 再如，由于客户需要的是一个系统的解决方案，高科技企业不可避免的从产品&#x2F;技术向服务转型，很多中国的高科技企业没有及时认识到这一点，不得不面临被整合甚至被淘汰的命运。 在种种困难和阵痛面前，企业界进行了不停的探索，其中，中国高科技企业中当之无愧的标杆——华为——率先多年寻求到了业界最佳的业务管理模型，就是建立端到端的流程，从了解市场到产品开发，再到生命周期管理，流程中的每一步都是由客户的输入牵引的，每一步都直接面对客户。这种业务管理模型的核心就在于它帮助企业找到了一个最佳平衡点，即既要保持技术的领先，更要确保技术在商业运作上的成功，我们称之为技术商业化。在这个大变革、大转型中，华为总裁任正非提出了鲜明的口号： 让工程师成为技术商人！ 在全球领域，如IBM、微软等世界级领袖企业,也早就将技术商业化作为公司的战略付诸实施： IBM——从思考到服务，让技术走向市场，让技术满足市场与客户需求； 微软——人才战略：只找既懂技术又懂经营的精英人士。 那么，这些领袖企业为什么不约而同的选择了这一路径，其内涵究竟是什么，它们又是如何做到这一点的？ 第二节：技术领先企业，为何难逃衰退厄运？ 进入21世纪的前后一段时间，企业界发生了一次不可抗拒的洪流，就是那些曾经依靠技术取得领先的企业，试图继续带着技术领先的优势进入21世纪时，几乎不约而同地步入了衰落甚至消亡。 20世纪90年代的贝尔实验室和蓝色巨人IBM可以说是其中的典型。贝尔实验室代表了一个技术导向的顶尖研发机构的没落，IBM则代表了一个技术导向型的领袖企业的没落——它们的经历有着惊人的相似：依靠技术取得空前的成功，曾经非常富有，把技术的重要性摆在市场前面，以及缺乏把技术市场化的动力和能力，最终不约而同的步入没落。 一、贝尔实验室：从翘楚到房地产商的猎物 贝尔实验室的名气，无人不晓，在过去的近一个世纪里，贝尔实验室有11位科学家在诺贝尔奖中榜上有名，其中有位科学家验证了“宇宙大爆炸”理论。这里诞生过镭射，光纤、卫星通讯、调制解调器、太阳能电池、电子麦克风和数字式计算机等。虽然贝尔实验室获得了无数殊荣，它自身却几乎没有将相关科研成果应用到市场上并获利。AT&amp;T几乎垄断了电话通讯业务，因此钱多得数不过来。一点都不缺钱的贝尔实验室经理们从来都没有将新技术商业化的动力，进而也失去了这种能力。因此，长期以来，贝尔实验室的科研活动没有走出实验室，相关的科研成果不能及时转化为市场需要的东西。但是，美国电话电报公司1984年进行了拆分，后来朗讯科技于1996年从美国电话电报中剥离出去，从此贝尔实验室进入了动荡时期。在科技电讯业泡沫破灭及公司产品需求下降后，朗讯科技削减了对贝尔实验室的资助。人们理所当然的认为贝尔实验室将一如既往地充当商业技术研究的翘楚，然而随着母公司在市场竞争的一系列不利，实验室慢慢的丧失了影响力。研究项目逐项被砍掉，科学家相继离去，这个全球闻名的实验室变得人去楼空，“如今，贝尔实验室的走廊到处都黑乎乎。在走廊里随便看看，有一大堆的空屋子”，以至于成为房地产商收购的猎物。 二、IBM：带着思考走向悬崖 在IBM成立早期，老华尔森为IBM定下了一个口号“思考”，以此作为IBM的精神。这个口号引导了IBM人对科学技术的不懈探索，激起了一代又一代IBM人的技术热情。带着这个口号，IBM从20世纪50年代进入计算机行业，并于80年代登上辉煌的顶峰，蓝色巨人一路高歌，以势如潮水的趋势不断扩张壮大，终于垄断了大型计算机领域。“IBM永远是第一”，IBM人对此确信不疑。 IBM在技术领先的路上一路狂跑，以至于忘记了市场环境的变化。它一味地沉迷于大型计算机市场所获得的成功，对数据设备公司、苹果公司进入个人电脑市场的个人计算机视而不见，并且将中央处理芯片CPU交给了英特尔公司，将DOS操作系统交给了微软，为自己培养了未来最为强大的敌人。 IBM将主要精力集中于对技术的思考的另一个后果是，IBM的组织机构逐步地、远远地脱离了市场，臃肿、反应迟缓、毫无创新精神。 IBM终于错失多次良机，迎来了接二连三的失败，到1992年已经是一发而不可收拾，净损失49．7亿美元，埃克斯引咎辞职，大批员工被裁减。 IBM总部的杰克-贝尔如此描述当时的情形：“我们就要从悬崖上坠落，对此我们却一无所知。”的确如此，即使在IBM跌落到最低谷的时候， IBM人依然是一帮对技术充满了幻想和崇拜的疯子，对于早已到来的外部危机毫无感觉，在一次战略会议上，刚刚入主IBM的郭士纳发现，那些高级经理们在会议上使用的技术行话、缩略语以及晦涩的术语，足以让任何人晕倒，以至于郭士纳置身其中的时候，发现身为总裁的自己纯属多余，“我宁可变成墙上的一只苍蝇”。 郭士纳重振IBM的最重要举措，就是改变IBM的这种技术至上的文化，他提出了一个新的口号——“服务”。从思考走向服务，代表着IBM从技术走向市场，对技术商业化的坚定决心。 贝尔实验室和IBM这两个不同领域的翘楚，以同样的方式取得成功，也以同样的方式衰落下去，它们身上浓缩了最近几十年来单纯依赖旧的商业模式（仅仅把成功建立在技术或产品的基础上）取得成功并不可避免的进入衰败的一代企业的经历。列在它们身后的企业名单还有很长，包括：通用汽车、加拿大北电网络、中国巨人电脑、大唐电讯……. IBM比贝尔实验室幸运的是，它提前了十年采取行动，而韩国人金锺勋(Jeong Kim)接管贝尔实验室，成立“技术商业化”小组，提出让实验室振兴的计划时，已是2005年。 第三节 技术商业化模式的兴起 此消则彼涨。曾经靠技术领先获得优势的企业逐步淡出商业舞台，取而代之的是那些在“技术商业化”方面有着卓越能力的企业。 一、微软的崛起 这期间，微软作为其中的代表崛起了。与其说，微软在上世纪90年代的崛起是一个商业神话，不如说，这是新商业模式适应新的市场环境的必然。微软崛起的秘诀：聘用一大批既懂技术又善于经营的高素质人才 说比尔-盖茨是一个电脑技术天才是不准确的，确切的说，他是一个深谙如何利用经营技术的天才。微软在IBM没落的同时崛起，似乎一开始就吸收了IBM的教训，即聘用一大批既懂技术又善于经营的精明的高素质人才来经营公司。微软的管理人员和工程师，似乎和比尔-盖茨是一个模板刻出来的：这些人都深刻理解软件技术以及如何将这种技术转化为市场需要的东西。 如果总裁、管理人员及工程师们真正理解他们的技术和市场，那么，公司就能始终走在别人前面，因此，微软总是能在市场激烈竞争中操作自如，叱咤风云。微软公司为此专门组建了职能交叉的专家小组，以便把这种技术商业化的能力以组织的形式进行强化。 同时，微软不断的向未来进军，不断创新，并且找到了一种令技术的市场价值最大化的办法，即把大规模市场作为目标，开发出了理论上让每个家庭、每个个人均可使用的产品。 从最近二十年的全球经济进程来看，微软崛起的另一层意义在于，它引领了一批新兴企业，正式宣布了一种新的商业模式的诞生（尽管该模式非微软首创），无论是西方，还是东方，我们都可以看到，近20年，那些活跃在市场上，具有旺盛生命力的领先企业身上，都印刻着这种商业模式。 特别需要提起的是，曾一度没落的IBM，一旦真正面对自己的问题，就立刻发起了强大的变革，在技术商业化道路上，演绎了新的神话，重新站起来的蓝色巨人不但夺回了失去的市场，走到了行业的最前端，并且，在商业运作模式上更为成功，还帮助一大批企业构建了世界级水平的组织体系，其中就包括中国的华为公司。后者在短短20年时间里实现了从零到250亿美元的井喷式增长，毫无争议的跨入了世界500强之列，其速度之快，效率之高，堪称奇迹。 二、构建技术商业化的组织体系 这些新的世界领袖级企业的成功，似乎暗示了一条很重要的商业规律，市场和技术应该是同一个东西，反过来说，如果你不能把它们有机的结合起来，就会在竞争中收获失败。 过去几十年来，我国以市场换技术已经被证明是失败的，其失败就在于，我们误以为市场和技术是两个完全不同的东西，摸石头过河20载后才发现，市场换不来技术，技术也换不来市场。被市场充分接受的技术才是有价值的技术，富有技术含量的市场才是有生命力的市场。 当然，在如此巨大的代价下，也不是完全没有斩获，华为公司就在摸爬滚打中，最终有效地把二者融合起来，成为中国目前唯一一家在市场领域和研发领域同时具有世界级竞争力的企业，并建立了与之对应的组织运作体系。 如果以组织体系的形式对技术商业化模式进行诠释的话，那就是，构建从传统的流线型组织体系到端到端的组织体系。 传统的流线型组织，在工业时代是非常有效的，在今天的知识经济、网络经济环境下，则由于客户需求、市场竞争变化的快速性和不确定性，暴露除了一系列问题：缺乏准确、前瞻的客户需求关注，组织的前端、中端、后端衔接不畅甚至脱节，反复做无用功，浪费资源，造成高成本；没有跨部门的结构化流程，部门流程之间是靠人工衔接，运作过程割裂；组织上存在本位主义各自为政，内耗大；项目计划无效，项目实施混乱等等。 端到端组织流程则从客户需求端出发，到满足客户需求端去，提供端到端服务，端到端的输入端是市场，输出端也是市场。这个端到端非常快捷，非常有效，好比中间没有水库、没有三峡的长江，流程很顺畅。如果达到这么快速的服务，降低了人工成本，降低了财务成本，降低了管理成本，也就是降低了运作成本。其实，端到端的改革就是进行内部最简单的最科学的管理体系的改革，形成一支最精简的队伍。 常山之灵蛇，现代商业组织的榜样 说到这个端对端的组织，最好的比喻，当然是我们大家都熟悉的“常山之灵蛇”，击其首则尾至，击其尾则首至，击其中则首尾俱至。而这条灵蛇的灵，就在于它节节贯通，各个关节配合无间，没有丝毫阻滞，就像没有三峡，没有水库的长江，畅通无阻。这正是现代商业组织需要达到的境界，可以说，这常山之灵蛇，正是现代商业组织的榜样。 我们可以看到，华为的端到端组织，从战略规划，到市场，到产品开发，到销售，到工程交付等等，从头到尾，都是直接面对客户，无疑具备了常山之灵蛇的特点，可以快速应对市场和客户的各种需求和变化。 第四节：技术商业化的必然路径——让工程师成为商人一、技术商业化的核心在于工程师 在传统的组织流程里，前端通常是市场销售人员，中端是技术工程师，后端是售后服务人员。很明显，这样的人才结构无法适应端到端的组织流程的要求。因为前面的人不懂技术，后面的人不了解市场变化和客户需求，将前、中、后三节打通的成本非常高，也很难实现。 端对端组织流程的一个重要特点是，工程师存在于在前、中、后三节之中，并发挥核心作用，就像前面提到的常山之灵蛇一样，首、躯干、尾密切协作，共同发挥作用。这些工程师就是新型的商业工程师。 前端的工程师即是售前工程师，包括企业里通常称谓的产品经理、技术支援工程师、方案设计工程师等，其责任是方案营销（包括技术需求了解、技术牵引、方案设计、技术交流）。在这样的组织里，实际上存在两类销售人员，一类即以上所言售前工程师，另一类才是传统意义上的销售人员，负责客户信息和客户关系。 中端的工程师就是我们通常所言的研发工程师。在端到端的组织里，研发工程师与前面讲的售前工程师一样，既懂技术又懂市场。好比我们在前面微软案例里提到的，他们必须是既懂技术懂经营之道的高素质人才；华为的研发工程师也一样，都是从市场上摸爬滚打下来的。 后端的工程师包括工程项目经理、技术服务工程师等。除了传统的技术工作以外，他们还要承担更重要、更贴近客户的职责，包括：项目利润策划、服务产品设计与营销、通过对客户需求的深入了解驱动研发等等。在很多公司，后端的工程师往往被当成没人管的小孩子，但是，在端对端组织里，后端工程师的作用是极为重要的，请留意以下数据：2008年，IBM的服务收入已经占总收入的约70%，华为公司的数据为约30%！ 由此可见，端到端组织有效运作的核心，在于工程师。一个组织只有具备上述所说的三类工程师，才有可能真正做到从客户需求端出发，到满足客户需求端去，提供端到端服务，两端直通，没有任何水库的阻滞。一旦建立起这样的组织，则如常山之灵蛇，击其首则尾至，击其尾则首至，击其中则首尾俱至，可以做到以不变应万变，如兵法所云：“其疾如风，其徐如林；侵掠如火，不动如山”。 一言以蔽之，让工程师成为商人！ 这是从技术领先型组织蜕变为技术商业化组织的必然路径。 二、什么是商业工程师，商业工程师的事业是什么？ 让工程师成为商人，就是企业需要造就一大批的商业工程师。任正非则把商业工程师称之为科学商人，意思是对科学技术知识进行商业经营的高素质人才。 简言之，商业工程师就是技术工程师和商人的结合者。 技术和市场、业务和商业经营，对多数人而言，是两个不同截然不同的领域，对人有着截然不同的要求。要同时掌握二者的知识和运作规则，确非易事。一流企业的高明之处就在于它们找到了这样的人才，或者通过某些不寻常的方法把上述两样东西成功的融入到员工身上。 商业工程师的来源通常是企业原有的技术工程师，当需要跨越自身的技术领域，去掌握商业经营这一新领域的知识和运作规则时，其难点主要在于如何成为商人。古人认为商人就是那些能够做到“变贵贱，调余缺，度远近”的人，意即通过对不同地域的有余和不足物资的调剂，把南方的东西运输到北边以较高的价格卖出，在满足人们的要求的同时自己也获利。这里包含了商人定义的两个要点：对市场行情的敏锐把握，以及满足人们的需要。 这个定义放在今天，用于商业工程师身上，依然是非常准确的：对市场行情的敏锐把握，代表了商业工程师必须具备的商业意识；如何满足人们的需要，则代表了商业工程师满足客户需求的商业技能。 因此，技术工程师转化为商业工程师，其要点就在于如何具备商业意识和商业技能。 我们不主张如社会有些观点所言，把商业或商人等同于一味追逐利润，实践证明，那些把利润放在第一位而漠视社会民众真正需求的企业，如安然等，其成功终究是昙花一现，社会最终会选择放弃它们，因此不足以为代表，这种企业也缺乏延续的根基。正如管理大师德鲁克所言，企业存在的目的是为了满足社会的某些需要，因此确切的说，企业并不存在利润，利润只是企业正确的履行了责任之后的一个自然的结果。刻意地、不计手段地追逐利润，其结果必会适得其反。 从事业的角度讲，无论个人还是企业，不关赚多少钱，获取多少利润，并不代表就成功了，或者说事业有成了。所谓事业，不是个人，也不是一个单个组织的所谓成功，而在于其对社会的贡献程度。孔子在《易经-系辞》对事业做了非常贴切的定义：举而措之天下之民，谓之事业。就是你做的事情对天下人们都有利益，才能算事业。对于商业工程师而言，凭借自己对技术和市场的双重了解，从社会的真实需求中来，到真正满足人们的需求中去，做到了这两点，就算是在做事业。我们今天的社会，在技术主导、商业利润主导下，已经走了很远很偏了，其结果就如我们今天经历的，我们制造了一切我们所能想象和制造的东西，社会资源以飞快的速度在浪费着，日益枯竭，污染加剧；在以商业利润为基础的剧烈竞争下，人文环境也日益恶化，如今的社会整体环境日益不适合人居。了解社会的真实需求，真正满足人们的需求，既是商业工程师群体的事业，也是一份使命。 三、商业工程师的诞生：以技术为主体开展市场营销的优势 华为、微软、复兴后的IBM等领袖企业的成功的同时，也完成了对企业最核心的人力资源即工程师的全新定义，传统的技术工程师成为了新型的商业工程师。新型的工程师们也改变了市场营销的模式，尤其是在高科技行业。在商业工程师诞生以前，企业市场营销的主体通常是营销人员；现在，市场营销的则以技术为主体展开。以技术为主体展开市场营销有着传统营销无可比拟的优势。要之，有以下三点： 真正把握市场和理解客户需求技术工程师从公司内部走向市场，走向客户，会同销售人员一起，可以实现对市场需求和客户需求的真正了解。高科技行业的营销不同于快速消费品营销，是解决方案的营销，具有非常高的技术含量，专业性强，要求前端的人员具备从解决方案的角度对客户需求有深刻理解的能力。当前很多高科技企业还没有完成营销模式的转型，常遇到的情况是，客户在前期往往对自己的需求未必能描述清楚，传统的销售人员又不懂技术，对企业内部的运作不甚了解，最擅长做的事情就是请客户吃饭、洗脚、打球、培训、旅游，先签下单再说，二者碰到一起，往往是瞎猫撞死耗子，签下的合同无法执行，研发说版本出不来，采购说货到不了，财务说没有现金流……甚至签下一些非常怪异的合同。你见过要服务一辈子的合同吗？有一家高科技企业，由于销售人员缺乏对工程服务知识和产品生命周期的理解，在与客户所签订的合同里，注明的服务期限竟然是永久。最后再加上公司内部合同审核环节的疏忽，该公司于是与客户签订了承诺服务一辈子的合同！ 最低成本运作以技术为主体展开营销，企业的营销队伍其实是由两部分组成的，一部分就是传统的销售人员，负责客户关系，一部分就是我们说的商业工程师，他们往往是研发技术或工程技术出身，对产品、解决方案有着非常透彻的了解。这两个队伍一起参与营销，从不同的角度同时与市场、客户进行深入接触，既能做到对市场趋势的准确把握，又能深刻了解客户的个性化需求，因此可以做到一开始就做正确的事情，并且一次把事情做对，相对于多数企业十次八次反反复复还不能把事情做好，这在很大程度上既节约了社会资源，也节约了企业内部资源，可以做到最低成本运作。 通过技术引导，达到不战而胜兵法云：“胜兵，先胜而后求战”，战争的胜负不是在战场上决定的，而是在战前决定的，战前的人心向背、地形、敌我之众寡、将能与不能等因素，已经在战前就宣布了战争的胜负。历史上有名的淝水之战、官渡之战、赤壁之战等等，几乎是“胜兵，先胜而后求战”的同一个版本。销售也是一样，从一个长期来看，签单往往不是在招标会上决定的，标前的一系列工作，如参展、标准引导、软文宣传、样板店、专家讲座等等，这一系列的工作，在无形中，已经让客户形成了决策。而这种引导，客观上也让客户变得更专业，可以提前做出一些业务规划方面的预测或决策，有利于形成供需双方的良性理解和良性循环。反之，如果没有这些技术引导的工作，公司的销售就会陷入无休止的抢单，天天救火，疲于奔命，这恰恰是当前大多数企业的现状。商业工程师积极参与市场工作，充当销售的先锋、主力，就是要让企业打有准备的仗、打胜利的仗，避免以大量资源消耗为代价的恶性竞争。华为在全球布置了数千名售前工程师，他们准确地把握了海外市场的真实需求，提前做好了一系列的铺垫工作，正是他们让华为2007年、2008年的爆炸式增长成为可能，并且支撑了华为未来3-5年1000亿美金的市场。 第五节 华为技术商业化之路——造就商业工程师 自中国企业进入世界经济体以来，道路就极为曲折、艰辛，并且真正获得成功的企业非常少。尤其是在代表一国经济核心竞争力的高科技行业，中国的绝大多数高科技企业其实缺乏真正的技术含量，即使少数企业具备了自主研发的能力，也因为缺乏对商业运作知识和规则的理解而在走向世界的路上举步维艰。 中国的国有企业，由于资源便利，加上体制的原因，缺乏自力更生的动力，大多民营企业，则先天基础薄弱，在种种条件的挤压下，往往成长乏力。 在这种背景下，在一些缺乏资源支持，竞争极为残酷的地区（如深圳），一些企业经过艰苦卓绝的奋斗，在与世界级企业的贴身肉搏和学习过程中，率先成长起来，具备了在世界舞台上与西方企业共舞的能力。华为公司就是其中一个，它用短短20年的时间，在没有任何外部资源可依赖的条件下，自力更生，从一无所有到250亿美元，成为目前中国唯一一家在研发、市场两个领域同时具备世界级竞争力的企业，并且，它的成功绝非偶然，通过市场管理流程（MM）、集成产品开发流程（IPD）、任职资格体系的建设，在机制和人才两方面都具有了核心竞争力。 在华为的核心竞争力中，数量庞大的商业工程师队伍尤其是核心中的核心。因为西方的高科技企业巨头早已完成了商业工程师队伍的建设，因此能在全球市场叱咤风云，而中国的高科技企业，在该方面还只是刚刚起步。在很多企业还在概念、摸索、尝试阶段时，华为公司已经率先数年系统、完整地建立起了这支队伍，成为其在国内外市场称雄的秘密武器。 下面，我们就以华为公司为例，看看在华为的技术商业化进程中，商业工程师队伍是如何建立起来的。 一、“最幼稚的研发部门” 到９０年代中期的时候，华为在国内市场已经取得了空前的成功，但是也曝露出一系列的问题，产品品质不稳定，交付周期长，维护成本高，过于依赖人海战术等等，这种在国内成功的模式，根本无法在国际上立足，而如果无法走出国门，通讯行业的残酷竞争将很快把华为打回原形，华为再次面临生死抉择。华为将进行的变革的所有方面，几乎都与研发队伍有关。而当年华为的研发部门，从组织体系上讲，一片迷茫和混乱；从研发工程师个体上讲，一方面如郭士纳曾描述过的IBM人，充满了自信、狂热、执着，另一方面，又如任正非描述的，像刚从青纱帐走出来的土八路，浑身是土，一点也不职业化，对面临的国际化竞争不知所措。任正非曾把研发部门描述成华为最幼稚、管理最差的部门。从当年“研发部门发放呆死物料、机票”活动及一系列的反思批判会上可见一斑。为了使华为研发人员能够铭心牢记“从对科研成果负责转变为对产品的市场成功负责”这句话，华为在年终将把库房里的呆滞物料打成一个个包，发给研发人员做奖状。把用户中心的飞机票（为了维修而导致的大量往返），也打成一个个包，发给中研人员做奖状，让他拿回家去对亲人说是自己得的浪费奖！任正非在会议上阐述他对“从对科研成果负责转变为对产品市场成功负责”这一口号的理解：“对待产品也要像对待你的儿子一样”“现在在座的所有的人都必须对产品的市场成功负责，产品犹如你的儿子，你会不会只是关心你儿子的某一方面？你不会吧。一个产品能生存下来，最重要的可能不是它的功能，而只是一个螺丝钉，一根线条，甚至一个电阻。因此，需要你对待产品也要像对待你的儿子一样。”结合这次活动，研发部人员举办了反思批判会，其中详细记载了华为研发的不少“幼稚”故事，而通过对这些幼稚做法的自省，华为人的思维受到的根本性的触动。兹举几例：你到底是研发工程师还是售后工程师？因为产品质量经常出问题，研发工程师需要在国内各城市不断穿梭往返现场解决问题，有些人几乎把天上的飞机都坐遍了。一次，某位研发工程师对一位新来的没怎么出过差的同事吹嘘，他对各种飞机型号和性能的熟练程度，结果该同事反唇相讥，“我还以为你是做售后服务的，真不敢相信，你居然是一个开发人员，是不是国内的研发都这个样子？”上海市话局某部长的牢骚上海市话局的某部长对华为研发的评价：“我对你们的产品很不满意，特别是对你们的态度很不满意，你们总以为你们的产品很先进，总以为是我们的维护人员水平低才出的问题。国外的机器也出问题，但是人家几个小时就定位出来，你们是东派一个高手，西派一个高手，不晓得要多少天才能定位出来……”“亩产十万斤”的华为软件工程师印度高级软件师每人月可以编写300行代码，华为的数据则是10000-20000行，结果就是印度的软件很稳定，华为的软件则漏洞百出……就是在这样反思和批判中，华为人，特别是技术工程师们的头脑中，一种新的思维方式逐渐的孕育起来。华为技术工程师的商业意识也逐步形成。 二、卖出去的技术才有价值——研发是地狱之门 任正非对公司的研发做了一个形象的比喻：研发是地狱之门。一个公司的研发水平高还是不高，都非常有可能进入地狱，万劫不复。公司研发水平高，一方面意味着很大的投入，也许在没有收回成本以前就死掉了；另一方面，研发水平高，代表你的技术非常先进，非常超前，就容易重蹈贝尔实验室之辙，也是死路一条；公司的研发水平不高，你拿什么去和人家竞争，结局还是死。可见研发之难。任正非意识到，华为必须保持技术上的优势，但是，如果死抱着一定要做世界上最先进的产品的理想，华为人能不能在市场上生存下来都成问题，就像梵高的“向日葵”，作品固然好，固然价值连城，可那都是在梵高饿死多年后的事情了。因此，华为公司的调整要以商业为导向，而不能以技术为导向，在对技术部门、技术工程师的评价体系中同样一定要以商业为导向。华为的战略由此发生了根本性的变化，即从技术驱动转变为市场驱动，既要保持技术的领先，更要强调技术商业化的能力。坚决不研发“卖不掉的世界顶尖水平”，华为人认为，“卖出去的技术才有价值。” 三、培养技术商人而不是培养科学家：华为工程师任职资格体系 要增强公司技术商业化的能力，做到卖出去的技术才有价值，华为的人才战略也必须进行重大转型，那就是，华为必须培养工程商人而不是培养科学家，并且必须大批量培养。围绕成批培养商业工程师的问题，华为开始了新的探索。探索的结果，就是华为必须建立一套国内没有过的、全新的人才培养体系。这套体系以英国的职业资格体系为蓝本，充分吸取IBM、微软等西方企业和日本企业的特点，在结合中国国情的基础上，逐步发育起来了。它就是被任正非称为华为过去十年三大变革的任职资格体系。华为工程师任职资格体系不同于外部的能力体系，它涵盖内容更广、对能力的要求程度更深，更重要的是，它针对具体的职位类的理解非常透彻，是由当初IBM、华为等一批最为顶级的相关领域内的专家，在借鉴最佳实践和华为成功经验上得出来的，因此，决不能把它当成是简单的人才能力体系，确切的说，它是一套关于如何做到业界最佳的最佳组织能力宝典。不同于以往的能力体系，华为的工程师任职资格体系可以说是集采众长，而又独具特色。它首先对每个岗位需要的知识点进行了详细的提炼，每个员工在走向岗位前就知道，自己需要具备哪些知识。其次，它针对不同职位类的特点，建立了对应的素质模型，一开始就选对人，让最合适的人最做合适的事情。关于素质模型，值得一提的是，很多企业认为建员工能力体系，就是建素质模型，这实在是一个很严重的误会。素质，无论如何，都是一个人在走向工作岗位前就已经形成的，所谓江山易改本性难移，素质一旦形成就很难改变，对在岗人员建立素质模型，试图以培训的方式来改变员工素质，无异于愚公移山，也许最终可以移走，但是估计没有几家现代企业就可接受其时间成本。华为建立素质模型，主要是用于岗前的人才选择，以及用作长期培养。例如，从现有的技术工程师中，找出那些具备市场素质的人员，让他们冲到市场一线，完成从技术工程师到售前工程师的转变。正因为素质较难改变的特点，华为从另一个角度来帮助员工能力的提升，这就是专业技能。华为从IBM的请来了操作指导书，针对转变为专业、职业人所需要的专业技能，华为以操作指导书的形式固化下来，并将其尊为圣经，任正非曾公开表示，华为的员工总是认为自己很聪明，自以为是，现在，华为从IBM买来了美国鞋，华为“削足适履”也要适应它。华为工程师的操作指导书，巧妙的将工程师需要的商业意识、商业技能融入到日常的作业行为中，既便于操作，又易于考量。例如，我们无法考量一个售前工程师是否具有良好的商业意识，但是，如果他能够按操作指导书的要求，在拜访客户前详细收集信息，资料准备充分，拜访时提出正确的问题，能根据事前的准备对现场的不同情况做出相对应的调整，拜访后及时总结，提出相应策略，这个过程既培养了他的商业意识，也形成了他的商业技能。如果他能认真遵照有关要求操作，我们就认为他具备了良好的商业意识和技能。华为工程师任职资格标准最重要的一点，就是它从成果出发，对工程师以市场贡献为重点进行考量。在华为的工程师任职资格标准里，对售前工程师、研发工程师、售后工程师，都从市场成果的角度进行了的要求：售前工程师：从被动技术方案设计到主动方案营销，提炼卖点，引导销售成功。研发工程师：关注市场需求，对产品的市场成功负责。售后工程师：从被动服务到主动创造客户价值，营造收费氛围，发现客户需求，拓展服务领域。以上是从大类的角度进行的宏观要求，对于具体到不同类别、不同层级的工程师，华为都规定了非常详细的衡量成果。成果是最可衡量的，也是大家最容易关注到的，正是这一点，真正的把华为工程师从技术工程师转变为商业工程师。在建立工程师任职资格标准的基础上，华为通过培训培训再培训，按照资格要求，开展了大量的商业化课程培训。从华为后来的培训课程设置来看，我们可以看出商业工程师任职资格标准的建立所起到的巨大作用，例如，华为先后对市场人员进行过国学、奢侈品知识培训等，如果不是事先完成了商业工程师的角色转变和相关任职资格标准的建立，任何人都很难想象这些培训课程跟售前工程师们有什么关系，如今，这些课程的设置则更深入的反映了华为在商业化方面的超前思维和务实作风，华为最近几年的巨大成功，足资证明。为了使商业工程师队伍的建设更为迅速、更为有效、更为深入，华为同时也做出了许多相关的配套措施，例如：没有市场一线经验的研发人员不能提拔。公司明确规定，每年必须有一定比例的研发人员走向市场，同时有一定比例的市场人员转做研发；成立战略市场部，主要由技术工程师出身的人员担任其中职责，这些人凭着对技术的敏感，把触角伸到市场的每一个角落，深入了解客户当前和未来的需求，他们成了华为前进过程中的“侦察连”。从市场的角度考核研发人员。评价研发人员，不仅仅是技术、开发周期维度，更重要的是新产品获利、上市周期等指标。……通过这一系列的战略调整，华为的工程师队伍完成了脱胎换骨的变化，华为在技术商业化的路上越走越顺了。其中的两个关键数据最能说明问题，一是，华为在最初打入国际市场的时候，到处碰壁，有些地区甚至长达两三年颗粒无收，最后华为在全球各地派出一支合计1000多人的技术工程师队伍进行市场工作，国际市场的缺口很快就打开了；二是，随着华为国际市场的成功，以及10年来在商业工程师队伍培养方面逐步开花结果，组织人才建设有力地推动了业务增长，华为迎来的业务上的井喷式增长，到2008年达到250亿美元！如果没有早在10年前做出的这一系列举措，以及长期不懈的坚持，很难想象华为会有今天的巨大成功。中国不缺乏技术人才，缺乏的是商业化环境下的产品研发工程师、售前工程师、售后工程师。一个企业的工程师商业化水平决定了这家企业的市场竞争力的高低。中国高科技企业成长的障碍就是技术人员商业化问题。当技术人才商业化之后，它的能量将是无限的。摆在绝大多数高科技企业面临的最大挑战，就是如何批量培养商业工程师。","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"技术商人","slug":"技术商人","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF%E5%95%86%E4%BA%BA/"}]},{"title":"桥水基金Ray Dalio给年轻人的建议","slug":"认知-修行-平衡/advice4young_raydalio","date":"2023-07-20T02:45:30.000Z","updated":"2023-07-20T07:32:19.757Z","comments":true,"path":"2023/07/20/认知-修行-平衡/advice4young_raydalio/","link":"","permalink":"http://example.com/2023/07/20/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/advice4young_raydalio/","excerpt":"","text":"Ray Dalio - Modern Wisdom, youtube 了解自己的天性，性格，原动力是什么。可以通过pricipleyou.com测试 去学习，去经历，去反思。(1). Ray Dalio的进步公式：痛苦pain + 反思reflection &#x3D; 进步progress 培养自己的远见(1). 理解发生的事情-&gt;发现事情的周期-&gt;获得自己的观点-&gt;清楚自己在周期中的位置-&gt;了解自己的生命周期(2). 佛曰：成住败空，Anything has a cycle. 如何在动乱不安的世界中寻找慰藉？(1). 活在当下，知足常乐，回归自然，冥想🧘","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"人生建议","slug":"人生建议","permalink":"http://example.com/tags/%E4%BA%BA%E7%94%9F%E5%BB%BA%E8%AE%AE/"}]},{"title":"问题解决框架","slug":"认知-修行-平衡/methodology","date":"2023-07-20T02:18:38.000Z","updated":"2023-07-20T03:44:36.900Z","comments":true,"path":"2023/07/20/认知-修行-平衡/methodology/","link":"","permalink":"http://example.com/2023/07/20/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/methodology/","excerpt":"","text":"办公室教授 7步工作法 Seven Steps to Efficitive Problem Solving 根源分析 Root Cause Analysis CIRCLES method for problem-solving Product Kano analysis DMAIC framework for problem-solving","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"方法论","slug":"方法论","permalink":"http://example.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"}]},{"title":"人类简史/人类发展周期","slug":"认知-修行-平衡/huamn_his","date":"2023-07-19T03:19:38.000Z","updated":"2023-07-19T04:01:34.832Z","comments":true,"path":"2023/07/19/认知-修行-平衡/huamn_his/","link":"","permalink":"http://example.com/2023/07/19/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/huamn_his/","excerpt":"","text":"狩猎社会 公元前200万年 认知革命 公元前5万年到10万年 智人产生，想象力，虚构的神 开始出现了部落社会 大家开始学会了合作，智人的合作事建立在虚构的故事上的 开发并学习使用工具 把其他人种挤出了历史跑道 农业革命 公元前1万年前，想要获得更多的蔬果粮食 开始了定居社会，因为农田搬不动 农民的历史总结为一句话：日出而作，日落而息 历史的发展说明：没有平等，公义可言 国家就是一个想象的秩序，人们无法逃离 为什么人们会逃不出呢？ 现实世界就是一个想象的秩序，如果你打破了秩序，就是打破了现实世界 人们都有欲望 主观意志 为什么人们会趋于统一呢？ 金钱，信用 帝国 宗教 工业革命 18世纪末，纺织工业新技术革命 19世纪中期，蒸汽和钢铁技术革命 20世纪初，电气和化学技术革命，汽车工业革命 20世纪中叶，人们意识到经济的制高点不在于对现有工业的控制，而是在于创造未来的能力 资本革命- 科技革命 的 未来 生物工程&#x2F;基因工作 仿生工程 无机的生命&#x2F;数字个体 快乐是怎么来的 放弃主动追求快乐，因为快乐是一时的，佛教最是支持去快乐，众生皆苦，皆要成佛，去掉贪嗔痴 参考资料 B站-1小时看透人类10万年，《人类简史》从动物到上帝","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"人类简史","slug":"人类简史","permalink":"http://example.com/tags/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/"},{"name":"发展周期","slug":"发展周期","permalink":"http://example.com/tags/%E5%8F%91%E5%B1%95%E5%91%A8%E6%9C%9F/"}]},{"title":"中国历史路线演进图","slug":"认知-修行-平衡/中国历史路线图","date":"2023-07-13T01:59:33.000Z","updated":"2023-07-16T01:38:06.431Z","comments":true,"path":"2023/07/13/认知-修行-平衡/中国历史路线图/","link":"","permalink":"http://example.com/2023/07/13/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/%E4%B8%AD%E5%9B%BD%E5%8E%86%E5%8F%B2%E8%B7%AF%E7%BA%BF%E5%9B%BE/","excerpt":"","text":"从历史学习经验，人生充满希望！","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"中国历史路线","slug":"中国历史路线","permalink":"http://example.com/tags/%E4%B8%AD%E5%9B%BD%E5%8E%86%E5%8F%B2%E8%B7%AF%E7%BA%BF/"}]},{"title":"什么是人性？","slug":"认知-修行-平衡/人性是什么","date":"2023-07-13T01:59:33.000Z","updated":"2023-07-15T02:41:32.868Z","comments":true,"path":"2023/07/13/认知-修行-平衡/人性是什么/","link":"","permalink":"http://example.com/2023/07/13/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/%E4%BA%BA%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"人性是一个概念性的词语，它是人对事物反应的情绪总和。 世上所有关系的结合和打破，就是关乎两个字：利益。人性背后的本质就是利益，而利益包含了物质利益和精神利益。 如何懂得人性？就是要有认知，认知来之两个途径：学习和实践。 道德，道和德拆解。道是一种自然规律。德是人自我约制的表象。舍得，先舍后得。","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"人性","slug":"人性","permalink":"http://example.com/tags/%E4%BA%BA%E6%80%A7/"}]},{"title":"monica AI GPT 总结视频内容2","slug":"ML/monica-ai-exam2","date":"2023-06-15T05:25:10.000Z","updated":"2023-07-22T01:53:19.151Z","comments":true,"path":"2023/06/15/ML/monica-ai-exam2/","link":"","permalink":"http://example.com/2023/06/15/ML/monica-ai-exam2/","excerpt":"","text":"Sam Altman - How to Succeed with a Startup](https://www.youtube.com/watch?v=0lJKucu6HJc&amp;ab_channel=YCombinator)的详细摘要： Monica 00:00打造一个人们自发告诉朋友的伟大产品是创业公司成功的关键。 成功的程度与建立一个人们喜爱的伟大产品成正比。 像谷歌和Facebook这样成功的公司就是被人们通过口碑发现的。 一个简单易懂的产品是成功的重要指标。 初创企业需要寻找一个正在经历或即将经历指数级增长的市场。 02:37 初创企业在下大赌注之前，需要有一个传道授业的创始人，一个雄心勃勃的愿景和每个用户的密集使用量。 iPhone的成功表明，有些东西已经从根本上发生了变化，有一个新的计算平台将催生巨大的业务。 VR也许有一天会成为大生意，但目前，大多数拥有VR头盔的人从未或很少使用它。 初创企业至少需要一位传教士式的创始人，他可以用热情感染整个世界，让大家了解公司要做什么。 拥有一个雄心勃勃的愿景有助于建立一个团队和吸引投资者。 05:17对未来有自信和明确的看法，有雄心勃勃的愿景，但如果成功的话，规模巨大的初创企业将吸引最好的人才。 对未来有一个自信和明确的看法，并且是一个明确的领导者，这与成功相关。 建立一个伟大的团队是一个创始人可以做的最重要的事情之一。 创始人要经历一个从建立产品到建立公司的过渡。 07:56让团队成员不断提出新的想法和 “我们会想出办法 “的精神对早期的创业团队很重要。 初创企业通过快速行动和在事情不成功的情况下迅速调整来赢得胜利。 拥有说 “我知道了 “并偏重于行动的团队成员是很重要的。 没有经验的祝福会导致不可思议的事情，因为没有人告诉他们这很难。 10:35初创企业需要保持势头，有竞争优势，有合理的商业模式，并有发展计划。 势头对于初创企业继续提供超出预期的结果至关重要 长期竞争优势是成功的必要条件 合理的商业模式是很重要的，即使在开始时没有完全想好。 一个增长和获取用户的计划是成功的必要条件。 13:13与大公司相比，初创企业在决策速度、在坏主意上取胜的能力以及在大平台转变上取胜方面具有优势。 初创企业只需要一个人同意就可以追求一个想法，而大公司则需要所有人同意。 初创企业在不断变化的市场中具有敏捷性和速度的优势，使他们能够做出更好、更快的决定。 初创企业通常在大的平台转变中获胜，因为大公司在进行战略转移时比较慢。","categories":[{"name":"技能-修行-进步-AI助手","slug":"技能-修行-进步-AI助手","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-AI%E5%8A%A9%E6%89%8B/"}],"tags":[{"name":"GPT","slug":"GPT","permalink":"http://example.com/tags/GPT/"},{"name":"monica-AI","slug":"monica-AI","permalink":"http://example.com/tags/monica-AI/"}]},{"title":"monica AI GPT 总结视频内容1","slug":"ML/monica-ai-exam1","date":"2023-06-15T05:21:10.000Z","updated":"2023-07-22T01:53:12.818Z","comments":true,"path":"2023/06/15/ML/monica-ai-exam1/","link":"","permalink":"http://example.com/2023/06/15/ML/monica-ai-exam1/","excerpt":"","text":"OpenAI Sam Altman &amp; Greg Brockman: Fireside Chat in Seoul, Korea | SoftBank Ventures Asia](https://www.youtube.com/watch?v=_hpuPi7YZX8&amp;ab_channel=SoftBankVenturesAsia)的详细摘要：[Monica](https://monica.im) 00:00 Sam Altman和Greg Brockman讨论了他们对韩国文化的尊重和钦佩，以及韩国的创新人工智能初创企业。 萨姆会说韩语，他喜欢韩国文化中传统和新事物的结合 格雷格非常尊重韩国的技术，特别是在互联网接入方面。 两人都对韩国的人工智能初创企业的发展程度和对聊天GPT技术的热情印象深刻。 07:15OpenAI不仅仅是一家语言模型公司，而是一家专注于深度学习和向AGI迈进的AI公司。 OpenAI尝试了很多失败的东西，但只看到成功的东西。 实现AGI的进展可以用最大的项目规模来衡量。 OpenAI已经致力于不同的主题，包括机器人学和强化学习。 14:30销售一个模糊的愿景需要自信心，并在从现实中学习时调整战术。 在人工智能领域没有正确的答案，只有随着时间推移变得更加准确的答案。 相信技术并有一个基本的赌注是很重要的。 最初的战术可能经不起时间的考验，需要随着新挑战的出现进行调整。 21:46处理快速变化的技术的最佳建议是成为适应新技术的专家，并利用它来解决问题。 具体的技术技能会很快变得过时。 适应新技术并找到使用它来解决问题的方法的元技能更重要。 不同的国家将以不同的方式监管人工智能的使用情况。 29:03OpenAI有失败的项目，也有成功的项目，一些项目由于技术还没有准备好而失败，而另一些项目尽管一开始就觉得注定要失败，但结果还是成功了。 OpenAI Universe是一个由于技术还没有准备好而失败的项目。 另一方面，API项目最初感觉是注定要失败的，但最后却获得了巨大的成功。 对于API项目，OpenAI经历了与客户交谈的痛苦，并在推出之前获得了早期采用者。 36:18 人工智能将使人们更有生产力，并创造新的工作类型，但技术变革的速度是一个问题。 许多领域对劳动力的需求过剩。 人工智能将创造出难以想象的新工作类别。 人类的创造力和能力将依然重要。 技术变革的速度是一个问题，UBI是潜在解决方案的一个有趣的组成部分。 43:35 OpenAI认为，内容创作者应该从人工智能技术中获益，要找到补偿的机制，必须进行实验。 OpenAI认为，内容创作者应该为他们帮助AI变得更好的工作得到补偿。 实验是必要的，以找到补偿的机制。 OpenAI直接与社区中正在创作的人接触。 50:51人工智能的进步是许多术语的乘法，计算硬件是一个重要因素，还有数据和工程口径。 AI的进步是计算能力、数据和工程口径的产物。 为了优化人工智能的进展，所有因素都应该是相等的。 定制硅领域对建立新的架构很有意思。 定制硅领域的障碍是建立伟大的软件。","categories":[{"name":"技能-修行-进步-AI助手","slug":"技能-修行-进步-AI助手","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-AI%E5%8A%A9%E6%89%8B/"}],"tags":[{"name":"GPT","slug":"GPT","permalink":"http://example.com/tags/GPT/"},{"name":"monica-AI","slug":"monica-AI","permalink":"http://example.com/tags/monica-AI/"}]},{"title":"conda docker git vim ssr","slug":"小而美-工具/conda_docker_git_vim","date":"2023-06-12T14:46:10.000Z","updated":"2023-07-20T04:01:42.106Z","comments":true,"path":"2023/06/12/小而美-工具/conda_docker_git_vim/","link":"","permalink":"http://example.com/2023/06/12/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/conda_docker_git_vim/","excerpt":"","text":"自建ssr服务器 https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B conda的使用笔记 创建环境conda create -n name python&#x3D;3.8 激活环境conda activate name 关闭环境conda deactivate 查看当前环境conda env –list 查看前期环境中pip列表pip list 查看指定pip包的安装pip list | grep packagename 删除环境conda remove -n name –all 克隆环境conda create -n BBB –clone AAA，B是A的克隆 转移环境 conda转移：conda env export &gt; name.yaml,然后新系统下执行conda env create -f name.yaml pip转移：pip freeze &gt; requirements.txt,然后新系统下pip install -r requirements.txt docker的使用笔记，轻量化虚拟技术 缺点：争抢资源，权限过高；优点：可移植性高，环境封闭 基础概念：dockfile，images，container, volume dockfile：docker的配置文件 image：docker的镜像文件，用来创建container的母本 container：俗称容器，docker最终落地的形态，是一个运行程序的隔离环境。 volume：数据卷， dockerfile常见的命令(大写形式)： FROM： WORKDIR： COPY RUN CMD docker 常见命令 docker create docker ps -aq，查看所有的容器 docker images -q，查看所有的镜像 docker build docker run -p -v 数据和命令，通过映射的方式在宿主和容器之间进行传递，其中-p表示port，端口，-v表示volume，卷。 -d,daemon，在后台运行。–name，表示名字1docker run -d --name music -p 264:264 -v /opt/musciplayer:/var/www/html/cache/music-player-docker 例子：通过冒号作为宿主和容器之间的分隔符!1宿主 : 容器 docker stop ，停止指定容器，docker stop $(docker ps -aq)，停止所有容器 docker restart docker rm ，删除指定容器，docker rm $(docker ps -aq)，删除所有容器 docker rmi ，删除指定镜像，docker rmi $(docker images -q)，删除所有镜像 docker exec -it &#x2F;bin&#x2F;bash docker volume create docker cp :&#x2F;opt&#x2F;file.txt &#x2F;opt&#x2F;local&#x2F; docker cp &#x2F;opt&#x2F;local&#x2F;file.txt :&#x2F;opt&#x2F; docker有了专门清理资源(container、image、网络)的命令，docker system prune docker image prune –force –all 或者docker image prune -f -a 删除所有不使用的镜像 docker container prune -f 删除所有停止的容器 docker compose docker compose up docker compose down git的使用笔记vim的使用笔记ssh知识和问题集 ssh连接发生错误信息：kex_exchange_identification: Connection closed by remote host 解决方法：可能是认证的key失效了，进入~&#x2F;.ssh，删除know_hosts目录，重新连接一下 基本命令pwd 打印当前文件夹的路径cd 改变目录, 相当于 windows 下的打开文件夹ls 展示当前目录下的所有文件内容mkdir 创建目录, 创建文件夹rmdir 删除文件夹touch 创建文件rm 删除文件cat 原意是指将文件与终端输出流连接, 通俗的说输出文件内容less 或 more( Unix ) 命令可以分页的打开文件, 注意使用 q 退出echo 命令 打印 重定向, 如果文件存在, 则将文件截断, 并重新输入. 重定向. 不截断重定向ipconfig&#x2F;all 查看ip信息ping IP地址 查看是否连接成功tips:注意: 换行问题:在 linux 中使用 \\n 表示换行;在 windows 中使用 \\r\\n 表示换行注意:文件截断是指将文件的所有内容删除, 但是文件的创建时间等信息不更改 查看某一目录下所有文件夹的内存占用 du -sh .&#x2F;* –exclude proc 查看各磁盘内存情况 df -h 开启ssh远程连接服务 测试是否安装了openssh server，sudo service ssh start 如果没有安装，则安装，sudo apt update &amp;&amp; sudo apt install openssh-server 安装完毕则可以开始连接了 本地机器和远程服务器之间传送文件 scp命令，scp [参数] &lt;源地址（用户名@IP地址或主机名）&gt;:&lt;文件路径&gt; &lt;目的地址（用户名 @IP 地址或主机名）&gt;:&lt;文件路径&gt; #拷贝文件夹，加-r参数 例子；scp -r &#x2F;home&#x2F;tim&#x2F;workspace&#x2F;github&#x2F;style &#x74;&#105;&#x6d;&#64;&#x31;&#x39;&#x32;&#46;&#49;&#x36;&#56;&#x2e;&#120;&#x78;&#120;&#46;&#x78;&#120;:&#x2F;home&#x2F;tim&#x2F;github&#x2F;style","categories":[{"name":"小而美-工具","slug":"小而美-工具","permalink":"http://example.com/categories/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"conda-docker-git-vim-ssr","slug":"conda-docker-git-vim-ssr","permalink":"http://example.com/tags/conda-docker-git-vim-ssr/"}]},{"title":"FLOPs","slug":"ML/FLOPs","date":"2023-05-31T05:19:10.000Z","updated":"2023-07-16T11:35:07.645Z","comments":true,"path":"2023/05/31/ML/FLOPs/","link":"","permalink":"http://example.com/2023/05/31/ML/FLOPs/","excerpt":"","text":"NPU的性能参数分解注意相同 FLOPs 的两个模型其运行速度是会相差很多的，因为影响模型运行速度的两个重要因素只通过 FLOPs 是考虑不到的，比如 MAC（Memory Access Cost）和网络并行度；二是具有相同 FLOPs 的模型在不同的平台上可能运行速度不一样。 &#x3D;&#x3D;模型参数量的分析是为了了解内存占用情况，内存带宽其实比 FLOPs 更重要。目前的计算机结构下，单次内存访问比单次运算慢得多的多。&#x3D;&#x3D;对每一层网络，端侧设备需要： 从主内存中读取输入向量 &#x2F; feature map；从主内存中读取权重并计算点积；将输出向量或 feature map 写回主内存。 双精度、单精度和半精度CPU&#x2F;GPU 的浮点计算能力得区分不同精度的浮点数，分为双精度 FP64、单精度 FP32 和半精度 FP16。因为采用不同位数的浮点数的表达精度不一样，所以造成的计算误差也不一样，对于需要处理的数字范围大而且需要精确计算的科学计算来说，就要求采用双精度浮点数，而对于常见的多媒体和图形处理计算，32 位的单精度浮点计算已经足够了，对于要求精度更低的机器学习等一些应用来说，半精度 16 位浮点数就可以甚至 8 位浮点数就已经够用了。 对于浮点计算来说， CPU 可以同时支持不同精度的浮点运算，但在 GPU 里针对单精度和双精度就需要各自独立的计算单元。 浮点计算能力FLOPS：每秒浮点运算次数，每秒所执行的浮点运算次数，浮点运算包括了所有涉及小数的运算，比整数运算更费时间。下面几个是表示浮点运算能力的单位。我们一般常用 TFLOPS(Tops) 作为衡量 NPU&#x2F;GPU 性能&#x2F;算力的指标，比如海思 3519AV100 芯片的算力为 1.7Tops 神经网络运算性能。 MFLOPS（megaFLOPS）：等于每秒一佰万（&#x3D;10^6）次的浮点运算。GFLOPS（gigaFLOPS）：等于每秒拾亿（&#x3D;10^9）次的浮点运算。TFLOPS（teraFLOPS）：等于每秒万亿（&#x3D;10^12）次的浮点运算。PFLOPS（petaFLOPS）：等于每秒千万亿（&#x3D;10^15）次的浮点运算。EFLOPS（exaFLOPS）：等于每秒百亿亿（&#x3D;10^18）次的浮点运算。 硬件利用率(Utilization)在这种情况下，利用率（Utilization）是可以有效地用于实际工作负载的芯片的原始计算能力的百分比。深度学习和神经网络使用相对数量较少的计算原语（computational primitives），而这些数量很少的计算原语却占用了大部分计算时间。矩阵乘法（MM）和转置是基本操作。MM 由乘法累加（MAC）操作组成。OPs&#x2F;s（每秒完成操作的数量）指标通过每秒可以完成多少个 MAC（每次乘法和累加各被认为是 1 个 operation，因此 MAC 实际上是 2 个 OP）得到。所以我们可以将利用率定义为实际使用的运算能力和原始运算能力的比值：————————————————版权声明：本文为CSDN博主「那个苏轼回不来了丶」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_45763093/article/details/118519790","categories":[{"name":"技能-修行-进步","slug":"技能-修行-进步","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"FLOPs","slug":"FLOPs","permalink":"http://example.com/tags/FLOPs/"}]},{"title":"水墨先生算命","slug":"认知-修行-平衡/mozi91_luck","date":"2023-05-28T02:40:33.000Z","updated":"2023-07-16T11:23:43.887Z","comments":true,"path":"2023/05/28/认知-修行-平衡/mozi91_luck/","link":"","permalink":"http://example.com/2023/05/28/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/mozi91_luck/","excerpt":"","text":"","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"命理","slug":"命理","permalink":"http://example.com/tags/%E5%91%BD%E7%90%86/"}]},{"title":"现代机器学习监控的混乱局面：重新思考流媒体评估（4/4）","slug":"现代机器学习监控的混乱局面/model_monitoring_mess_part04","date":"2023-05-24T14:45:16.000Z","updated":"2023-07-22T01:34:57.359Z","comments":true,"path":"2023/05/24/现代机器学习监控的混乱局面/model_monitoring_mess_part04/","link":"","permalink":"http://example.com/2023/05/24/%E7%8E%B0%E4%BB%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%91%E6%8E%A7%E7%9A%84%E6%B7%B7%E4%B9%B1%E5%B1%80%E9%9D%A2/model_monitoring_mess_part04/","excerpt":"","text":"作者：Shreya Shankar- 原文连接：rethinking ml monitoring 4 在过去的几篇文章中，我讨论了流式ML评估，思考了要监控的内容（跨状态和组件轴），并探索了现有软件监控工具（如Prometheus）的故障模式。在这最后一篇文章中，我为ML监控中的问题提出了一个更广泛的研究议程，由 “真实世界 “的ML部署后问题所激发。 预备工作 我们将用一个例子来阐述这个议程： 任务：对于乘坐出租车，我们想预测出租车乘客给司机的小费超过车费10%的概率。这是一个二元分类问题。预测值是在0和1之间的浮点数。 数据集：我们使用从纽约市出租车联盟收集的2020年1月1日至5月31日的数据。这是一个 “时间上演变的表格数据 “的例子（这句话是从阿伦-库马尔那里偷来的）。 SLI：我们衡量准确度，或者当四舍五入到最接近的整数时，正确预测的例子的分数。在ML社区，SLI通常被称为评估指标。 管道结构：我们的例子只包括一个模型。2有两条管道–代表训练和推理–共享一些组件，如清洗和特征生成。请参考本系列的第三篇文章中的图表。 挑战的保护伞 我的研究议程主要集中在数据管理，而不是算法。 度量衡计算 我将指标计算分为粗粒度和细粒度两类。3 粗粒度指标是SLI（如准确率、精确率、召回率），与商业价值最接近，需要一些反馈，或标签。我们使用粗粒度的指标来检测ML性能问题。细粒度指标是可能表明或解释粗粒度指标变化的指标，不一定需要标签（例如，一个特征的两个连续滑动窗口之间的KL分歧）。我们使用细粒度的指标来诊断ML的性能问题。相关的、我认为许多组织都落入了这样的陷阱，即首先监测细粒度的指标、 仿佛一个不起眼的特征的中位值的一些变化会对是否重新训练一个模型提供任何可操作的洞察力。当粗粒度的度量应该被视为一等公民时。 粗粒度的监控：检测ML性能问题 令人惊讶的是，各组织发现要了解其SLI的实时价值具有挑战性。一些原因是： 预测和反馈组件之间的分离。如果一条流水线进行预测，而另一条流水线摄取反馈，我们就需要对一个高权重的属性进行连接。这可能不是一个研究问题本身，但却是一个需要考虑的恼人的工程问题，特别是在流媒体环境中。 改变感兴趣的子群体。许多组织监测不同子群体（如客户）的SLI 随着时间的推移，新的子群体或人口统计学可能逐渐进入数据流。组织很难知道要监测哪些子人群–考虑到覆盖面（即支持）、时间变化或高培训损失。 标签滞后。由于预测和反馈部分的分离，在我们做出预测后，其相应的反馈（即标签）在一段时间后（或根本没有）到达系统中。不同的预测或子组之间的延迟可能并不一致。在需要人类手动标注数据的情况下，延迟会加剧。此外，我们假设标签滞后是一个非平稳的时间序列（即未预料到的问题可能导致滞后，而且可能没有一个模式）。 Scalable Monitoring Infrastructure 解决前两个问题，特别是在规模上，需要更好的监控基础设施，优先考虑增量维护的连接，灵活定义SLI（即用户定义的功能），智能建议监控的内容，以及在部署后添加新的SLI定义并通过历史数据窗口计算的能力。我的上一篇文章展示了Prometheus如何不满足这些需求。为此，我正在考虑一个具有以下层次的ML监控系统： 存储。我们需要一个时间序列数据库用于持久性存储（计算的度量值、直方图或总结、原始输出和反馈），以及用于快速连接和度量计算的内存流。 执行。用户应该能够将度量函数指定为Python UDFs，我们可以用一个基于数据流的差分系统（Murray等人）在数据窗口上增量运行。考虑一个假想的用户工作流： 在上面的工作流程中，用户定义他们自己的度量函数，并用记录函数来记录他们的代码。我们将需要加入输出和反馈–增量的，以节省时间–并在任意的窗口大小上计算度量。一个初步的原型4计算流式ML SLI，定义为Python UDFs，跨越不同的组件，显示出有希望的度量计算时间和最小的日志开销： 图1：ML查询和记录的延迟。 查询。支持快速和灵活的查询是最重要的。在用户查询之前预先计算和存储摘要–包括连接和度量值–会产生最低的延迟查询；然而，用户可能希望在查询时改变窗口大小和其他参数。在查询时间之前进行预计算和在飞行中计算所有内容之间的最佳权衡是什么？此外，随着用户添加新的UDF和新的子群的出现，我们如何有效地回填部署以来所有窗口的度量值？ 估计有标签滞后的实时SLI 我们不仅需要考虑监测基础设施，而且还需要能够正确计算SLI。滞后为计算SLI引入了有趣的算法挑战。如果用户不能及时收到所有预测的标签（反馈），我们如何尽可能正确地估计实时SLI？ 全面反馈 在这种情况下，为了计算一个窗口的SLI，我们只需要执行一个流式连接。挑战发生在规模上，或者当我们的窗口尺寸太大，无法在内存中容纳预测和反馈时。一个自然的解决方案可能是执行近似的流式连接，但是众所周知，在连接之前对流式进行均匀的子采样，可以在结果中产生四倍的少的图元（Chaudhuri等人）。现有的流式连接的近似查询处理（AQP）技术在图元的数量或所产生的连接的代表性之间权衡准确性。在我们的案例中，我们关心的是后者，因为我们想使我们的SLI近似的误差最小化（即近似的精度应该接近于精确的精度）。所以我们可能不想利用最先进的宇宙抽样技术（Kandula等人）来保留大量的连接结果图元，因为它们不一定能提供准确的估计（Huang等人）。 为了优先考虑我们连接样本的代表性，我们可以从渐进式近似连接的分层抽样技术中得到启发（Tok等人）。直观地说，为了使我们的SLI近似值的误差最小化，我们应该构建具有相似预测误差（即ML模型目标认为的损失）的阶层或子组。不幸的是，在我们的高数据设置中，我们无法计算每个预测的误差（因为我们无法将每个预测连接到其相应的标签上）!也许我们可以在高层特征分组中识别 “典范”（即 “重要 “的数据点），并在分组标签上加入典范。例如，在我们的高尖预测问题中，我们可以将我们的预测和标签按邻里（例如FiDi、Tribeca、Midtown）分组，在这些组中挑选典范，汇总这些典范的预测和标签，并将它们连接起来以计算指标。研究的挑战在于设计出高效、高准确度的方法–可能是混合的ML和数据处理技术–来计算群体和典范。 无反馈 这种情况通常在部署后立即发生。在我们纽约市出租车的例子中，假设我们有两个原始数据来源：出租车传感器遥测数据（如里程、位置）和计价器数据（如支付信息）。计价器数据可能会在以后分批出现，促使我们找到其他方法来估计没有标签的实时性能。 一个想法是使用重要性加权（IW）技术（Sugiyama等人）。在高层次上，我们可以根据输入特征确定子组，算出每个子组的训练SLI（例如准确度），并根据实时（部署后，未标记）数据中每个子组的点的数量来加权这些准确度。在我们的例子中，基本的子组定义可以是街区–对于纽约市的每一个街区，我们会找到训练的准确性，并通过相应街区中的实时点的比例来加权，以获得其 “估计 “的准确性。然后，我们将每个社区的估计值汇总，得到一个整体的估计精度。对于一个更复杂（和更高置信度）的方法，我们可以构建不同的分组，并对所产生的SLI估计值进行平均。同样，研究的挑战在于确定这些分组，当然也包括评估这些方法的效果。 我们可以在训练集或直播流中确定子群。最便宜的选择是根据训练数据点来计算子群，因为这可以做一次。然而，有了这个 “静态子群 “选项，实时的SLI估计就变得不那么准确了，因为子群的代表性随时间而变化。因此，我们希望在实时数据中计算出适应性的子群。我们可以利用流式聚类算法，这些算法对不断变化的数据分布具有明确的鲁棒性（Zubaroğlu等人）；然而，这在我们的案例中是额外昂贵的，因为每次有新的实时数据进来，我们都需要重复地将训练数据集的点重新分配给聚类。此外，集群在训练集中可能很少或没有相应的数据点，使我们无法估计出SLI。因此，我们需要研究在高维的、不断变化的数据流中有效识别子群的方法，并考虑到参考数据集（即训练集）。 部分反馈 这种情况是我在 “野外 “看到的ML管线中最常见的。通常情况下，实时数据只在时间表上标注，更多的时候，一些上游的数据收集问题影响了反馈的到来（例如，在Tribeca的某个地区有一个手机塔的中断，导致支付表的数据比预期的晚到）。假设标签滞后的分布是未知和非平稳的, (即训练一个单独的模型来预测哪些预测不会有反馈可能是不可行的），在这种情况下，我们如何估计实时SLI？ 乍一看，也许我们可以简单地汇总全反馈和无反馈的估计值，按每个子组的数据点的数量加权。但现实情况是，标签滞后很少在各桶中均匀分布，识别具有类似反馈滞后时间的数据点组，对产生实时SLI的准确估计至关重要6。我们可以利用无反馈部分所描述的流式聚类算法，但这种聚类可能无法解释，或者只用谓词中的几个条款简单描述（Saisubramanian等人）。出于调试的目的，我们还关心这些 “滞后 “的数据点集群如何随时间变化，或者滞后的异常情况。 也许我们可以从流模式挖掘算法中获得灵感，比如频繁项集（Rajaraman和Ullman等人）。然而，这类算法是在标签不变的数据点窗口中寻找特征组，而我们想要应用频繁项集算法的数据点–那些没有反馈的数据点（即 “滞后 “点）–在我们计算出频繁项集后可能会得到反馈。因此，我们如何扩展流式频繁项集算法，以便在删除数据点后有效地重新计算项集？我们可以在频繁项集的增量维护工作的基础上（Tobji等人）。 细致的监控：诊断ML性能问题 当SLI较低时，最优先考虑的是尽快使其回升。”细粒度 “监测类别涉及表现不佳的管道的 “根本原因分析”–模型是否应该重新训练，或者管道中的工程问题是否是失败的根本原因。此外，如果模型应该被重新训练（例如，有 “漂移 “或 “转移”），我们应该如何改变训练集以提高性能？ 检测数据质量问题 针对ML可观察性的数据管理研究在自动识别数据管道中的工程问题方面取得了进展（Schelter等人，Breck等人）。诸如模式验证、检测批次内的异常值以及对特征统计的约束（如预期平均值、完整性和范围）等技术可以标示出意外的数据质量问题，如传感器损坏和不完整的上游数据摄取。对于少量的特征和对问题领域的高度熟悉，宣布界限或预期可能是可行的，但这能否扩展到高维设置–例如，当数据科学家向xgboost模型投掷2000或更多的特征时？此外，在 “工程问题 “和 “漂移 “之间划清界限是很难的、特别是如果我们想自动检测问题。像TFX（Modi等人）这样的工具允许用户监测感兴趣的距离指标，如KL发散和Kolmogorov-Smirnov测试统计，但在视觉检查的L1距离很低的情况下，这些工具会失效–这可能发生在成千上万的数据点的规模上（Breck等人）。缓解这个问题的策略是假设拥有一个FAANG公司可能正在处理的数据点的数量（如果不是数十亿，也是数亿）。如果在FAANG公司之外，我们可以用什么技术来弥补经验漂移d(p̂, q̂)和理论漂移d(p, q)之间的差距，其中p和q是两个不同的分布？ 朝着重新训练模型的方向发展 在研究和实践界都存在一个巨大的问题，那就是 “分配转变 “是一个定义不明确的、负担过重的短语、造成全面的混乱。当人们说 “分布转移 “时，他们指的是一种现象，即一个数据集来自与另一个数据集不同的分布。”分布转移 “可能会导致ML性能下降–例如，在一个出租车公司供应商的数据上训练的模型在取自另一个出租车公司供应商的数据上可能表现不佳。这个重载的短语包含了不同类型的转变；例如： 概念转变：输入特征和目标输出（即标签）之间关系的变化。这方面的一个例子是华尔街的年终奖金导致乘客在一周内多给小费。 协变量转移：训练数据中输入变量分布的变化，而不是目标输出分布。这方面的一个例子是在新年前夕在中城（时代广场的落球）收到更多的出租车乘坐。 年龄转移：一个输入变量的分布随着时间的推移预期增加或减少。这方面的一个例子是出租车的总里程数，它只能随着时间的推移而增加。 在 “分布转变 “方面的很多研究和现有方法都集中在比较两组有限的数据。正如我在本系列文章前面提到的，在实践中，我们关心的是在无限的数据流上部署模型，或在可预见的未来的数据。难道我们应该任意地将生产数据切割成两个固定大小的数据集，以想知道是否有 “分布转移”？这似乎并不正确。在流式ML设置中，我们真正关心的问题是：在什么时候我的模型对我当前的数据不能像预期那样工作？(即我何时需要重新训练我的模型？)。 在现实中，SLI的下降是由不同类型的转变组合而成的，特别是在高度非平稳的环境中。从产品的角度考虑，告诉用户 “78%来自概念转变，22%来自协变量转变”，即使我们能精确地确定这种细分，其可操作性如何？我们希望告诉用户何时以及如何在部署后重新训练模型,鉴于当前数据窗口中出现的 “异常”。假设我们有标签或反馈Y和输入数据或特征X，其中Xi代表所有数据点中第i个特征的数据。按照颗粒度增加的顺序，异常情况的类型可以包括：： P(Y | X)有变化，但P(X)没有变化 P(Y | X)没有变化，但P(X)有变化 P(Xi)中的移位 P(Xi | Xj)中的移位，其中i ≠ j P(Xi | Xj , Xk , …)中的移位，其中i ≠ j ≠ k 在规模上跟踪许多距离度量。如前所述，为了接近上述的异常情况，现有的工作提出在连续的滑动窗口和训练集上跟踪KL分歧和Kolmogorov-Smirnov检验等指标（即Breck等人所述的训练-服务倾斜）。在内存中保留许多实时数据的窗口和训练集可能是不可行的，因此我们可以利用AQP技术来计算具有合理误差的距离指标。例如，度量计算功能可以在特征的直方图上运行，而不是在完整的数据流上运行；然而，直方图槽在流式设置中需要随着数据的演变而变化。研究的挑战在于将增量维护的近似直方图（Gibbons等人）的想法与自适应直方图（Leow等人）的想法相结合，以产生不断变化的数据窗口的总结。 识别距离度量中的静止性。通常情况下，模型在周末、工作时间以外或节假日表现不佳。一个有趣的想法是训练一个模型来识别滑动窗口中观察到的P（Y | X）和P（X）之间的距离是否存在季节性模式。追踪所有的特征组合是不切实际的（Heise等人），那么是否有可能利用预测寻找算法（如Wu等人）来简化追踪距离指标的空间？ 自我调整的训练集。最后，根据检测到的异常类型，我们可以建议增加或改变训练集的方法。例如，在P(X)发生变化但P(Y | X)不变的情况下，我们可以建议对代表性不足的子群体进行增加采样。在P(Y | X)变化但P(X)不变的情况下，也许用户可以在最近的数据窗口上重新训练他们的模型。研究的挑战在于具体的、有用的提示，以构建新的训练数据集来避免低性能的陷阱。 可视化 目前的ML监控仪表盘信息量过大.用户看到数以百计，甚至数以千计的柱状图和图表，试图将 “分布转移 “可视化。这些图表没有可操作性，特别是当人们可以用同一组图表来讲述两个相互矛盾的故事时。例如，一个用户可以说，一个模型需要重新训练，因为一个特征的平均值在过去的几天里急剧下降了。另一方面，用户可以说这个特征不是三个最重要的特征之一，所以重新训练模型不会有很大影响。因此，从界面的角度来看，在给定数百个图形的情况下，在何时重新训练一个模型上划线是一个任意的过程。我们如何想出更好的可视化工具？ 仪表盘的目标。监测可视化的目的是帮助用户与他们的数据和模型保持同步。为此，好的监测仪表板应该毫不含糊地回答具体问题，如：： 实时ML的性能是什么？ 这个性能是比预期的高还是低？比要求的（即满足SLOs）？ 性能降低的原因是数据质量问题吗？ 模型应该被重新训练吗？ 仪表盘应该只包含少数几个描述 “统治它们的单一指标”（即SLI）的图，这样用户就不会被淹没了。 仪表盘的挑战。在两个以上的维度上实现指标的可视化是非常困难的。不幸的是，在涉及到ML指标时，我们至少有以下几个维度： 度量值 组件（即管道中跨组件的连接，见本系列第二篇文章中的单组件与跨组件的讨论）。 状态（即输入和输出的历史值） 子种群（包括特征群） 时间（一般意义上的时间，例如，绘制过去6个月内100天窗口的滚动平均值） 我们如何开发出能明确传达所有这些维度的信息而又没有太多认知开销的可视化产品？ 争取实现有洞察力的可视化。与前文所述的细粒度监测信息相结合，一个好的仪表盘将有深刻的可视化，让用户对分布如何变化有直观感受。ML工程师使用的现有的 “最先进的 “可视化（通过口口相传确定，所以要慎重对待8）包括比较两个数据集的静态条形图直方图。这在流式ML环境中很难推理。什么新的可视化类型可以解释细粒度指标的变化？这里有一个高尖预测的 “动态 “小提琴图的例子，显示了输出的分布如何随时间变化： 图2：产出随时间的分布。 在上面的例子中，由于我们有充分的反馈（即所有的预测都有标签），SLI（准确性）有确认的下降。在我们需要近似SLI和假设推理细粒度指标的情况下，也许用户可以直观地看到这样一个可视化的季节性。这绝对不是万能的解决方案，但要回到主要的问题：研究的挑战在于如何以有原则的方式提出更好的可视化来理解数据漂移，并根据用户工作的数据和ML任务自动将其呈现给用户。 数据集和基准 由于缺乏对 “真实世界 “流式ML任务的访问，许多研究人员和开发人员主要用玩具数据或合成分布转移来工作。为此，有几个问题围绕着数据集和基准来加速ML监测的进展： 一个实时数据流的存储库，对应于可操作的ML任务。一个好的数据流的属性包括：它是无限的，代表了一个真实世界的现象，并且有一个比预测天气或股票价格更容易解决的ML任务。一个影响特别大的问题可能是以太坊天然气价格预测。具体来说，一个模型能否以95%的置信度输出未来一小时内一笔交易所需的最低天然气价格？另一个选择是将现有的基准转换为流格式（例如，从WILDS的训练和测试分布（D和D’）中取样点xt，用一个函数，当时间戳t小时，xt∈D的概率很高，当t大时，xt∈D’的概率很高）。理想情况下，我们收集更多的 “时间演化的表格数据流”，因为这种类型的数据在研究界大量存在。 以直观的方式从资源库中查询数据的接口,大多数数据科学家并不使用流式系统，那么我们如何让他们进行范围查询并接收Pandas或PyTorch数据集？我们如何保障用户在试验新想法时不被标签泄露或意外地偷看到未来？ 用于创建和评估训练模型的策略的接口（我敢说是DSL？)mltrace的愿景是成为一个类似于React的库，用户在其中定义管道的组件，并在每个组件运行之前和之后运行触发器。在这些触发器中，用户可以根据自己的标准决定重新训练模型–比如数据漂移指标或预定更新。 总结 有了关于一个ML任务的足够的上下文，就有可能解决该任务特有的数据管理问题。但在构建一个通用的监控工具时，还有其他一些挑战，这些挑战源于ML管道和系统复杂性的增加，包括： 壮大的数据科学团队和工具栈。软件工程表明，团队和工具栈的分散性使其很难保持系统的可持续性。这将适用于ML，特别是当可能的ML数据管理工具的数量每年大量增加时。调试一个别人训练的模型是一件很痛苦的事情。 模型堆叠。许多组织将模型连锁在一起以产生最终的预测。漂移检测对于一个模型来说已经很困难了。将错误的预测追溯到需要调试的特定模型上，似乎更具挑战性。 无法解释的特征。许多组织使用ML来产生嵌入，并将其作为特征输入到下游的ML任务中。数据质量警报，如用户定义的特征列的约束，然后无法构建。 将组件作为容器化应用进行部署。在Kubernetes集群中很难做ML。容器化基础设施主要适用于无状态的应用程序，不幸的是，在线和持续学习是有状态的（即模型权重被更新，需要在预测服务荚之间共享）。 多模态数据。我在这篇文章中概述的许多解决方案想法都是针对表格数据的。我们可以在图像、音频和视频案例中使用什么技术？我敢说，信息的 “数据湖”？ 我还没有太深入地思考这些临时性的挑战，但我怀疑一个好的ML监测工具至少会意识到这些挑战。最后，我想以个人名义结束这个系列。10我很感激有时间批判性地思考ML监控，以及行业专家和学术合作者的支持。我很幸运能读博士，我为自己能写出的论文感到兴奋! 感谢Divyahans Gupta和我的导师Aditya Parameswaran的头脑风暴帮助和对许多草案的反馈。 声明 通常情况下，我谈论的是可观察性。监测是可观察性中的一个子问题，有最有趣的研究问题（在我看来）。 新的挑战出现在模型的堆叠上，或者将模型串联在一起，形成最终的预测结果。 不清楚 “粗粒度 “和 “细粒度 “是否是这里的最佳术语。DG建议采用 “外部 “与 “内部 “的衡量标准。如果您对此有任何想法，请告诉我！ 基于 timely-dataflow（基于Rust的差分数据流实现）。向Peter Schafhalter致敬，感谢他在这方面的快速工作。 我应该进一步阐述这些方法。 更不用说，确定哪些子组有较高的滞后时间，对调试工作有帮助。 这里不点名，但如果你有兴趣，请查看ML监控公司的演示。 我们RISELab的几个人正在进行一项采访研究，以正式撰写部署后ML维护的 “最佳实践”。 深度学习的危险性就属于这个范畴。 向那些能看完本系列所有4篇文章的人表示敬意。我是认真的。我很确定我还没有读完这里的所有字。","categories":[{"name":"技能-修行-进步-MLOps","slug":"技能-修行-进步-MLOps","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-MLOps/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"MLOps","slug":"MLOps","permalink":"http://example.com/tags/MLOps/"}]},{"title":"现代机器学习监控的混乱局面：重新思考流媒体评估（3/4）","slug":"现代机器学习监控的混乱局面/model_monitoring_mess_part03","date":"2023-05-24T11:12:16.000Z","updated":"2023-07-22T01:34:53.288Z","comments":true,"path":"2023/05/24/现代机器学习监控的混乱局面/model_monitoring_mess_part03/","link":"","permalink":"http://example.com/2023/05/24/%E7%8E%B0%E4%BB%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%91%E6%8E%A7%E7%9A%84%E6%B7%B7%E4%B9%B1%E5%B1%80%E9%9D%A2/model_monitoring_mess_part03/","excerpt":"","text":"作者：Shreya Shankar 原文连接：rethinking ml monitoring 3 在上一篇文章中，我调查了现有的部署后问题，并将它们分为两个轴：状态和组件。我提到，监控跨组件的状态指标，如模型的准确性，对于维护ML管道至关重要，但在现有的工具中却很困难。在这篇文章中，我们将亲身体验这些困难：我们将用Prometheus（一种流行的软件监控工具）扩展一个玩具ML管道，以提供ML监控。在这个过程中，我们将看到Prometheus的许多不足之处，从代码混乱到算法的低效率 背景介绍 有一天在工作中，当我在Slack频道中浏览AWS警报的时候，我突然意识到我的infra同事和我对 “标签 “一词的解释非常不同。他指的是一个标识符。我是指预测的真实值。我们只是在一个大项目进行了几个月后才发现我们是错位的。值得庆幸的是，我们从未在同一个任务上合作过，所以对我们没有任何影响。但我想知道这种错位是否会在其他组织中造成问题。 我认为关于ML监测的讨论中最令人困惑的方面是术语。像 “度量 “和 “标签 “这样的术语是超载的。在这篇文章中，我将利用以下定义： 指标：一个汇总数据的函数，以评估管道的性能如何（例如，平均值、准确度）。 普罗米修斯公制：数字测量的时间序列 标识符：分配给一个对象或对象集合的唯一名称 预测：由一个ML模型做出的输出 反馈：预测的 “真实 “值 服务水平指标（SLI）：一个汇总预测和反馈的函数，以评估管道的性能如何（例如，准确性） ML任务，数据源，和管道 在这个练习中，我使用纽约市出租车联盟的数据构建了一个ML管道来预测出租车乘客是否会给司机高额小费（二元分类）。使用Prometheus，我们将监测累积的准确性，或者说自部署以来所有预测的准确性。训练和推理管道在架构上共享一些组件，看起来像这样： 图1：ML管道架构。 由于这是一个二元分类问题，推理组件产生0和1之间的浮动值预测，而反馈组件返回0或1的值。我把我的管道和实验代码寄存在这个资源库中，结构如下： 我在2020年1月的数据上运行训练管道，模拟2020年2月1日开始的部署。我没有进行任何再训练，主要是因为这个练习的目的是展示Prometheus的故障模式，而不是调试由 “数据漂移 “导致的低SLI。 Prometheus入门 普罗米修斯(Prometheus)是一个开源的软件监控工具： 收集和存储指标，如响应延迟 允许用户通过一种名为PromQL的查询语言查询公制值的集合（例如平均延迟）。 普罗米修斯支持四种类型的度量值： 计数器：一个单调增长的累积度量。例如，可用于跟踪预测服务的数量。 仪表：一个代表单一数值的度量，可以任意改变。例如，可以用来跟踪当前的内存使用情况。 直方图：一个将观察到的数值归类到用户预先定义的桶中的度量衡。这有很高的服务器端成本，因为服务器在查询时要计算量值。 摘要：在一个滑动的时间窗口中跟踪用户预先定义的量化指标。这具有较低的服务器端成本，因为量值是在登录时配置和跟踪的。另外，摘要指标一般不支持查询中的聚合。 通常情况下，企业的DevOps或SRE人员使用Prometheus来监控软件SLO。用户用他们的应用程序代码来记录Metric值。这些值被刮取并存储在Prometheus服务器中。这些值可以使用PromQL进行查询，并导出到Grafana等可视化工具中。该架构看起来像这样： 图2：普罗米修斯架构。 Ivan Velichko的这一系列教育性的帖子很好地解释了普罗米修斯。我将总结他的一些关键点： 普罗米修斯不是一个时间序列数据库（TSDB）。它只是利用了一个TSDB。 由于普罗米修斯定期刮取数值，如果度量值的变化比刮取间隔更频繁，一些度量类型（如仪表）会失去精度。这个问题不适用于单调增长的度量（如计数器）。 Metrics可以用任意的标识符来记录，这样在查询时，用户可以通过标识符的值来过滤Metrics。 PromQL很灵活–用户可以在不同的窗口大小上计算许多不同的度量值聚集，这些参数可以在查询时指定。 Velichko承认，PromQL在实际软件应用中的使用 “远非微不足道”（也就是说，令人讨厌）。然而，在学习了矢量匹配和其他语法之后，我认为它并不太糟糕–特别是当我们不需要加入Metrics的时候。PromQL查询通常不会太长，而且在查询时有许多辅助函数可以使用。但我们会看到它对ML监控的情况有多糟糕。 Prometheus 🤝 ML 以下问题将有助于评估Prometheus是否是一个合适的ML监控解决方案： 我们可以使用Prometheus Metrics来跟踪我们的ML管道中的任何ML指标吗？将 “ML度量 “映射到Prometheus Metric类型并不直接。对于单一组件的有状态指标，也许我们想使用直方图或汇总指标。如果我们对跨组件的有状态度量感兴趣，我们需要考虑如何将不同组件的度量 “连接 “起来，以计算ML SLI，如准确度和精确度。 用PromQL编写ML SLI有多难？ ML SLI的查询延时是多少？ 管线仪表跨组件的有状态度量 普罗米修斯的指标类型（计数器、测量仪、直方图或摘要）没有一个明显地映射到我们想要测量的SLI：累积精度。相反，我们将使用2个Gauge Metric3–一个用于管道预测，一个用于反馈–并在PromQL中聚合它们来计算准确性。在mext&#x2F;prometheus_ml_ext.py中，我定义了一个BinaryClassificationMetric类，其中包含Gauge Metrics以及logOutputs和logFeedbacks方法，以便在每次推理调用后更新它们。对应用程序进行仪表化是非常直接的。下面是inference&#x2F;main.py中的Prometheus专用代码： 将累积的准确度表现为两个Gauge Metrics并不完全是直接的，但我仍将这种经验评为简单。 单一成分的有状态度量 ML监控解决方案经常监控输入和输出的聚集，如中位数和p90，以粗略地测量 “数据漂移”。有时，他们还计算更复杂的统计测试（如Kolmogorov-Smirnov测试），我肯定永远无法用PromQL来写。这些方法既不健全也不完整，但为了这个练习的目的，我们可以用直方图度量来跟踪输出值的各种百分位数。下面是inference&#x2F;main.py中的相关仪表代码： 这种整合比跨组件的情况更容易，但一个主要的缺点是，我们需要提前定义我们的直方图桶。这有两个原因：（1）我们常常不知道输出的分布是什么样子的，（2）分布可能随着数据的 “漂移 “而改变。 用于ML SLI的PromQL 现在我们已经检测了我们的管道，我们可以通过Docker-Compose启动我们的容器，开始使用PromQL刮取记录的Metric值并提取我们的ML指标。使用PromQL结构和一个很大的白板，我想出了以下查询： 在ML SLI中使用PromQL有几个问题： 不正确性。当我第一次运行查询的准确性时，我很惊讶，结果并不完全准确（哈哈）。这是因为我的搜刮间隔是15秒，这对于我产生新预测的速度来说太大了。把搜刮间隔缩短到5秒，提高了查询的精确性，但使Prometheus容器的速度变慢，消耗更多的内存和计算资源。 滑动窗口的挑战。即使在几个小时后，我也无法弄清楚如何在固定的窗口大小上计算前3个指标中的任何一个（交叉成分）。我没有发现关于在滑动窗口上计算PromQL中的连接的资源。我不太擅长使用Prometheus，所以请让我知道是否有可能通过窗口计算这些指标。 复杂的查询。表中的最后3个指标（单成分）并不像前3个（跨成分）那样错综复杂。我不会期望任何数据科学家编写这些跨组件的PromQL查询，特别是对于那些简单地调用scikit-learn模块的函数。一个理想的监测工具应该允许用户将自定义的Python函数作为指标传入，并在后端有效地产生这些指标的值。 查询延时 在本小节中，我将重点讨论延迟问题，特别是跨组件查询的延迟。为了计算类似SLI的准确性，如上一小节所示，我们需要对output_id做一个连接。这是对Prometheus的严重滥用，因为output_id的cardinality显然会随着ML管道的预测数量而增长。Prometheus并不是为了处理高卡数的标识符，更不用说高卡数的连接了。 为了证明Prometheus的扩展性有多差，我设计了一个小型的Postgres后端，将预测和反馈放在以时间戳为索引的表中。我计算了PromQL和PostgreSQL的准确度，并测量了与管道产生的预测数量有关的延时： 图3：ML查询的延迟。 由于Prometheus度量值不是急于计算的（也就是说，当用户想在Grafana上查询或绘制一段时间的度量值时，它们都会被计算出来）、这种延迟是不可接受的，而且不能扩展。 随着更多预测的产生，许多想要跟踪实时ML SLI的组织可能无法足够快地更新或刷新他们的SLI。也许在某些领域，每天甚至每小时计算一次SLI可能就足够了，但对于数据和用户偏好经常变化的领域来说，这就不适用了。我知道我在使用Prometheus的情况下，它并不是为之设计的，但总的来说，这些问题共同突出了企业的需要：（1）有一个ML监控团队，在Postgres或现有的DBMS之上创建一个层，或者（2）利用一个专门用于ML监控的专有供应商。我相信，现在、我们需要更好的ML监测实践和工具。 回顾总结 在这篇文章中，我强调了使用Prometheus进行ML监控的一些主要隐患，最明显的是： 需要使用多个普罗米修斯公制类型进行跨组件监测 需要提前定义直方图桶以进行单组件监控 查询结果的正确性取决于搜刮时间间隔 无法处理滑动窗口 看起来很恶心的PromQL查询 跨组件指标的高延迟（即高cardinality连接）。 在这个系列的下一篇也是最后一篇文章中，我将讨论建立一个通用的ML监控工具的一些关键要求和想法。我非常高兴能与大家分享，同时还有一个监测实时ML SLI的原型。更多的内容将陆续推出，新年快乐! 感谢Divyahans Gupta, Preetum Nakkiran, 和Peter Schafhalter对许多草案的反馈。 声明 这个帖子是针对ML工程师和信息员的。我建议对数据库（如表、连接、索引）、ML SLI（如准确性、精确性、召回率）和查询语言（如SQL、PromQL）有基本认识。 我用大写的Metric来指代Prometheus Metric的抽象概念。 我为预测和反馈选择了Gauge Metric，因为它们表示可以上升或下降的数值。由于反馈和推理组件在ML管道中通常是相互分离的，所以真的没有办法（我能想到的）避免连接。 如果这些查询是错误的，我也不会感到惊讶。如果有错误，请纠正我。 也许这不是一个失败的模式–我只是想不通。如果我错了，请让我知道!","categories":[{"name":"技能-修行-进步-MLOps","slug":"技能-修行-进步-MLOps","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-MLOps/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"MLOps","slug":"MLOps","permalink":"http://example.com/tags/MLOps/"}]},{"title":"现代机器学习监控的混乱局面：重新思考流媒体评估（2/4）","slug":"现代机器学习监控的混乱局面/model_monitoring_mess_part02","date":"2023-05-24T10:19:16.000Z","updated":"2023-07-22T01:34:48.784Z","comments":true,"path":"2023/05/24/现代机器学习监控的混乱局面/model_monitoring_mess_part02/","link":"","permalink":"http://example.com/2023/05/24/%E7%8E%B0%E4%BB%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%91%E6%8E%A7%E7%9A%84%E6%B7%B7%E4%B9%B1%E5%B1%80%E9%9D%A2/model_monitoring_mess_part02/","excerpt":"","text":"作者：Shreya Shankar 原文连接：rethinking ml monitoring 2 在《现代ML监控乱象》系列的最后一篇文章中，我讨论了现有流式ML指标失败的一些方式。在这篇文章中，我从 “以数据为中心 “的角度过渡到软件工程的角度：我调查了现有的部署后问题，并将其分类，以激励更好的开源ML监控工具。 作为ML从业者，我们如何分配我们的时间？ 最近，Zillow因其最新的ML灾难而在社交媒体上引起热议。一些人声称他们的ML购房和售房项目因低质量的预测而关闭。另一些人则认为，关闭的原因是没有关于如何对预测采取行动的组织程序–员工手动推翻了预测，以满足他们自己的配额。谁知道问题是什么，但我认为Zillow的新闻变得非常流行的一个重要原因是我们所做的许多ML应用在生产中都是不稳定的。 我们不知道他们是否或何时会失败。我们不知道，在组织上，如何对模型输出采取行动。而且我们肯定不知道当我们怀疑ML管道或管理方面出现一些故障时该怎么做。 为了剖析如何改善应用ML的令人苦恼的状态，我认为了解ML从业者目前如何分配他们的时间很重要。经过广泛的搜索，我在一篇关于87%的机器学习项目失败的文章中发现了一个相当准确的细分（在我看来），即行业ML项目是如何分配时间的： 图1：分解ML项目时间分配的图表，取自iiot-world。 图1显然解释了为什么数据标签初创公司目前在MLOps市场上获胜，但我更感兴趣的是，随着越来越少的ML项目失败，细分市场将如何变化。就像在软件方面一样，我怀疑在未来5年内，图表中的大部分大众都会在运营化方面。我们如何从数据化中去除质量，并将更多的质量放在监测上？ 构建一个ML管道 上图所示的分类对于失败的ML项目来说感觉很准确。在我以前的ML工作的任期结束时，我们最终遵循这个过程来建立新的成功的ML管道： 想出针对ML的服务水平目标（SLO），比如在每月的窗口中90%的召回率 🪟 编写为占位的ML管道输出计算SLO的函数（例如，基线预测概率） 🪠 编写确认校准输出的函数 ⚖️ 编写管道的所有组件或阶段，除了模型训练&#x2F;评估之外 🔧 进行仔细的探索性数据分析，编写清理数据、选择特征等的管道组件 📊 将上述所有内容生产化 🚧 训练&#x2F;评估逻辑回归模型或决策树 🌲 逐步改善模型 📈 这里的关键是，在管道的一些骨干部分投入生产之前，我们没有做任何建模工作、消除了花在数据预处理上的时间，这可能是特定的训练&#x2F;测试分割。然而，在我上面描述的范式中，我们在管道中的数据处理组件中仍然有bug（我认为这是不可避免的）。当采用这种模式时，我注意到我的大部分开发人员的时间从 “研发 “建模工作转移到监控生产ML服务。 几个月来，我一直记录着我个人在监控时面临的部署后问题。缺少数据导致空值键的连接，子组表示法随时间变化，将错误的模型推广到生产中，上游依赖关系（如嵌入）变化，Spark节点故障……这个清单似乎没有尽头。每当我面临一个新问题时，我都试图设计一个警报，以防止未来出现这种故障模式。随后，管道代码逐渐变得不可持续，而我在生产中仍然面临着许多新的挑战–促使我思考更清洁的部署后问题的分解。 部署后问题的分类 假设一个团队为一项任务定义了一个具体的ML SLO，比如在每月的窗口中90%的召回。重新表述我关于部署后问题的问题–这些SLO没有达到的原因有哪些？我喜欢Neptune.ai博客文章中的这个表格： 生产挑战 关键问题 1 数据分布变化 为什么我的特征值会有突然的变化？ 2 生产中的模型所有权 谁拥有生产中的模型？DevOps团队？工程师？数据科学家？ 3 训练-部署不一致 尽管我们在开发过程中进行了严格的测试和验证尝试，但为什么该模型在生产中给出的结果不佳？ 4 模型&#x2F;概念漂移 为什么我的模型在生产中表现良好，而随着时间的推移，性能突然下降？ 5 黑匣子模型 我如何根据商业目标并向相关的利益相关者解释和说明我的模型的预测？ 6 一致的对手 我怎样才能确保我的模型的安全？我的模型被攻击了吗？ 7 模型准备情况 我如何将我的模型的较新版本的结果与正在生产的版本进行比较？ 8 管道健康问题 为什么我的训练管道在执行时失败？为什么再培训工作需要这么长时间才能运行？ 9 表现不佳的系统 为什么我的预测服务的延迟非常高？为什么我的不同模型的延迟有很大的不同？ 10 极端事件的案例（异常值） 我将如何在极端和非计划的情况下跟踪我的模型的效果和性能？ 11 数据质量问题 我怎样才能确保生产数据的处理方式与训练数据的处理方式相同？ 图2：部署后问题表，取自Neptune.ai。 说实话，很多博客文章读起来就像洗衣清单。作为一个懒人，我绝不会在每个拉动请求上手动检查每个清单项目。我们如何使这些挑战更容易推理，以便我们能够建立一个监测工具？ 戴上我的软件工程帽子，我发现将这些生产挑战（以及其他挑战）提炼成四种类型的问题是很有帮助的，这些问题沿着两个轴线（状态和组件）分组： 图3：将少数部署后的问题按状态和组件轴进行分类。 让我定义一下 “状态 “和 “组件”，以便图3真正有意义。很多时候，只有当你将数据点与历史上的一组数据点进行比较时，你才知道ML系统中存在一个错误。例如，也许代表传感器数据的表格中的一列主要是空值。是传感器刚刚坏了，还是它一直都在坏？为了回答这样的问题，你需要跟踪历史数据，或状态。此外，你可能需要来自多个不同组件的信息来诊断一个ML系统的故障模式。例如，假设模型训练的数据和模型推断预测的实时数据之间存在差异。显然，一个调试器应该关心ML管道的训练和推理部分。我把这种错误定义为跨组件的错误。 对我来说，理解这些轴线，就可以知道为什么ML监控从根本上说比传统的软件监控更难，也更有区别。软件SLI完全属于单组件区域，如平均响应延迟。最复杂的软件SLI是有状态的和单组件的，促使了像Prometheus这样的工具。但最基本的ML SLI，如准确度，是有状态的和跨组件的–最难处理的桶。 一旦你能够有效地监控这种有状态的跨组件指标（如实时准确性），以确定何时有bug，了解有状态的单组件指标，如第90个百分点的特征值，是很有用的，因为你就可以确定bug在你的管道中的位置。 通过状态-组件视角查看现有的工具 我个人对一个完全开源的监控解决方案很感兴趣，它可以有效地、快速地、以一种需要用户付出最小努力的方式来跟踪可能属于这4组中任何一组的指标。现有的工具能做到这一点吗？从我的研究中，我发现开源监控工具只涉及4个组的一个子集。我在头脑中把现有的工具分为以下几个 “层次”： 缠绕着的报告 scipy.your_favorite_statistical_test(finite_sample_from_dist_A_that_you_define, finite_sample_from_dist_B_that_you_define) —用户被迫跟踪状态和组件。在这里，用户需要解决数据管理问题，即为他们关心的每个组件存储历史输入和输出，编写作业来反复对感兴趣的数据进行子采样并创建这些报告，并在这个过程中组织所有工件。 工作流协调工具（如Airflow、Argo、Kubeflow）–用户被迫跟踪状态。在这里，仪表盘会向你显示单个管道运行中不同任务或组件的详细结果。但用户无法真正访问当前运行中的历史运行值。 Postgres数据库持有单个组件的历史输入和输出，以及一个显示np.some_aggregation(dist_A)随时间变化的仪表板–用户被迫跟踪组件。在这里，用户需要知道要监控哪些组件，手动连接组件的输入和输出以进行任何自定义的聚合（例如，F1分数），并定义他们自己的标准，即如何以及何时对仪表盘的结果采取行动。例如，如果一个特征的平均值变化了10%，用户会怎么做？ 专有的供应商，鉴于对你的数据和模型的访问，为你监控一切。不知道这些公司是做什么的，所以我不作评论。 回顾总结 在这篇文章中，我讨论了如何通过两个简单的轴对部署后问题进行分类：状态和组件。我不想讨论如何监测我在图3中描述的每个问题，但回到我在本期第一篇文章中提出的一个问题–要如何扩展现有工具以支持有状态的组件和跨组件的情况？是否有可能轻松地扩展它们？在下一篇文章中，我将探讨如何调整Prometheus以监测ML，并研究它的缺陷所在。 感谢Laszlo Sragner对早期草案的反馈。 声明 我喜欢数据科学博客文章中点击率高的标题。🙃 这并不是要挖苦博文作者；而是要说明生产ML问题的广泛性。 这并不明显，为什么像准确性这样的实时指标的近似是一个有状态的和跨组件的程序。这是有状态的，因为你需要一组历史预测和标签来计算这个指标。这是跨组件的，因为在许多情况下，提供预测的组件与收集反馈（标签）的组件不同。","categories":[{"name":"技能-修行-进步-MLOps","slug":"技能-修行-进步-MLOps","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-MLOps/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"MLOps","slug":"MLOps","permalink":"http://example.com/tags/MLOps/"}]},{"title":"现代机器学习监控的混乱局面：重新思考流媒体评估（1/4）","slug":"现代机器学习监控的混乱局面/model_monitoring_mess_part01","date":"2023-05-24T09:01:16.000Z","updated":"2023-07-22T01:34:40.592Z","comments":true,"path":"2023/05/24/现代机器学习监控的混乱局面/model_monitoring_mess_part01/","link":"","permalink":"http://example.com/2023/05/24/%E7%8E%B0%E4%BB%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%91%E6%8E%A7%E7%9A%84%E6%B7%B7%E4%B9%B1%E5%B1%80%E9%9D%A2/model_monitoring_mess_part01/","excerpt":"","text":"作者：Shreya Shankar 原文连接：rethinking ml monitoring 1 我对MLOps感兴趣的部分原因是有太多的工具，而且我无法相信一些受人尊敬的软件老手和学者正在向左、向右、向中间推出新的创业公司。在我之前的公司，使用现有的DevOps工具来简化ML的部署和生产，让我走得很远–但还不够远，促使我思考MLOps问题的定制解决方案，比如ML监控。 我喜欢当博士生，因为我可以思考问题，而没有人嚷嚷着要我建立什么。事实是，当涉及到监测ML时，我不知道到底应该建立什么。ML监控的现状是，不加掩饰，一团糟。在这个由四篇文章组成的文集中，我说明了我对获得一个好的开源ML监控解决方案的想法，其大纲如下： 重新思考流媒体机器学习的评估(本篇) 对部署后的各种问题进行分类 调查现有的DevOps工具（如Prometheus）在机器学习监控方面的不足之处 建立一个通用的机器学习监测解决方案的具体研究挑战 重新思考流媒体ML的评估 在我讨论什么是监控之前，我将把监控定义为：跟踪指标以确定应用程序何时失败。有很多文章都在说服你，监控对于机器学习应用是必要的。下面是我对为什么我们需要监控的两点看法： 生产中的应用程序将不可避免地遇到问题。我们希望尽早发现并解决这些问题，以尽量减少停机时间。 机器学习越来越多地被部署在高风险的场景中（例如，累犯、贷款、信用卡欺诈、招聘、自动驾驶汽车），其中的监管是不可避免的。 许多文章还讨论了在生产型ML系统中会出现哪些类型的错误，促使人们去监测什么。我个人对所有可能发生的bug以及必须执行和监控的大量测试和指标清单感到不知所措，以确保管道的 “良好 “健康。在我以前的工作中，我曾经有过一次生存危机，因为我不知道为什么要监控成千上万的东西；我只是认为这是管道 “不失败 “的必要条件。但 “失败 “是什么意思，特别是在ML背景下？ 为什么造成这样的局面？ 机器学习领域有一个有趣的评估历史。针对ML的指标被设计用来评估一个特定模型在特定数据集上的表现。为了在 “学术 “环境中评估一个模型，几十年来，我们一直在测量固定的指标，如准确率、精确率和召回率，这些指标是我们的模型在训练期间没有看到的 “验证 “集。为了评估一个模型是否能推广到新的数据，机器学习入门课程强调了检查过拟合的重要性（即验证集指标应该接近训练集指标）。这真的是我们宣称可推广性所需要的全部吗？ 在今天这个基准的黄金时代，我们并没有真正质疑这种在一些静态或固定的数据集上计算指标的评估程序（有一些例外）。最近，我的朋友Deb和其他ML领导人一直在提高人们对当前通用的ML评估方法在评估ML系统中与关键子群体（如种族）和外部性（如能源消耗）相关的失败模式方面的认识。我提到这项工作是因为我认为它非常重要，尽管与我在这里要谈的内容正交。 我们很清楚，在实践中，虽然所有的模型都是错误的，但有些模型是有用的。在 “行业 “背景下的ML评估，毫不奇怪，可以追溯到50年代和60年代的军事背景下。ROC曲线是在第二次世界大战期间发明的，用于对战场上的敌方物体进行分类，我想主要是因为从业者需要计算有用的模型，并随着时间的推移抛弃无用的模型。我喜欢把ROC曲线和PR曲线看作是更好的指标 “聚合”，它有助于告知模型输出的哪个阈值，以及这种阈值如何随时间变化。当在实践中（例如医疗）长期部署ML时，这种聚合显然是必要的。 因为在实践中，我们与数据流打交道，而不是固定的数据集，ML监测的行业标准（可能是软件监测的结果）遵循这些步骤： 选择他们认为代表模型性能的指标和阈值 选择一个滑动窗口大小（单位是基于时间的，如天或周）来计算指标。 当指标值下降到阈值以下时，设置警报。 警报后，手动或自动触发重新训练 这个过程假设故障被定义为指标值下降到其阈值以下。为什么我们需要把这个定义弄正确呢？在你不需要的时候触发重新训练的影响可能是不好的：它可能会浪费计算，或者如果最近的窗口不能代表未来的数据，它实际上可能会降低性能。在需要的时候不触发重新训练的影响是，你的性能将继续恶化–甚至可能无声无息。因此，我们希望我们的警报是健全的（即，没有错误的警报）和完整的（即，每次出现故障时都触发）。不幸的是，我总是得到太多或者太少的警报，促使我质疑–我们的评估程序有什么问题？ 我们目前的做法有什么问题？ 现在我将论证为什么这种在数据流上评估ML的程序被打破了。假设我们有一个从时间t&#x3D;0开始的数据流。我们在t&#x3D;0和t&#x3D;i之间的数据上训练和验证一个模型。我们在t&#x3D;i处 “部署”，并连续计算跨越d天的滚动窗口的ML指标。 有一些自然和常见的现象会被计入公制计算中： 代表性差异。各个窗口的类比可能不一样（例如，一个窗口的阳性比例可能与另一个窗口的阳性比例有很大不同）。 不同的样本大小。每个窗口中的数据点数量可能不同（例如，周日收到的请求数量少于周一收到的请求数量）。 延迟的反馈。由于合理的事件（如失去互联网连接），标签可能会滞后出现，使得没有标签的预测不可能被纳入当前窗口的评估指标。 在每一种情况下，即使你测量auROC和auPRC这样的聚合，指标值也会发生剧烈变化–而模型与预期任务的 “一致性”（即预测能力）或 “概念漂移 “没有任何变化。当我们触发重新训练时，我们隐含地相信我们的模型不具有我们预期的预测能力。如果我们的滚动窗口与我们的保留验证集的假设不一致（例如，我们的滚动窗口跨度为一周，而我们的验证集跨度为一个月），我们怎么能对这个信念有信心？大多数时候，我们并没有明确意识到在训练时所作的所有假设。我认为在一个滚动窗口上评估的ML特定指标告诉你的是模型的一致性，而不是该窗口中数据的属性。 因此，由于我们不知道如何评价模型与预期任务的一致性，对数据流的评价在不同的组织中是不同的。我们不知道在哪里为可接受的业务绩效划线，所以我们看所有可辩护的指标（例如auROC），并试图为它们的一些聚合进行优化。虽然我们没有更好的选择（据我所知），但这显然是破绽百出的，并使ML在如此多的产品设置中变得毫无用处。许多行业的ML资深人士谈到，我们需要从ML指标到商业结果的清晰明确的映射–成熟的组织有一个ML模型的 “SLO “概念，其中BizDev和数据人员合作，以确定单一任务（SLO）的指标集合、窗口大小和警报程序。当SLO与任务不一致时，你不知道一个指标的下降是否应该触发一个重新训练！这种合作来计算SLO参数！这种计算SLO参数的合作迫使人们定义如何对模型输出采取行动。疯狂的是，可能需要几个月甚至一年的时间来确定正确的参数来计算SLO。更重要的是，与我的兴趣更相关的是—这样一个针对特定环境的ML SLO选择程序与建立一个通用工具来监控ML管道是不一致的。 回顾总结 因此，在我所概述的流媒体ML评估中确实有两个不同的问题： 要使目前的 “行业标准 “评估程序（选择指标、阈值和窗口大小）发挥作用需要时间和许多资源 这个程序可能永远不会成功，这取决于数据的性质，而且通用性很差（即，需要同样多的时间和资源来解决新任务的评估协议或SLO）–使得ML在生产中真的很难实现 我猜想，与ML相关的敏捷宣言的延伸以及围绕ML的优点和缺点的更好的教育可以解决第一个问题。第二个问题对我来说似乎更难解决–作为一个ML信息员，我对规定具体的SLO不感兴趣；我感兴趣的是建立基础设施，让任何人都能轻松监控他们关心的ML SLO。 我希望我们的ML社区能更深入地思考如何普遍评估将在数据流上运行的模型的一致性或预测能力。 也许我们不能比我们已经有的程序做得更好，但我很好奇–我们能不能建立技术来理解ML结果的特定数据的时间性，并使用这些信息来为我们选择SLO？我们能不能建立更多的一般性指标，明确地与业务成果挂钩，如 “ML Apdex Score”？这些一般的指标能否对我上面概述的所有三种现象–代表性差异、不同的样本量和延迟反馈–保持稳健？我不知道这最终会是什么样子，但我相当有信心，能够阐明和衡量正确的SLO将为从生产性ML应用中获得价值提供巨大的突破。我很高兴我们能取得进展。 感谢Alex Tamkin、Rolando Garcia和Peter Schafhalter对许多草案的反馈。 声明 没有任何MLOps公司付钱给我写这个。我无法对隐藏在付费墙之外的解决方案发表明智的看法，所以我对现有的专有工具不做任何声明。另外，我认为完全开源的ML监控解决方案是有市场的。 对我来说，最有用的MLOps资源来自博客文章、Slack频道和口碑，这很疯狂。这个领域完全处于起步阶段。","categories":[{"name":"技能-修行-进步-MLOps","slug":"技能-修行-进步-MLOps","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-MLOps/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"MLOps","slug":"MLOps","permalink":"http://example.com/tags/MLOps/"}]},{"title":"何仁讀通鑑 观后感","slug":"认知-修行-平衡/何仁读通鉴","date":"2023-05-21T05:29:33.000Z","updated":"2023-07-16T01:38:21.691Z","comments":true,"path":"2023/05/21/认知-修行-平衡/何仁读通鉴/","link":"","permalink":"http://example.com/2023/05/21/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/%E4%BD%95%E4%BB%81%E8%AF%BB%E9%80%9A%E9%89%B4/","excerpt":"","text":"何仁讀通鑑-Youtube 第二集：三家分晋 蠢人-&gt;小人-&gt;君子-&gt;圣人 德才兼备谓之圣人，才德皆无谓之蠢人。 有德无才谓之君子，有才无德谓之小人。 第三集：商鞅变法 过程： 为鞅对秦孝公说： 变法开始的时候，普通大众是不会自动自觉与你一起规划的，但是等到有成果可以享受的时候，他们就会心服诚服了 立志实现至善大德之人不应该迎接草根阶层的想法，希望建立宏伟工业的人不能寄望于大众能够与你合作， 所以，只要能够使国家富强，圣人并不会一味固守旧法， 但是既得利益者就会反驳，因为他们要保住自己的利益能够维持下去， 为鞅答道：普通人因循守旧，知识分子满足于道听途说 ，他们只适宜于规规矩矩地做官生活，你不能和他们讨论超出这个特定范围的事物， 聪明人要制定规矩，蠢人就会加以掣肘；有才能的人要改变现有的秩序，没出息的人就会来捣乱。 秦孝公表示十分认同！ 变法涵盖经济，社会，政制等多个方面 变革，制定规则并且严格执行，重奖，严罚，大众和权贵都要遵守规则，变法才能发挥作用 支持精英治国，支持专业性，精英政治，以结果为第一评估原则 没有为自己埋好退路 第四集：怀王弱智 贪，狂，怨，软 第五集：秦王逐客 既要用才，亦要防才。所谓疑人不用，用人不疑好像是一个极端的说法，中国人最终都要找到一个中庸之道，找到一个平衡之处。 一代君主一朝臣 第八集：南越归汉 真诚信件，趋利避害，不急一时的耐心 第九集：七国之乱 固本培元","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"从历史学习经验","slug":"从历史学习经验","permalink":"http://example.com/tags/%E4%BB%8E%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/"}]},{"title":"Mac上通过airas2无限速下载网盘文件","slug":"小而美-工具/mac-ariel","date":"2023-05-03T05:57:38.000Z","updated":"2023-07-16T01:32:13.287Z","comments":true,"path":"2023/05/03/小而美-工具/mac-ariel/","link":"","permalink":"http://example.com/2023/05/03/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/mac-ariel/","excerpt":"","text":"参考 度盘 使用浏览器：chrome，科学上网，安装插件Tampermonkey， 安装前前下载插件，地址https://greasyfork.org/zh-CN/scripts/463171-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%8D%83%E5%8D%83%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B mac上安装aria2 安装brew 通过brew安装aria2，brew install aria2 aira2.conf配置，附件 启动aira2后端程序 mac上安装ariaNg，地址https://github.com/mayswind/AriaNg-Native/releases 配置ariaRPC密码，连接成功 打开度盘网页页面，勾选单个你需要下载的文件，点击上方的千千下载插件按钮，进入获取下载链接页面，关注公共号，获取验证码，点击aira下载，并且输入你的token，就是上面设置的airaRCP密码，就可以高速下载了 雷盘 在greasyFork安装网盘下载助手，地址https://greasyfork.org/zh-CN/scripts/436446-%E7%BD%91%E7%9B%98%E7%9B%B4%E9%93%BE%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B 进入迅雷下载页面，勾选单个下载文件，点击上方的下载助手，选择RPC下载，填写你的配置端口和token后便可以成功下载","categories":[{"name":"小而美-工具","slug":"小而美-工具","permalink":"http://example.com/categories/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"下载工具","slug":"下载工具","permalink":"http://example.com/tags/%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/"}]},{"title":"什么是系统？","slug":"认知-修行-平衡/什么是系统","date":"2023-04-05T04:39:30.000Z","updated":"2024-02-23T03:40:51.336Z","comments":true,"path":"2023/04/05/认知-修行-平衡/什么是系统/","link":"","permalink":"http://example.com/2023/04/05/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"系统定义 系统是一个由若干相互作用相互依赖的元素组成的一个有特定功能的有机整体。 design for learning 百度百科 系统在生活中无处不在，一个班级，一个家庭，一个人等等，正所谓一叶一菩提，一花一世界. 人生来世，就像游戏打怪升级一样，面对林林种种的挑战，那么挑战如果是一个系统，该是怎么样的呢？ 挑战系统 有了挑战，自然就有解决方案，我们俗称how to archive&#x3D;this is your value，而这恰恰是你的价值所在，那sollution sytem又是怎么样的呢？ 解决方案系统 利用树状的思维结构，分成3个部分，简称pdp，（1）to prove&#x3D;root（2）to define&#x3D;trunk（3）to practice&#x3D;leaves","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"系统, 方法论","slug":"系统-方法论","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F-%E6%96%B9%E6%B3%95%E8%AE%BA/"}]},{"title":"常霖法師講-學佛修行信願行","slug":"认知-修行-平衡/buddism","date":"2023-03-18T03:58:38.000Z","updated":"2023-07-16T01:27:38.842Z","comments":true,"path":"2023/03/18/认知-修行-平衡/buddism/","link":"","permalink":"http://example.com/2023/03/18/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/buddism/","excerpt":"","text":"一、信：眾生皆可成佛，包含世界萬物，一草一木。 【淨薈主辦】常霖法師講「學佛修行信願行」之一: 信 - YouTube 佛偈： 人生難得今已得，佛法難聞今已聞； 此身不向今生度，更待何生度此身？ 世间万物必经阶段：成住坏空 佛曰：眾生皆苦，都有很多不完美，很多缺憾，所以我們需要修佛。 學佛是學習與自己的心相處，修佛是提升自己的覺察力，成佛是成為更好的自己，每個人心中都有一個佛陀，我們需要不斷進行修行，成為自己的佛陀，才能擺脫六道輪迴，進入西方極樂世界。 六道輪迴：天道，地道，人道，餓鬼道，地獄道，阿修羅道。只有在人道才能進行修行。 二、愿 【淨薈主辦】常霖法師講「學佛修行信願行」之二: 願 - YouTube1、 佛缘 -&gt; 佛愿，由因-&gt;果，被动-&gt;主动，清楚自己想要什么，愿意做，并且坚持做，直到达成所愿。 三、行 【淨薈主辦】常霖法師講「學佛修行信願行」之三: 行 - YouTube 一念一动一缘生 学佛，学菩萨 观世音菩萨，喜欢帮助众生 地藏菩萨，没有什么做不了的事情，有心者事竟成 逆行菩萨，针对你搞你，但是在这个过程中你可以学习和进步，最终其实是帮助你 打座是提升你的觉察力 一切都是最好的安排","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"佛学","slug":"佛学","permalink":"http://example.com/tags/%E4%BD%9B%E5%AD%A6/"}]},{"title":"停一停 心呼吸 每日銘言 202307","slug":"认知-修行-平衡/心青年-202307","date":"2023-02-03T02:21:33.000Z","updated":"2024-02-22T09:17:24.001Z","comments":true,"path":"2023/02/03/认知-修行-平衡/心青年-202307/","link":"","permalink":"http://example.com/2023/02/03/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/%E5%BF%83%E9%9D%92%E5%B9%B4-202307/","excerpt":"","text":"日期 銘言 7月29号 7月25号 7月24号 7月21号 7月16号 7月14号 7月12号 7月9号 7月7号 7月6号 7月3号 7月2号","categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"}],"tags":[{"name":"佛学","slug":"佛学","permalink":"http://example.com/tags/%E4%BD%9B%E5%AD%A6/"}]},{"title":"P，R，AP, mAP, AP@0.5, mAP@0.5:0.95","slug":"ML/mAP-PR","date":"2022-05-28T05:48:30.000Z","updated":"2023-07-29T06:34:15.702Z","comments":true,"path":"2022/05/28/ML/mAP-PR/","link":"","permalink":"http://example.com/2022/05/28/ML/mAP-PR/","excerpt":"","text":"reference IOU，Intersection of Union，两个框的交集&#x2F;两个框的并集GT，Ground-truth，真实的标注TP，True Positive，检测结果是正确的，简称正检FP，False Positive，检测结果是错误的，简称误检FN，False Negative，没有检测到的目标，简称漏检P，Precison，精准率，检测结果中检测正确所占比例R，Recall，召回率，检测结果中正确检测个数占GT的比例&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; AP，Average Precision，AP计算一个类别，一系列Precision点，Recall点组成一个P-R曲线图，P-R曲线图下的面积就是APmAP，mean Average Precision，多个AP求平均值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x41;&#80;&#x40;&#48;&#x2e;&#53;，计算一个类别的AP，0.5是IOU_thresh的阈值，用来过滤检测框和真实框之间的重叠度IOU，IOU&gt;0.5满足条件&#x41;&#80;&#x40;&#48;&#46;&#53;:0.95，即[0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95] 10个IOU_thresh阈值来画出10个P-R曲线，然后求平均值&#x6d;&#x41;&#80;&#x40;&#x30;&#46;&#x35;，计算多个类别（AP）在IOU_thresh&#x3D;0.5的阈值的情况下的平均值&#109;&#65;&#x50;&#64;&#48;&#x2e;&#53;:0.95，计算多个类别（AP）在IOU_thresh&#x3D;[0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95] 10个IOU_thresh阈值的情况下的平均值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; VOC2007，计算[0:0.1:1]11个recall-point下的Precision点和Recall点值，画P-R曲线，曲线下的面积就是APVOC2010，计算检测值按confidence降序排序，所有confidence都当成recall-point计算Precision点和Recall点值，画P-R曲线，曲线下的面积就是APCOCO，计算[0:0.01,1]101个recall-point下的Precision点和Recall点值，画P-R曲线，曲线下的面积就是AP&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;","categories":[{"name":"技能-修行-进步-ML","slug":"技能-修行-进步-ML","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-ML/"}],"tags":[{"name":"物体检测-metrics","slug":"物体检测-metrics","permalink":"http://example.com/tags/%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8B-metrics/"}]},{"title":"老石谈芯-人工智能的底层逻辑","slug":"ML/AI底层逻辑","date":"2022-05-21T05:48:30.000Z","updated":"2023-07-29T06:14:09.489Z","comments":true,"path":"2022/05/21/ML/AI底层逻辑/","link":"","permalink":"http://example.com/2022/05/21/ML/AI%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/","excerpt":"","text":"AI创新的天花板 暴力美学，大数据+大算力 探索模型的边界 从感知智能→ 认知智能 根据应用设计算法 AI算法的全局观 AI的“圣杯”问题 怎么样做逻辑 ？ 怎么样让AI拥有常识？ 怎么样建模记忆？ 感知 → 认知 ？ 继续深挖神经网络 神经主义+符号主义 传统逻辑推理的新提升 数字石油 数字是现代社会的石油 传统模式，以模型为中心 → 新模式，以数据为中心 数据隐私带来的新问题 联合建模，联邦学习：一种分布式机器学习技术，保护数据隐私，实现共同建模，打破数据孤岛 设计范式的转变（Paradigm Shift） 从关注算法 → 到关注数据 数据墙 cpu → RAM → NPU → GPU 对数据设计温度 冷数据：访问频率低，性能要求低，适合存硬盘 温数据：访问频率较高，数据较为零散，适合放SSD 热数据：访问频率高，性能要求高，适合放内存 芯片和硬件为AI量身定制？ 云原生，AI原生，把硬件算力环境放到云端 AI硬件 &#x3D; GPU 吗？ 异构系统如何编程和控制？ Intel 的OneAPI AI系统，还有那些创新方向？ End-to-end解决方案 以数据为中心的软件开发，通过大数据编程，数据驱动来发现规则，制造机器人的机器人 AI如何落地应用？ 观点1，从需求出发，同时考虑非技术因素 观点2，小样本学习，未来的机会 观点3，统一的平台，推进高校协作 观点，AI LAB必然会消失 观点，单靠技术创业是不够的 AI的未来发展，路在何方？ 需要摩尔定律的加持 互联网技术或者虚拟经济→ 传统行业或者实体经济渗透","categories":[{"name":"技能-修行-进步-ML","slug":"技能-修行-进步-ML","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-ML/"}],"tags":[{"name":"人工智能的底层逻辑","slug":"人工智能的底层逻辑","permalink":"http://example.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"}]},{"title":"Object Detection Solution","slug":"ML/Object-Detection-Solution","date":"2022-03-18T05:48:30.000Z","updated":"2023-07-29T06:30:36.559Z","comments":true,"path":"2022/03/18/ML/Object-Detection-Solution/","link":"","permalink":"http://example.com/2022/03/18/ML/Object-Detection-Solution/","excerpt":"","text":"Reference - HuaWei Clound - ModeArts,网站被删除 To analyze the performance of object detection model, there are two main parts to do: (1) 误检分析，False positive analysis; (2) 漏检分析，False negative analysis. 同样的， 对于误检分析和漏检分析，我们可以把数据划分4个部分，（1）TP(标注漏标，但实际能够检测成功的目标)；（2）Positio false positive（预测结果类别正确，但是和GT的iou不满足；（3）Class false positive（预测结果和GT的iou满足，但是类别不正确）；（4）Background false postive（背景误检） 把TP加回原来的TP，然后就可以画一个饼图出来。 如果类别误检占的比重高，建议训练的时候使用multi-scale，多尺度训练。 如果位置误检占的比重高，建议训练的时候关注IOU-loss，建议使用DIOU-loss。 如果背景误检占的比重高，建议训练的时候关注bounding box loss，通常用的是smooth-L1 loss，可以使用balanced loss。 如果数据中的类别框高比差异较大，比如人是竖立的矩形，车是横向的矩形，需要考虑到模型对框高比的敏感度，建议模型backbone采用FPN结构。 模型对检测目标的亮度敏感（如下图），建议使用DropBlock 模型对检测目标的清晰度敏感个（如下图），建议使用DropBlock 模型对检测目标的面积大小敏感，例如，检测头盔类别，而头盔在图片中的框大多数都是小的，另外一个类别是挖掘机，挖掘机在图片中的框大多数都是大的，建议使用balanced loss。","categories":[{"name":"技能-修行-进步-ML","slug":"技能-修行-进步-ML","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-ML/"}],"tags":[{"name":"物体检测","slug":"物体检测","permalink":"http://example.com/tags/%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8B/"}]},{"title":"Training your own datasets with Darknet","slug":"ML/Training-your-own-datasets-with-Darknet","date":"2021-11-07T06:48:57.000Z","updated":"2023-07-22T01:36:20.351Z","comments":true,"path":"2021/11/07/ML/Training-your-own-datasets-with-Darknet/","link":"","permalink":"http://example.com/2021/11/07/ML/Training-your-own-datasets-with-Darknet/","excerpt":"","text":"date, 2018-11-07 14:48:57 Data collection &amp; labeling Use your own way to collect your data, usually the size of image doesn’t matter. It’ll better to be fit in (48, 48) ~ (1280, 720) When you finished your own dataset, you should label your images. tools : labelImage Usage : refer to the github Install Darknet Darknet Installation , compile with GPU and Opencv if it’s necessary Create VOC format dataset (1) In the root of darknet, create a folder names ‘VOCdevkit’, and create a folder names what you want to name your dataset. like ‘VOC2019_oppo’, which has to start with ‘VOC’. 1234cd /path/darknetmkdir VOCdevkitcd VOCdevkitmkdir VOC2019_oppo (2) Directory like this : 123456└── VOCdevkit └── VOC2019_oppo ├── Annotations ├── ImageSets │ └── Main └── JPEGImages (3) Move the images into JPEGImages and xml files into Annotations. (4) Split the train, val and test, create a py script like belows 1234567891011121314151617181920212223242526## split_train_val.pyimport os,random# read the filenames from a filedirname = &#x27;./Annotations&#x27;files = [f[:-4] for f in os.listdir(dirname) if f[-4:].lower() == &#x27;.xml&#x27;]# random divide trainval = random.sample(files, len(files)//2)test = [f for f in files if f not in trainval]# random divide train = random.sample(trainval, len(trainval)//2)val = [f for f in trainval if f not in train]# save to txt filedef list2txt(arr, fname): with open(fname+&#x27;.txt&#x27;, &#x27;w&#x27;) as f: for a in arr: f.write(a+&#x27;\\n&#x27;)list2txt(trainval, &#x27;trainval&#x27;)list2txt(test, &#x27;test&#x27;)list2txt(train, &#x27;train&#x27;)list2txt(val, &#x27;val&#x27;) then run the script, you will get four files, then move them into the ImageSets&#x2F;Main&#x2F; 123456python split_train_val.pymv test.txt ImageSets/Main/mv train.txt ImageSets/Main/mv trainval.txt ImageSets/Main/mv val.txt ImageSets/Main/ (5) Now you have the directory like this 123456789101112└── VOCdevkit └── VOC2019_oppo ├── Annotations ├── ImageSets │ └── Main │ ├── test.txt │ ├── train.txt │ ├── trainval.txt │ └── val.txt ├── JPEGImages └── split_train_val.py Use the voc_labe to generate Image path list123cd /path/darknettouch voc_label.pyvim voc_label.py (1) create a python script12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061## name voc_label.pyimport xml.etree.ElementTree as ETimport pickleimport osfrom os import listdir, getcwdfrom os.path import join# 1. change to your labels# oppo for example# 4 classes, A5s, A7, reno, reno10xsets = [(&#x27;2019_oppo&#x27;, &#x27;train&#x27;), (&#x27;2019_oppo&#x27;, &#x27;val&#x27;), (&#x27;2019_oppo&#x27;, &#x27;test&#x27;)]classes = [&#x27;A5s&#x27;, &#x27;A7&#x27;, &#x27;reno&#x27;, &#x27;reno10x&#x27;]def convert(size, box): dw = 1./(size[0]) dh = 1./(size[1]) x = (box[0] + box[1])/2.0 - 1 y = (box[2] + box[3])/2.0 - 1 w = box[1] - box[0] h = box[3] - box[2] x = x*dw w = w*dw y = y*dh h = h*dh return (x,y,w,h)def convert_annotation(year, image_id): # 2. change to your path in_file = open(&#x27;/home/ares2/darknet/VOCdevkit/VOC%s/Annotations/%s.xml&#x27;%(year, image_id)) out_file = open(&#x27;/home/ares2/darknet/VOCdevkit/VOC%s/labels/%s.txt&#x27;%(year, image_id), &#x27;w&#x27;) tree=ET.parse(in_file) root = tree.getroot() size = root.find(&#x27;size&#x27;) w = int(size.find(&#x27;width&#x27;).text) h = int(size.find(&#x27;height&#x27;).text) for obj in root.iter(&#x27;object&#x27;): difficult = obj.find(&#x27;difficult&#x27;).text cls = obj.find(&#x27;name&#x27;).text if cls not in classes or int(difficult)==1: continue cls_id = classes.index(cls) xmlbox = obj.find(&#x27;bndbox&#x27;) b = (float(xmlbox.find(&#x27;xmin&#x27;).text), float(xmlbox.find(&#x27;xmax&#x27;).text), float(xmlbox.find(&#x27;ymin&#x27;).text), float(xmlbox.find(&#x27;ymax&#x27;).text)) bb = convert((w,h), b) out_file.write(str(cls_id) + &quot; &quot; + &quot; &quot;.join([str(a) for a in bb]) + &#x27;\\n&#x27;)wd = getcwd()for year, image_set in sets: if not os.path.exists(&#x27;VOCdevkit/VOC%s/labels/&#x27;%(year)): os.makedirs(&#x27;VOCdevkit/VOC%s/labels/&#x27;%(year)) # 3. change to your path image_ids = open(&#x27;/home/ares2/darknet/VOCdevkit/VOC%s/ImageSets/Main/%s.txt&#x27;%(year, image_set)).read().strip().split() list_file = open(&#x27;%s_%s.txt&#x27;%(year, image_set), &#x27;w&#x27;) for image_id in image_ids: list_file.write(&#x27;%s/VOCdevkit/VOC%s/JPEGImages/%s.jpg\\n&#x27;%(wd, year, image_id)) convert_annotation(year, image_id) list_file.close() remember that there are 3 places you need to change this will generate 3 files: 2019_oppo_train.txt 2019_oppo_val.txt 2019_oppo_test.txt Usually I merge 2019_oppo_train.txt and 2019_oppo_test.txt as 2019_oppo_train.txt 1234cd /path/darknetmkdir oppo_od_bakcd oppo_od_bakmkdir cfg from the darknet&#x2F;cfg&#x2F; you can find the yolo-voc.cfg and the yolo-tiny.cfg and from the official website you can download the pretrained models, like for the yolo-voc is darknet53.conv.74. Prepare your cfg file the 3 files you use to train the yolo is yourdata.names yourdata.data yourcfg.cfg (1) yourdata.names contains the labels of your dataset, each label for a line (2) yourdata.data example12345classes= #classes #类别数目train = /path/yourfilename_train.txt # 训练数据valid = /path/yourfilenane_val.txt # 验证数据names = data/yourname.names # class labelsbackup = /backup/ # 权重保存所在文件 remember to delete the comments (3) yourcfg.cfg you can use the yolo-voc.cfg or the yolo-tiny.cfg remember to change these places 12345678910vim yolo-voc.cfg## Remember to comment the testing and uncomment the training[net]# Testing# batch=1# subdivisions=1# Trainingbatch=64subdivisions=16 YOU should change every [yolo] layer.1234567891011121314151617[convolutional]size=1stride=1pad=1filters=27 ## YOU SHOULD CHANGE THE # OF FILTERS## filters = (classes + 5) * 3activation=linear[yolo]mask = 6,7,8anchors = 10,13, 16,30, 33,23, 30,61, 62,45, 59,119, 116,90, 156,198, 373,326classes=4 ## CHANGE TO THE NUMBER OF YOUR LABELSnum=9jitter=.3ignore_thresh = .5truth_thresh = 1random=1 Start Training First time you train, use the pretrained classification model12345cd path/darknet/# yolo-tiny./darknet detector train cfg/yourdata.data cfg/yourcfg.cfg backup/bo_can_tiny_176.weights# yolo-voc./darknet detector train cfg/yourdata.data cfg/yourcfg.cfg backup/darknet53.conv.74 Know your log123456Region 82 Avg IOU: 0.801934, Class: 0.737764, Obj: 0.782024, No Obj: 0.006216, .5R: 1.000000, .75R: 1.000000, count: 5 Region 94 Avg IOU: 0.706899, Class: 0.073915, Obj: 0.544467, No Obj: 0.000506, .5R: 1.000000, .75R: 0.000000, count: 1 Region 106 Avg IOU: 0.831056, Class: 0.037965, Obj: 0.026004, No Obj: 0.000057, .5R: 1.000000, .75R: 1.000000, count: 1 Region 82 Avg IOU: 0.731572, Class: 0.800899, Obj: 0.793200, No Obj: 0.005694, .5R: 1.000000, .75R: 0.333333, count: 3 Region 94 Avg IOU: 0.607969, Class: 0.199724, Obj: 0.884315, No Obj: 0.000286, .5R: 1.000000, .75R: 0.000000, count: 1 Region 106 Avg IOU: -nan, Class: -nan, Obj: -nan, No Obj: 0.000015, .5R: -nan, .75R: -nan, count: （1）以上输出显示了所有训练图片的一个批次（batch），批次大小的划分根据我们在 .cfg 文件中设置的subdivisions参数。在我使用的 .cfg 文件中 batch &#x3D; 64 ，subdivision &#x3D; 16，所以在训练输出中，训练迭代包含了16组，每组又包含了4张图片，跟设定的batch和subdivision的值一致。但是此处有16*3条信息，每组包含三条信息，分别是：Region 82 Avg IOU:Region 94 Avg IOU:Region 106 Avg IOU:三个尺度上预测不同大小的框 82卷积层 为最大的预测尺度，使用较大的mask，但是可以预测出较小的物体 94卷积层 为中间的预测尺度，使用中等的mask， 106卷积层为最小的预测尺度，使用较小的mask，可以预测出较大的物体 （2）每个batch都会有这样一个输出：12706: 1.350835, 1.386559 avg, 0.001000 rate, 3.323842 seconds, 173184 images 2706：batch是第几组。1.350835：总损失1.386559 avg ： 平均损失0.001000 rate：当前的学习率3.323842 seconds： 当前batch训练所花的时间173184 images ： 目前为止参与训练的图片总数 &#x3D; 2706 * 64 （3）1Region 82 Avg IOU: 0.798032, Class: 0.559781, Obj: 0.515851, No Obj: 0.006533, .5R: 1.000000, .75R: 1.000000, count: 2 Region Avg IOU: 表示在当前subdivision内的图片的平均IOU，代表预测的矩形框和真实目标的交集与并集之比.Class: 标注物体分类的正确率，期望该值趋近于1。Obj: 越接近1越好。No Obj: 期望该值越来越小，但不为零。count: count后的值是所有的当前subdivision图片（本例中一共4张）中包含正样本的图片的数量。 参考：https://blog.csdn.net/qq_33444963&#x2F;article&#x2F;details&#x2F;80842179 Training experience YOLO-TINY It’s a simple network for feature extraction, fit to the simple circumstances. Each class should have more than 500 images Training more than 1000 epoches Fast but low accurate. YOLO-VOC It’s a complicated network training on the Imagenet Each class should have more than 300 images Traing more than 10000 epoches. Slow but accurate Overall, more images, the model will be better. You can try to add images slowly. How to run your own yolov3 model with Opencv first you need to install the opencv then, you just copy three files from what you have trained123yourname.nameyourcfg.cfgyourweights.weights then set them in the config file123456789101112131415161718class FLAGS: # Initialize the parameters confThreshold = 0.65 # Confidence threshold nmsThreshold = 0.3 # Non-maximum suppression threshold inpWidth = 416 # Width of network&#x27;s input image inpHeight = 416 # Height of network&#x27;s input image camera_id = 0 # Load names of classes classesFile = &quot;./shelves_od_300/shelves_od.names&quot; classes = None with open(classesFile, &#x27;rt&#x27;) as f: classes = f.read().rstrip(&#x27;\\n&#x27;).split(&#x27;\\n&#x27;) # Give the configuration and weight files for the model and load the network using them modelConfiguration = &quot;./shelves_od_300/yolov3-voc.cfg&quot; modelWeights = &quot;./shelves_od_300/yolov3-voc_latest.weights&quot; Finally, run the script below123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177# This code is written at BigVision LLC. It is based on the OpenCV project. It is subject to the license terms in the LICENSE file found in this distribution and at http://opencv.org/license.html# Usage example: python3 object_detection_yolo.py --video=run.mp4# python3 object_detection_yolo.py --image=bird.jpgimport cv2 as cvimport argparseimport sysimport numpy as npimport os.pathimport uuidfrom config import FLAGS# Initialize the parametersconfThreshold = FLAGS.confThreshold #Confidence thresholdnmsThreshold = FLAGS.nmsThreshold #Non-maximum suppression thresholdinpWidth = FLAGS.inpWidth #Width of network&#x27;s input imageinpHeight = FLAGS.inpHeight #Height of network&#x27;s input imageclasses = FLAGS.classesglobal _i_i = 1000# Get the =-.l2 of the output layersdef getOutputsNames(net): # Get the names of all the layers in the network layersNames = net.getLayerNames() # Get the names of the output layers, i.e. the layers with unconnected outputs return [layersNames[i[0] - 1] for i in net.getUnconnectedOutLayers()]# Draw the predicted bounding boxdef drawPred(frame, classId, conf, left, top, right, bottom): # Draw a bounding box. cv.rectangle(frame, (left, top), (right, bottom), (255, 178, 50), 3) label = &#x27;%.2f&#x27; % conf # Get the label for the class name and its confidence if classes: assert(classId &lt; len(classes)) label = &#x27;%s:%s&#x27; % (classes[classId], label) #Display the label at the top of the bounding box labelSize, baseLine = cv.getTextSize(label, cv.FONT_HERSHEY_SIMPLEX, 0.5, 1) top = max(top, labelSize[1]) cv.rectangle(frame, (left, top - round(1.5*labelSize[1])), (left + round(1.5*labelSize[0]), top + baseLine), (255, 255, 255), cv.FILLED) cv.putText(frame, label, (left, top), cv.FONT_HERSHEY_SIMPLEX, 0.75, (0,0,0), 1)# Remove the bounding boxes with low confidence using non-maxima suppressiondef postprocess(frame, outs): frameHeight = frame.shape[0] frameWidth = frame.shape[1] # Scan through all the bounding boxes output from the network and keep only the # ones with high confidence scores. Assign the box&#x27;s class label as the class with the highest score. classIds = [] confidences = [] boxes = [] for out in outs: for detection in out: scores = detection[5:] classId = np.argmax(scores) confidence = scores[classId] if confidence &gt; confThreshold: center_x = int(detection[0] * frameWidth) center_y = int(detection[1] * frameHeight) width = int(detection[2] * frameWidth) height = int(detection[3] * frameHeight) left = int(center_x - width / 2) top = int(center_y - height / 2) classIds.append(classId) confidences.append(float(confidence)) boxes.append([left, top, width, height]) global _i # Perform non maximum suppression to eliminate redundant overlapping boxes with # lower confidences. indices = cv.dnn.NMSBoxes(boxes, confidences, confThreshold, nmsThreshold) for i in indices: i = i[0] box = boxes[i] left = box[0] top = box[1] width = box[2] height = box[3] ## save crop image crop_img = frame[top:top+height, left:left+width, ] #resized_img = cv.resize(crop_img, (100, 100)) #if _i % 5 == 0: #cv.imwrite(&#x27;save_imgs/&#x27;+str(uuid.uuid1())+&#x27;.jpg&#x27;, crop_img) _i = _i + 1 drawPred(frame, classIds[i], confidences[i], left, top, left + width, top + height)def processing_yolov3(args): net = cv.dnn.readNetFromDarknet(FLAGS.modelConfiguration, FLAGS.modelWeights) net.setPreferableBackend(cv.dnn.DNN_BACKEND_OPENCV) net.setPreferableTarget(cv.dnn.DNN_TARGET_CPU) # Process inputs winName = &#x27;Deep learning object detection in OpenCV&#x27; cv.namedWindow(winName, cv.WINDOW_NORMAL) outputFile = &quot;yolo_out_py.avi&quot; if (args.image): # Open the image file if not os.path.isfile(args.image): print(&quot;Input image file &quot;, args.image, &quot; doesn&#x27;t exist&quot;) sys.exit(1) cap = cv.VideoCapture(args.image) outputFile = args.image[:-4]+&#x27;_yolo_out_py.jpg&#x27; elif (args.video): # Open the video file if not os.path.isfile(args.video): print(&quot;Input video file &quot;, args.video, &quot; doesn&#x27;t exist&quot;) sys.exit(1) cap = cv.VideoCapture(args.video) outputFile = args.video[:-4]+&#x27;_yolo_out_py.avi&#x27; else: # Webcam input cap = cv.VideoCapture(FLAGS.camera_id) cap.set(3, 720) cap.set(4, 1280) # Get the video writer initialized to save the output video if (not args.image): vid_writer = cv.VideoWriter(outputFile, cv.VideoWriter_fourcc(&#x27;M&#x27;,&#x27;J&#x27;,&#x27;P&#x27;,&#x27;G&#x27;), 30, (round(cap.get(cv.CAP_PROP_FRAME_WIDTH)),round(cap.get(cv.CAP_PROP_FRAME_HEIGHT)))) while cv.waitKey(1) &lt; 0: # get frame from the video hasFrame, frame = cap.read() # Stop the program if reached end of video if not hasFrame: print(&quot;Done processing !!!&quot;) print(&quot;Output file is stored as &quot;, outputFile) cv.waitKey(3000) # Release device cap.release() break # Create a 4D blob from a frame. blob = cv.dnn.blobFromImage(frame, 1/255, (inpWidth, inpHeight), [0,0,0], 1, crop=False) # Sets the input to the network net.setInput(blob) # Runs the forward pass to get output of the output layers outs = net.forward(getOutputsNames(net)) # Remove the bounding boxes with low confidence postprocess(frame, outs) # Put efficiency information. The function getPerfProfile returns the overall time for inference(t) and the timings for each of the layers(in layersTimes) t, _ = net.getPerfProfile() label = &#x27;Inference time: %.2f ms&#x27; % (t * 1000.0 / cv.getTickFrequency()) cv.putText(frame, label, (0, 15), cv.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255)) # Write the frame with the detection boxes if (args.image): cv.imwrite(outputFile, frame.astype(np.uint8)) else: vid_writer.write(frame.astype(np.uint8)) cv.imshow(winName, frame)if __name__ == &#x27;__main__&#x27;: parser = argparse.ArgumentParser(description=&#x27;Object Detection using YOLO in OPENCV&#x27;) parser.add_argument(&#x27;--image&#x27;, help=&#x27;Path to image file.&#x27;) parser.add_argument(&#x27;--video&#x27;, help=&#x27;Path to video file.&#x27;) args = parser.parse_args() processing_yolov3(args)","categories":[{"name":"技能-修行-进步-ML","slug":"技能-修行-进步-ML","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-ML/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"yolov3","slug":"yolov3","permalink":"http://example.com/tags/yolov3/"},{"name":"darknet","slug":"darknet","permalink":"http://example.com/tags/darknet/"}]},{"title":"comparison of MTCNN on RK3399","slug":"ML/comparison-of-MTCNN-on-RK3399","date":"2021-03-08T04:04:23.000Z","updated":"2020-06-23T01:08:20.000Z","comments":true,"path":"2021/03/08/ML/comparison-of-MTCNN-on-RK3399/","link":"","permalink":"http://example.com/2021/03/08/ML/comparison-of-MTCNN-on-RK3399/","excerpt":"","text":"date, 2019-03-08 12:04:23 在RK板上运行mtcnn的方案1. 运行caffe版本的mtcnn 在RK上安装OPENCL的Caffe(环境配置) 先装OPENBLAS，后装Caffe 中间遇到ViennaCL库没找到，但是安装出错 在RK板上运行python版的mtcnn-caffe 在RK板上运行C++版的mtcnn-caffe 2. 运行tensorflow-lite版本的mtcnn 在RK板上安装tensorflow-lite(环境配置) 这一部分的教程较少，安装出错 把mtcnn的模型转换成lite模型 运行mtcnn 3. 测试mtcnn(tensorflow)在不同机器上的fps星期五, 08. 三月 2019 11:32上午 test_video : outpy4.avi image size : 480 x 640 fps CPU GPU HP_Zhan(MX150)2G 5.05 12.04 JTx2 (Pascal GPU) 8G 4.00 6.23 RK3399 (No GPU) 1.52 None image size : 216 x 512 fps CPU GPU HP_Zhan(MX150)&#x2F;2G 10.45 22.96 JTx2 (Pascal GPU) &#x2F;8G 8.64 11.89 RK3399 (No GPU) 2.81 None 4. 优化mtcnn的思路reference : MTCNN优化和另类用法 MTCNN速度的瓶颈 图片越大Pnet耗时也就越大。 人脸越多Onet和Rnet耗时越大。 噪点比较多的夜晚图像会导致Pnet误检测增多。 从input_size入手，缩小input_size可以加快速度，如：480x640 -&gt; 216 x 512，可以提高40%左右的速率 换caffe框架，想办法把RK板上的GPU利用起来实现加速 5. caffe2 VS tensorflow (MTCNN) 在HP-Zhan-Tim上跑GPU，每个流程跑3次 Framwork tensorflow caffe2 FPS GPU-1&#x2F;GPU-2&#x2F;GPU-3 GPU-1&#x2F;GPU-2&#x2F;GPU-3 480x640 13.41&#x2F;13.08&#x2F;12.75 13.69&#x2F;13.73&#x2F;13.58 216X512 22.43&#x2F;22.62&#x2F;23.09 30.01&#x2F;29.25&#x2F;29.82","categories":[],"tags":[{"name":"mtcnn","slug":"mtcnn","permalink":"http://example.com/tags/mtcnn/"},{"name":"RK3399","slug":"RK3399","permalink":"http://example.com/tags/RK3399/"}]},{"title":"Training your own data with TF object detection API","slug":"ML/Training-your-own-data-with-TF-object-detection-API","date":"2021-02-03T06:28:07.000Z","updated":"2023-07-22T01:36:12.605Z","comments":true,"path":"2021/02/03/ML/Training-your-own-data-with-TF-object-detection-API/","link":"","permalink":"http://example.com/2021/02/03/ML/Training-your-own-data-with-TF-object-detection-API/","excerpt":"","text":"System Info Ubuntu 16.04 Git TF 2.0 pillow lxml protobuf ( &gt; 3.3 , my version, 3.11.2) ref1-tensorflow+ssd_mobilenet实现目标检测的训练 ref2-（更新视频教程）Tensorflow object detection API 搭建属于自己的物体识别模型（2）——训练并使用自己的模型 ref3-Tensorflow object detection API训练自己的数据 To-dos TF object detection API Env prepare Clone the model repository into local Guid for installation Make your own dataset For us, we have the yolo format annotaion files(txt files), but TFRecord format data is fit to the tensorlow. 123yolo-2-voc.pyvoc-2-csv.pycsv-2-tfrecord.py yolo to voc Prepare two folders, one for annotation files and the other for the image files. VOC format(xml files) will save into the converted_lanbels folder. manual change your own data label-mappings Notice that the value of (x, y, width, height) are integers .123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124# Script to convert yolo annotations to voc format# Sample format# &lt;annotation&gt;# &lt;folder&gt;_image_fashion&lt;/folder&gt;# &lt;filename&gt;brooke-cagle-39574.jpg&lt;/filename&gt;# &lt;size&gt;# &lt;width&gt;1200&lt;/width&gt;# &lt;height&gt;800&lt;/height&gt;# &lt;depth&gt;3&lt;/depth&gt;# &lt;/size&gt;# &lt;segmented&gt;0&lt;/segmented&gt;# &lt;object&gt;# &lt;name&gt;head&lt;/name&gt;# &lt;pose&gt;Unspecified&lt;/pose&gt;# &lt;truncated&gt;0&lt;/truncated&gt;# &lt;difficult&gt;0&lt;/difficult&gt;# &lt;bndbox&gt;# &lt;xmin&gt;549&lt;/xmin&gt;# &lt;ymin&gt;251&lt;/ymin&gt;# &lt;xmax&gt;625&lt;/xmax&gt;# &lt;ymax&gt;335&lt;/ymax&gt;# &lt;/bndbox&gt;# &lt;/object&gt;# &lt;annotation&gt;import osimport xml.etree.cElementTree as ETfrom PIL import ImageANNOTATIONS_DIR_PREFIX = &quot;annotations&quot;DESTINATION_DIR = &quot;converted_labels&quot;CLASS_MAPPING = &#123; &#x27;0&#x27;: &#x27;cream_hazelnut&#x27;, &#x27;1&#x27;: &#x27;cream_berry&#x27;, &#x27;2&#x27;: &#x27;cream_cherry&#x27;, &#x27;3&#x27;: &#x27;yida_cool_lemon&#x27;, &#x27;4&#x27;: &#x27;box_yogurt_mango&#x27;, &#x27;5&#x27;: &#x27;white_strawberry&#x27;, &#x27;6&#x27;: &#x27;cookies_lemon&#x27;, &#x27;7&#x27;: &#x27;yogurt_cranberry&#x27;, &#x27;8&#x27;: &#x27;box_cookies_matcha&#x27;, &#x27;9&#x27;: &#x27;cookies_matcha&#x27;, &#x27;10&#x27;: &#x27;yogurt_mango&#x27;, &#x27;11&#x27;: &#x27;white_passionfruit&#x27;, &#x27;12&#x27;: &#x27;yida_cool_litchi&#x27;, &#x27;13&#x27;: &#x27;box_white_strawberry&#x27; # Add your remaining classes here.&#125;def create_root(file_prefix, width, height): root = ET.Element(&quot;annotations&quot;) ET.SubElement(root, &quot;filename&quot;).text = &quot;&#123;&#125;.jpg&quot;.format(file_prefix) ET.SubElement(root, &quot;folder&quot;).text = &quot;images&quot; size = ET.SubElement(root, &quot;size&quot;) ET.SubElement(size, &quot;width&quot;).text = str(width) ET.SubElement(size, &quot;height&quot;).text = str(height) ET.SubElement(size, &quot;depth&quot;).text = &quot;3&quot; return rootdef create_object_annotation(root, voc_labels): for voc_label in voc_labels: obj = ET.SubElement(root, &quot;object&quot;) ET.SubElement(obj, &quot;name&quot;).text = voc_label[0] ET.SubElement(obj, &quot;pose&quot;).text = &quot;Unspecified&quot; ET.SubElement(obj, &quot;truncated&quot;).text = str(0) ET.SubElement(obj, &quot;difficult&quot;).text = str(0) bbox = ET.SubElement(obj, &quot;bndbox&quot;) ET.SubElement(bbox, &quot;xmin&quot;).text = str(voc_label[1]) ET.SubElement(bbox, &quot;ymin&quot;).text = str(voc_label[2]) ET.SubElement(bbox, &quot;xmax&quot;).text = str(voc_label[3]) ET.SubElement(bbox, &quot;ymax&quot;).text = str(voc_label[4]) return rootdef create_file(file_prefix, width, height, voc_labels): root = create_root(file_prefix, width, height) root = create_object_annotation(root, voc_labels) tree = ET.ElementTree(root) tree.write(&quot;&#123;&#125;/&#123;&#125;.xml&quot;.format(DESTINATION_DIR, file_prefix))def read_file(file_path): file_prefix = file_path.split(&quot;.txt&quot;)[0] image_file_name = &quot;&#123;&#125;.jpg&quot;.format(file_prefix) img = Image.open(&quot;&#123;&#125;/&#123;&#125;&quot;.format(&quot;images&quot;, image_file_name)) w, h = img.size with open(&quot;&#123;&#125;/&#123;&#125;&quot;.format(ANNOTATIONS_DIR_PREFIX, file_path), &#x27;r&#x27;) as file: lines = file.readlines() voc_labels = [] for line in lines: voc = [] line = line.strip() data = line.split() voc.append(CLASS_MAPPING.get(data[0])) bbox_width = float(data[3]) * w bbox_height = float(data[4]) * h center_x = float(data[1]) * w center_y = float(data[2]) * h voc.append(int(center_x - (bbox_width / 2))) voc.append(int(center_y - (bbox_height / 2))) voc.append(int(center_x + (bbox_width / 2))) voc.append(int(center_y + (bbox_height / 2))) voc_labels.append(voc) create_file(file_prefix, w, h, voc_labels) print(&quot;Processing complete for file: &#123;&#125;/&#123;&#125;&quot;.format(ANNOTATIONS_DIR_PREFIX, file_path))def start(): if not os.path.exists(DESTINATION_DIR): os.makedirs(DESTINATION_DIR) for filename in os.listdir(ANNOTATIONS_DIR_PREFIX): if filename.endswith(&#x27;txt&#x27;): read_file(filename) else: print(&quot;Skipping file: &#123;&#125;&quot;.format(filename))if __name__ == &quot;__main__&quot;: start() train test split on xml files You can change the percentage to split the dataset manually.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import osimport randomimport timeimport shutilxmlfilepath = r&#x27;./Annotations&#x27;saveBasePath = r&quot;./&quot;trainval_percent = 0.8train_percent = 0.8total_xml = os.listdir(xmlfilepath)num = len(total_xml)list = range(num)tv = int(num * trainval_percent)tr = int(tv * train_percent)trainval = random.sample(list, tv)train = random.sample(trainval, tr)print(&quot;train and val size&quot;, tv)print(&quot;train size&quot;, tr)start = time.time()test_num = 0val_num = 0train_num = 0print(&#x27;total xml : &#123;&#125;&#x27;.format(total_xml))for i in list: name = total_xml[i] # print(&#x27;name : &#123;&#125;&#x27;.format(name)) if i in trainval: # train and val set if i in train: directory = &quot;train&quot; train_num += 1 xml_path = os.path.join(os.getcwd(), &#x27;&#123;&#125;&#x27;.format(directory)) if (not os.path.exists(xml_path)): os.mkdir(xml_path) filePath = os.path.join(xmlfilepath, name) newfile = os.path.join(saveBasePath, os.path.join(directory, name)) # print(&#x27;newfile : &#123;&#125;&#x27;.format(newfile)) shutil.copyfile(filePath, newfile) else: directory = &quot;validation&quot; xml_path = os.path.join(os.getcwd(), &#x27;&#123;&#125;&#x27;.format(directory)) if (not os.path.exists(xml_path)): os.mkdir(xml_path) val_num += 1 filePath = os.path.join(xmlfilepath, name) newfile = os.path.join(saveBasePath, os.path.join(directory, name)) # print(&#x27;newfile : &#123;&#125;&#x27;.format(newfile)) shutil.copyfile(filePath, newfile) else: directory = &quot;test&quot; xml_path = os.path.join(os.getcwd(), &#x27;&#123;&#125;&#x27;.format(directory)) if (not os.path.exists(xml_path)): os.mkdir(xml_path) test_num += 1 filePath = os.path.join(xmlfilepath, name) newfile = os.path.join(saveBasePath, os.path.join(directory, name)) # print(&#x27;name : &#123;&#125;&#x27;.format(name)) shutil.copyfile(filePath, newfile)end = time.time()seconds = end - startprint(&quot;train total : &quot; + str(train_num))print(&quot;validation total : &quot; + str(val_num))print(&quot;test total : &quot; + str(test_num))total_num = train_num + val_num + test_numprint(&quot;total number : &quot; + str(total_num))print(&quot;Time taken : &#123;0&#125; seconds&quot;.format(seconds)) voc to csv Transfer the xml files to csv for trian, test and validation folder individually. You should change the save path for your own csv files.12345678910111213141516171819202122232425262728293031323334353637import osimport globimport pandas as pdimport xml.etree.ElementTree as ETdef xml_to_csv(path): xml_list = [] for xml_file in glob.glob(path + &#x27;/*.xml&#x27;): tree = ET.parse(xml_file) root = tree.getroot() print(root.find(&#x27;filename&#x27;).text) for member in root.findall(&#x27;object&#x27;): value = (root.find(&#x27;filename&#x27;).text, int(root.find(&#x27;size&#x27;)[0].text), #width int(root.find(&#x27;size&#x27;)[1].text), #height member[0].text, int(member[4][0].text), int(float(member[4][1].text)), int(member[4][2].text), int(member[4][3].text) ) xml_list.append(value) column_name = [&#x27;filename&#x27;, &#x27;width&#x27;, &#x27;height&#x27;, &#x27;class&#x27;, &#x27;xmin&#x27;, &#x27;ymin&#x27;, &#x27;xmax&#x27;, &#x27;ymax&#x27;] xml_df = pd.DataFrame(xml_list, columns=column_name) return xml_dfdef main(): for directory in [&#x27;train&#x27;,&#x27;test&#x27;,&#x27;validation&#x27;]: xml_path = os.path.join(os.getcwd(), &#x27;./&#123;&#125;&#x27;.format(directory)) xml_df = xml_to_csv(xml_path) # xml_df.to_csv(&#x27;whsyxt.csv&#x27;, index=None) xml_df.to_csv(&#x27;/home/tim/workspace/models/research/object_detection/data/dove_cholo_&#123;&#125;_labels.csv&#x27;.format(directory), index=None) print(&#x27;Successfully converted xml to csv.&#x27;)main() csv to tfrecord You should set your JPEGImage path.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;Created on Tue Mar 5 15:28:55 2019@author: z&quot;&quot;&quot;&quot;&quot;&quot;Usage: # From tensorflow/models/ # Create train data: python generate_tfrecord.py --csv_input=data/tv_vehicle_labels.csv --output_path=train.record # Create test data: python generate_tfrecord.py --csv_input=data/test_labels.csv --output_path=test.record&quot;&quot;&quot;import osimport ioimport pandas as pdimport tensorflow as tffrom PIL import Imagefrom object_detection.utils import dataset_utilfrom collections import namedtuple, OrderedDictos.chdir(&#x27;/home/tim/workspace/models/research/&#x27;)flags = tf.app.flagsflags.DEFINE_string(&#x27;csv_input&#x27;, &#x27;&#x27;, &#x27;Path to the CSV input&#x27;)flags.DEFINE_string(&#x27;output_path&#x27;, &#x27;&#x27;, &#x27;Path to output TFRecord&#x27;)FLAGS = flags.FLAGS# TO-DO replace this with label mapdef class_text_to_int(row_label): # 你的所有类别, 必须从1开始，0被征用作为了背景。 if row_label == &#x27;cream_berry&#x27;: return 1 elif row_label == &#x27;cream_cherry&#x27;: return 2 elif row_label == &#x27;yida_cool_lemon&#x27;: return 3 elif row_label == &#x27;box_yogurt_mango&#x27;: return 4 elif row_label == &#x27;white_strawberry&#x27;: return 5 elif row_label == &#x27;cookies_lemon&#x27;: return 6 elif row_label == &#x27;yogurt_cranberry&#x27;: return 7 elif row_label == &#x27;box_cookies_matcha&#x27;: return 8 elif row_label == &#x27;cookies_matcha&#x27;: return 9 elif row_label == &#x27;yogurt_mango&#x27;: return 10 elif row_label == &#x27;white_passionfruit&#x27;: return 11 elif row_label == &#x27;yida_cool_litchi&#x27;: return 12 elif row_label == &#x27;box_white_strawberry&#x27;: return 13 elif row_label == &#x27;cream_hazelnut&#x27;: return 14 else: return Nonedef split(df, group): data = namedtuple(&#x27;data&#x27;, [&#x27;filename&#x27;, &#x27;object&#x27;]) gb = df.groupby(group) return [data(filename, gb.get_group(x)) for filename, x in zip(gb.groups.keys(), gb.groups)]def create_tf_example(group, path): with tf.gfile.GFile(os.path.join(path, &#x27;&#123;&#125;&#x27;.format(group.filename)), &#x27;rb&#x27;) as fid: encoded_jpg = fid.read() encoded_jpg_io = io.BytesIO(encoded_jpg) image = Image.open(encoded_jpg_io) width, height = image.size filename = group.filename.encode(&#x27;utf8&#x27;) image_format = b&#x27;jpg&#x27; xmins = [] xmaxs = [] ymins = [] ymaxs = [] classes_text = [] classes = [] for index, row in group.object.iterrows(): xmins.append(row[&#x27;xmin&#x27;] / width) xmaxs.append(row[&#x27;xmax&#x27;] / width) ymins.append(row[&#x27;ymin&#x27;] / height) ymaxs.append(row[&#x27;ymax&#x27;] / height) classes_text.append(row[&#x27;class&#x27;].encode(&#x27;utf8&#x27;)) classes.append(class_text_to_int(row[&#x27;class&#x27;])) tf_example = tf.train.Example(features=tf.train.Features(feature=&#123; &#x27;image/height&#x27;: dataset_util.int64_feature(height), &#x27;image/width&#x27;: dataset_util.int64_feature(width), &#x27;image/filename&#x27;: dataset_util.bytes_feature(filename), &#x27;image/source_id&#x27;: dataset_util.bytes_feature(filename), &#x27;image/encoded&#x27;: dataset_util.bytes_feature(encoded_jpg), &#x27;image/format&#x27;: dataset_util.bytes_feature(image_format), &#x27;image/object/bbox/xmin&#x27;: dataset_util.float_list_feature(xmins), &#x27;image/object/bbox/xmax&#x27;: dataset_util.float_list_feature(xmaxs), &#x27;image/object/bbox/ymin&#x27;: dataset_util.float_list_feature(ymins), &#x27;image/object/bbox/ymax&#x27;: dataset_util.float_list_feature(ymaxs), &#x27;image/object/class/text&#x27;: dataset_util.bytes_list_feature(classes_text), &#x27;image/object/class/label&#x27;: dataset_util.int64_list_feature(classes), &#125;)) return tf_exampledef main(_): writer = tf.python_io.TFRecordWriter(FLAGS.output_path) path = os.path.join(os.getcwd(), &#x27;object_detection/VOCdevkit/VOC2020_dove_cholo/JPEGImages/&#x27;) examples = pd.read_csv(FLAGS.csv_input) grouped = split(examples, &#x27;filename&#x27;) num = 0 for group in grouped: num += 1 tf_example = create_tf_example(group, path) writer.write(tf_example.SerializeToString()) if (num % 100 == 0): # 每完成100个转换，打印一次 print(num) writer.close() output_path = os.path.join(os.getcwd(), FLAGS.output_path) print(&#x27;Successfully created the TFRecords: &#123;&#125;&#x27;.format(output_path))if __name__ == &#x27;__main__&#x27;: tf.app.run() command to generate tfrecord files1234567cd models/research/python generate_tfrecord.py --csv_input=object_detection/data/dove_cholo_test_labels.csv --output_path=dove_test.tfrecordpython generate_tfrecord.py --csv_input=object_detection/data/dove_cholo_validation_labels.csv --output_path=dove_validation.tfrecordpython generate_tfrecord.py --csv_input=object_detection/data/dove_cholo_train_labels.csv --output_path=dove_train.tfrecord Training model Things to prepare create your own label-map.pbtxt1234567891011121314cd models/research/object_detection/datacreate label-map.pbtxtcontents are belows item &#123; id: 1 # id 从1开始编号 name: &#x27;red pedestrian&#x27; &#125; item &#123; id: 2 name: &#x27;green pedestrian&#x27; &#125; model config file list12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364cd object_detection/samples/config/(base) tim@tim-System-Product-Name:~/workspace/models/research/object_detection/samples/configs$ tree.├── embedded_ssd_mobilenet_v1_coco.config├── facessd_mobilenet_v2_quantized_320x320_open_image_v4.config├── faster_rcnn_inception_resnet_v2_atrous_coco.config├── faster_rcnn_inception_resnet_v2_atrous_cosine_lr_coco.config├── faster_rcnn_inception_resnet_v2_atrous_oid.config├── faster_rcnn_inception_resnet_v2_atrous_oid_v4.config├── faster_rcnn_inception_resnet_v2_atrous_pets.config├── faster_rcnn_inception_v2_coco.config├── faster_rcnn_inception_v2_pets.config├── faster_rcnn_nas_coco.config├── faster_rcnn_resnet101_atrous_coco.config├── faster_rcnn_resnet101_ava_v2.1.config├── faster_rcnn_resnet101_coco.config├── faster_rcnn_resnet101_fgvc.config├── faster_rcnn_resnet101_kitti.config├── faster_rcnn_resnet101_pets.config├── faster_rcnn_resnet101_voc07.config├── faster_rcnn_resnet152_coco.config├── faster_rcnn_resnet152_pets.config├── faster_rcnn_resnet50_coco.config├── faster_rcnn_resnet50_fgvc.config├── faster_rcnn_resnet50_pets.config├── mask_rcnn_inception_resnet_v2_atrous_coco.config├── mask_rcnn_inception_v2_coco.config├── mask_rcnn_resnet101_atrous_coco.config├── mask_rcnn_resnet101_pets.config├── mask_rcnn_resnet50_atrous_coco.config├── rfcn_resnet101_coco.config├── rfcn_resnet101_pets.config├── ssd_inception_v2_coco.config├── ssd_inception_v2_pets.config├── ssd_inception_v3_pets.config├── ssdlite_mobilenet_edgetpu_320x320_coco.config├── ssdlite_mobilenet_edgetpu_320x320_coco_quant.config├── ssdlite_mobilenet_v1_coco.config├── ssdlite_mobilenet_v2_coco.config├── ssdlite_mobilenet_v3_large_320x320_coco.config├── ssdlite_mobilenet_v3_small_320x320_coco.config├── ssd_mobilenet_v1_0.75_depth_300x300_coco14_sync.config├── ssd_mobilenet_v1_0.75_depth_quantized_300x300_coco14_sync.config├── ssd_mobilenet_v1_0.75_depth_quantized_300x300_pets_sync.config├── ssd_mobilenet_v1_300x300_coco14_sync.config├── ssd_mobilenet_v1_coco.config├── ssd_mobilenet_v1_focal_loss_pets.config├── ssd_mobilenet_v1_focal_loss_pets_inference.config├── ssd_mobilenet_v1_fpn_shared_box_predictor_640x640_coco14_sync.config├── ssd_mobilenet_v1_pets.config├── ssd_mobilenet_v1_ppn_shared_box_predictor_300x300_coco14_sync.config├── ssd_mobilenet_v1_quantized_300x300_coco14_sync.config├── ssd_mobilenet_v2_coco.config├── ssd_mobilenet_v2_fpnlite_quantized_shared_box_predictor_256x256_depthmultiplier_75_coco14_sync.config├── ssd_mobilenet_v2_fullyconv_coco.config├── ssd_mobilenet_v2_oid_v4.config├── ssd_mobilenet_v2_pets_keras.config├── ssd_mobilenet_v2_quantized_300x300_coco.config├── ssd_resnet101_v1_fpn_shared_box_predictor_oid_512x512_sync.config└── ssd_resnet50_v1_fpn_shared_box_predictor_640x640_coco14_sync.config0 directories, 57 files Custom your own model config, ssd_moblienet_v1_coco.config for example Open it and change the code.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194# SSD with Mobilenet v1 configuration for MSCOCO Dataset.# Users should configure the fine_tune_checkpoint field in the train config as# well as the label_map_path and input_path fields in the train_input_reader and# eval_input_reader. Search for &quot;PATH_TO_BE_CONFIGURED&quot; to find the fields that# should be configured.model &#123; ssd &#123; num_classes: 14 ## change here box_coder &#123; faster_rcnn_box_coder &#123; y_scale: 10.0 x_scale: 10.0 height_scale: 5.0 width_scale: 5.0 &#125; &#125; matcher &#123; argmax_matcher &#123; matched_threshold: 0.5 unmatched_threshold: 0.5 ignore_thresholds: false negatives_lower_than_unmatched: true force_match_for_each_row: true &#125; &#125; similarity_calculator &#123; iou_similarity &#123; &#125; &#125; anchor_generator &#123; ssd_anchor_generator &#123; num_layers: 6 min_scale: 0.2 max_scale: 0.95 aspect_ratios: 1.0 aspect_ratios: 2.0 aspect_ratios: 0.5 aspect_ratios: 3.0 aspect_ratios: 0.3333 &#125; &#125; image_resizer &#123; fixed_shape_resizer &#123; height: 300 width: 300 &#125; &#125; box_predictor &#123; convolutional_box_predictor &#123; min_depth: 0 max_depth: 0 num_layers_before_predictor: 0 use_dropout: false dropout_keep_probability: 0.8 kernel_size: 1 box_code_size: 4 apply_sigmoid_to_scores: false conv_hyperparams &#123; activation: RELU_6, regularizer &#123; l2_regularizer &#123; weight: 0.00004 &#125; &#125; initializer &#123; truncated_normal_initializer &#123; stddev: 0.03 mean: 0.0 &#125; &#125; batch_norm &#123; train: true, scale: true, center: true, decay: 0.9997, epsilon: 0.001, &#125; &#125; &#125; &#125; feature_extractor &#123; type: &#x27;ssd_mobilenet_v1&#x27; min_depth: 16 depth_multiplier: 1.0 conv_hyperparams &#123; activation: RELU_6, regularizer &#123; l2_regularizer &#123; weight: 0.00004 &#125; &#125; initializer &#123; truncated_normal_initializer &#123; stddev: 0.03 mean: 0.0 &#125; &#125; batch_norm &#123; train: true, scale: true, center: true, decay: 0.9997, epsilon: 0.001, &#125; &#125; &#125; loss &#123; classification_loss &#123; weighted_sigmoid &#123; &#125; &#125; localization_loss &#123; weighted_smooth_l1 &#123; &#125; &#125; hard_example_miner &#123; num_hard_examples: 3000 iou_threshold: 0.99 loss_type: CLASSIFICATION max_negatives_per_positive: 3 min_negatives_per_image: 0 &#125; classification_weight: 1.0 localization_weight: 1.0 &#125; normalize_loss_by_num_matches: true post_processing &#123; batch_non_max_suppression &#123; score_threshold: 1e-8 iou_threshold: 0.6 max_detections_per_class: 100 max_total_detections: 100 &#125; score_converter: SIGMOID &#125; &#125;&#125;train_config: &#123; batch_size: 24 ## change here optimizer &#123; rms_prop_optimizer: &#123; learning_rate: &#123; exponential_decay_learning_rate &#123; initial_learning_rate: 0.0004 decay_steps: 800720 decay_factor: 0.95 &#125; &#125; momentum_optimizer_value: 0.9 decay: 0.9 epsilon: 1.0 &#125; &#125; fine_tune_checkpoint: &quot;object_detection/finetune_cpkt/ssd_mobilenet_v1_coco_2018_01_28/model.ckpt&quot; ## change here from_detection_checkpoint: true # Note: The below line limits the training process to 200K steps, which we # empirically found to be sufficient enough to train the pets dataset. This # effectively bypasses the learning rate schedule (the learning rate will # never decay). Remove the below line to train indefinitely. num_steps: 10000 ## change here data_augmentation_options &#123; random_horizontal_flip &#123; &#125; &#125; data_augmentation_options &#123; ssd_random_crop &#123; &#125; &#125;&#125;train_input_reader: &#123; tf_record_input_reader &#123; input_path: &quot;object_detection/data/dove_train.tfrecord&quot; ## change here &#125; label_map_path: &quot;object_detection/data/dove_cholo_label_map.pbtxt&quot; ## change here&#125;eval_config: &#123; num_examples: 3438 ## change here # Note: The below line limits the evaluation process to 10 evaluations. # Remove the below line to evaluate indefinitely. max_evals: 10&#125;eval_input_reader: &#123; tf_record_input_reader &#123; input_path: &quot;object_detection/data/dove_validation.tfrecord&quot; ## change here &#125; label_map_path: &quot;object_detection/data/dove_cholo_label_map.pbtxt&quot; ## change here shuffle: false num_readers: 1&#125; Download the pre-trained model modle zoo fine_tune_checkpoint: “object_detection&#x2F;finetune_cpkt&#x2F;ssd_mobilenet_v1_coco_2018_01_28&#x2F;model.ckpt” ## change here legacy training (同时跑train.py和eval.py) 旧的训练方法，path, &#x2F;models&#x2F;research&#x2F;object_detection&#x2F;legacy&#x2F;train.py 旧的训练方法，path, &#x2F;models&#x2F;research&#x2F;object_detection&#x2F;legacy&#x2F;eval.py ref-eval的使用 –logtostderr, 日志保存 –train_dir, 训练模型保存的位置 –pipeline_config_path, 模型配置文件的路径 1234567891011121314151617181920212223242526272829## 可用GPU训练，但常常会cuda out of memory## 先在trian.py和eval.py中加入以下代码控制gpu的内存使用import os os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;0&quot;config = tf.ConfigProto(allow_soft_placement = True)gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction = 0.35)config.gpu_options.allow_growth = True sess0 = tf.InteractiveSession(config = config)# 原文链接：https://blog.csdn.net/baidu_33597755/article/details/102311000cd models/research/python object_detection/legacy/train.py \\ --pipeline_config_path=object_detection/dove_cholo_od/config/ssd_mobilenet_v2_coco.config \\ --train_dir=object_detection/dove_cholo_od/dove_train_dir/ssd_m_v2/dove_train \\ --alsologtostderr # 等train.py跑了一会之后，再运行eval.pypython object_detection/legacy/eval.py \\ --pipeline_config_path=object_detection/dove_cholo_od/config/ssd_mobilenet_v2_coco.config \\ --checkpoint_dir=object_detection/dove_cholo_od/dove_train_dir/ssd_m_v2/dove_train \\ --eval_dir=object_detection/dove_cholo_od/dove_train_dir/ssd_m_v2/dove_eval \\ --logtostderr Then open the tensorboard to watch the training and eval progress Open two tensorboard at the same time 123tensorboard --logdir=object_detection/dove_cholo_od/dove_train_dir/ssd_m_v2/dove_train --port=6005tensorboard --logdir=object_detection/dove_cholo_od/dove_train_dir/ssd_m_v2/dove_eval modern training(暂不支持GPU) 新的训练方法，path, &#x2F;models&#x2F;research&#x2F;object_detection&#x2F;model_main.py12345678# From the tensorflow/models/research/ directorypython object_detection/model_main.py \\ --pipeline_config_path=object_detection/training/ssd_mobilenet_v1_coco.config \\ --model_dir=object_detection/training \\ --num_train_steps=50000 \\ --num_eval_steps=2000 \\ --alsologtostderr Model evaluationQ&amp;A12341. ImportError: cannot import name &#x27;input_reader_pb2&#x27; from &#x27;object_detection.protos&#x27;solution:# From tensorflow/models/research/protoc object_detection/protos/*.proto --python_out=. 123456789102. from nets import inception_resnet_v2 ModuleNotFoundError: No module named &#x27;nets&#x27;solution:cd model/research/python setup.py buildpython setup.py installcd model/research/slim/python setup.py buildpython setup.py install 12343. Not found: PATH_TO_BE_CONFIGURED; No such file or directorysolution:download pre-trained cpkt modelgo into the config file and Search for &quot;PATH_TO_BE_CONFIGURED&quot; to find the fields that should be configured. 124. No module named &#x27;pycocotools&#x27;pip install git+https://github.com/philferriere/cocoapi.git#subdirectory=PythonAPI","categories":[{"name":"技能-修行-进步-ML","slug":"技能-修行-进步-ML","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-ML/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://example.com/tags/tensorflow/"},{"name":"目标检测","slug":"目标检测","permalink":"http://example.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}]},{"title":"linux shell常用的指令功能","slug":"小而美-工具/linux_shell_cmd","date":"2021-02-03T05:57:38.000Z","updated":"2023-07-29T06:42:19.913Z","comments":true,"path":"2021/02/03/小而美-工具/linux_shell_cmd/","link":"","permalink":"http://example.com/2021/02/03/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/linux_shell_cmd/","excerpt":"","text":"Linux shell的三剑客grep, sed, awk find命令 find把某个文件夹下的所有文件名称重定向到txt中，例子：把某个文件下的所有jpg文件名（绝对路径）重定向到savetext.txt中。 1$ find abs_path &quot;*.jpg&quot; &gt; savetext.txt 文件数量太多，无法mv，报 1$ bash: /bin/mv: Argument list too long 解决方法 1$ find source/ -name &quot;*.txt&quot; | xargs -i mv &#123;&#125; target/ 统计文件夹下文件数量 1$ ls -l | wc -l 查看当前系统运行的python程序 1$ ps -ef |grep python 复制文件夹 1$ cp -r srt_folder dest_folder 查看当前目录占用空间 1$ du -sh 当前目录文件占用空间按序排列 1$ du -s * | sort -nr | head sed命令 批量修改 1$ sed -i &#x27;s///g&#x27; file.txt 批量修改字符串中包含路径分隔符斜杆，用^分割 1$ sed -i &#x27;s^/data1/images^/data2/images/^g&#x27; test.txt 批量修改带空格的字符串 1$ sed -i &#x27;s#0 #1 #g&#x27; *.txt 修改文件权限 https://blog.csdn.net/mzy202/article/details/7178586 1$ chmod o+w -R folder/file meld，文件内容比对软件1$ sudo apt install meld cat &#x2F;sed 查看文件1$ sed -n &#x27;5,10p&#x27; filename 这样你就可以只查看文件的第5行到第10行。 1234567891011121314151617$ 【一】从第3000行开始，显示1000行。即显示3000~3999行cat filename | tail -n +3000 | head -n 1000【二】显示1000行到3000行cat filename| head -n 3000 | tail -n +1000 *注意两种方法的顺序分解： tail -n 1000：显示最后1000行 tail -n +1000：从1000行开始显示，显示1000行以后的 head -n 1000：显示前面1000行 文件夹卡住了怎么办12# can kill the folder process$ pkill -f nautilus FileZilla遇到编码问题1FileZilla Please make sure the LC_CTYPE (or LC_ALL) environment variable is set correctly https://serverok.in/filezilla-please-make-sure-the-lc_ctype 内存查看1procrank | grep benchmark(程序名) https://blog.csdn.net/qinhai1989/article/details/88112715","categories":[{"name":"小而美-工具","slug":"小而美-工具","permalink":"http://example.com/categories/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"linux shell命令","slug":"linux-shell命令","permalink":"http://example.com/tags/linux-shell%E5%91%BD%E4%BB%A4/"}]},{"title":"nms_and_iou","slug":"ML/nms-and-iou","date":"2020-06-23T02:02:57.000Z","updated":"2023-07-22T02:17:47.020Z","comments":true,"path":"2020/06/23/ML/nms-and-iou/","link":"","permalink":"http://example.com/2020/06/23/ML/nms-and-iou/","excerpt":"","text":"IOU(Intersection of Union)，交并比 给定2个框(bounding box)，计算其交集和并集的比例。 通常bounding box的坐标表示有2种，第一种是2点坐标(x1, y1, x2, y2); 第二种是中心坐标和宽高(x, y, w, h)。在编写代码时我们会把第二种转换成2点坐标的形式进行计算。 code 123456789101112131415161718192021222324252627# params: boxes1: [, [xmin, ymin, xmax, ymax]]# params: boxes2: [num, [xmin, ymin, xmax, ymax]]# returns: iou, [weights], length=len(boxes2)def bboxes_iou(boxes1, boxes2): boxes1 = np.array(boxes1) boxes2 = np.array(boxes2) # 计算各自面积 boxes1_area = (boxes1[..., 2] - boxes1[..., 0]) * (boxes1[..., 3] - boxes1[..., 1]) boxes2_area = (boxes2[..., 2] - boxes2[..., 0]) * (boxes2[..., 3] - boxes2[..., 1]) # 计算交集 left_up = np.maximum(boxes1[..., :2], boxes2[..., :2]) right_down = np.maximum(boxes1[..., 2:], boxes2[..., 2:]) inter_section = np.maximum(right_down - left_up, 0.0) inter_area = inter_section[..., 0] * inter_section[..., 1] # 计算并集 union_area = boxes1_area + boxes2_area - inter_area # 计算IOU iou = np.maximum(1.0 * inter_area / union_area, np.finfo(np.float32).eps) return iou NMS(Non-Maximum Suppression), 极大值抑制 通常在物体检测(object detection)中，在head中预测出了很多的框，每个框包含了物体的类别，类别得分和坐标信息。因为在检测过程产生很多冗余的预测框，那么这时候我们就会用到NMS来去除这些冗余。具体做法是： (1) 取得某一张图片上的某一类别的所有预测框 (2) 对其类别得分进行排序，取出得分最大的框做保留 (3) 拿得分最大的框作为基准(pivot)，和剩余的框的坐标信息做IOU的计算，并将得到的IOU进行排序 (4) 设定一个iou_threshold，把IOU大于iou_threshold过滤出来进行冗余处理 (5) 冗余处理方案有2种，hard NMS和soft NMS，前者是直接把所有过滤的框的得分置为0，后者是利用高斯函数对其得分进行抑制或者减小，IOU越大的得分减少越多或者抑制程度越大，反之就减少越少或者抑制程度越小 (6) soft NMS是为了防止2个同类密集的框被误删其中得分小的框 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# params: bboxes: (xmin, ymin, xmax, ymax, score, class)# params: iou_threshold, scale value# params: method, &#x27;nms&#x27;, &#x27;soft-nms&#x27;# return: best_bboxesdef nms(bboxes, iou_threshold, sigma=0.3, method=&#x27;nms&#x27;): # 找出所有类别的唯一值 classes_in_img = list(set(bboxes[:5])) # 保留的框 best_bboxes = [] # 按每个class进行for循环 for cls in classes_in_img: # 首先过滤当前class的bboxes，得到cls_bboxes cls_mask = (bboxes[:5] == cls) cls_bboxes = bboxes[cls_mask] # NMS开始 while len(cls_bboxes) &gt; 0: # 按照score排序得到最大score的bboxes max_ind = np.argmax(cls_bboxes[:, 4]) best_bbox = cls_bboxes[max_ind] # 从cls_bboxes中剔除最大score的bbox cls_bboxes = np.concatenate([cls_bboxes[:max_ind], cls_bboxes[max_ind+1:]]) # 计算IOU iou = bboxes_iou(best_bbox[np.newaxis, : 4], cls_bboxes[:, :4]) # 初始化weight weight = np.ones(len(iou), dtype=np.float32) assert method in [&#x27;nms&#x27;, &#x27;sfot-nms&#x27;] # nms过滤冗余 if method == &#x27;nms&#x27;: iou_mask = iou &gt; iou_threshold # 把满足冗余的weight设为0 weight[iou_mask] = 0.0 # soft-nms if method == &#x27;soft-nms&#x27;: # 高斯函数 weight = np.exp(-(1.0 * iou **2 / sigma)) # 修改score的值 cls_bboxes[:, 4] *= weight # 过滤score为0的预测框 score_mask = cls_bboxes[:, 4] &gt; 0 cls_bboxes = cls_bboxes[score_mask] return best_bboxes NMS另一种实现方法，from B站Bubbling.. (0) backbone输出的格式是，boxes: [bs, all_boxes, 4+1+num_classes] (1) 先处理坐标转换 (2) 再拿出1张图片中的所有boxes，对conf_threshold进行过滤 (3) 处理每个box最后预测的结果num_classes，如共有20个分类，那么取20个分类中的max_score就是这个box预测的类别，在得到相应的下标index (4) 按类别划分boxes，然后每个类别进行如下循环 取得boxes的conf_score（正&#x2F;背分类得分），按从大到小进行排序 将得分最大的box保留，然后得分最大的box与剩余的boxes进行iou计算 nms_threshold就是iou得分的过滤，把iou得分高于nms_threshold的boxes去掉 直至处理玩当前class的所有boxes 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#coding=utf-8import numpy as npdef nms(boxes, conf_threshold=0.5, nms_threshold=0.4): # boxes: [bs, all_boxes, 4+1+num_classes] bs = np.shape(boxes)[0] # 将中心宽高转换成左上角和右下角的形式 shape_boxes = np.zeros_like(boxes[:,:,:4]) shape_boxes[:,:,0] = boxes[:,:,0] - boxes[:,:,2] / 2 shape_boxes[:,:,1] = boxes[:,:,1] - boxes[:,:,3] / 2 shape_boxes[:,:,2] = boxes[:,:,2] + boxes[:,:,2] / 2 shape_boxes[:,:,3] = boxes[:,:,3] + boxes[:,:,3] / 2 boxes[:,:,:4] = shape_boxes output = [] for i in range(bs): # 取每一张图片中的所有预测框prediction prediction = boxes[i] # 取出每个预测框的前景的二分类得分 score = prediction[:, 4] # 过滤满足conf_threshold的框 mask = score &gt; conf_threshold detections = prediction[mask] # 找出每个预测框box是属于哪个分类的，如80个分类中的哪一个分类label和score class_conf = np.expand_dim(np.max(detections[:,5:], axis=-1), axis=-1) class_pred = np.expand_dims(np.argmax(detections[:,5:], axis=-1), axis=-1) detections = np.concatenate(detections[:,:,5], class_conf, class_pred, 1) unique_class = np.unique(detections[:, -1]) if len(unique_class) == 0: continue best_box = [] for c in unique_class: cls_mask = detection[:, -1] == c detection = detections[cls_mask] scores = detection[:, 4] arg_sort = np.argsort(scores)[:,:,-1] detection = detection[arg_sort] while len(detection) != 0: best_box.append(detection[0]) if len(detection) == 1: break ious = iou(detection[0], detection[1:]) detection = detection[1:][ious &lt; nms_threshold] output.append(best_box) return np.array(output)","categories":[{"name":"技能-修行-进步","slug":"技能-修行-进步","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5/"}],"tags":[{"name":"object detection","slug":"object-detection","permalink":"http://example.com/tags/object-detection/"},{"name":"nms","slug":"nms","permalink":"http://example.com/tags/nms/"},{"name":"iou","slug":"iou","permalink":"http://example.com/tags/iou/"},{"name":"soft-nms","slug":"soft-nms","permalink":"http://example.com/tags/soft-nms/"}]},{"title":"leetcode_binary_tree_series","slug":"alogrithms/leetcode-binary-tree-series","date":"2020-03-09T08:55:53.000Z","updated":"2023-07-22T02:19:30.284Z","comments":true,"path":"2020/03/09/alogrithms/leetcode-binary-tree-series/","link":"","permalink":"http://example.com/2020/03/09/alogrithms/leetcode-binary-tree-series/","excerpt":"","text":"什么是树 **树(Tree)**是一种非线性结构，用来模拟具有树状结构性质的数据集合。它是由n(n&gt;0)个有限节点组成一个具有层次关系的集合。树是递归结构，在树的定义中又用到了树的概念。 什么是二叉树 **二叉树(Binary tree)**是每个节点最多只有两个分支(即不存在分支度大于2的节点)的树结构。通常分支被称作“左子树”或者“右子树”。二叉树的分支具有左右次序，不能随意颠倒。二叉树可以为空。 完全二叉树 若设二叉树的深度为ℎ，除第ℎ层外，其它各层(1～ℎ−1)的结点数都达到最大个数，第ℎ层所有的结点都连续集中在最左边，这就是完全二叉树 什么是二叉搜索树 左子树的值都比根节点小，右子树的值都比根节点大。 树的定义(Python)123456# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.value = x self.left = None self.right = None 树的遍历深度优先，通常有前序(pre-order)，中序(in-order)，后序(post-order)3种遍历方法，每一种又分递归和迭代两种实现 3种遍历经过的路径都是一样的，而且每个节点都会被访问3次，当我们在第一次访问该节点就打印出来的话，那么这就是前序；当我们第二次访问该节点才打印出来的话，那么这就是中序；当我们第三次访问该节点才打印出来的话，那么这就是后序。 伪代码，递归实现12345678910111213141516171819202122# pseudocode，递归## 前序func preorder(root): if not root: return **print(root.val)** preorder(root.left) preorder(root.right) ## 中序, 对于二叉搜索树，中序后的是一个排序数组func inorder(root): if not root: return inorder(root.left) **print(root.val)** inorder(root.right) ## 后序func postorder(root): if not root: return postorder(root.left) postorder(root.right) **print(root.val)** Python 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109## 前序遍历### 1. 递归实现class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: ans = [] if not root: return ans self.preTraversal(root, ans) return ans def preTraversal(self, t, ans): ans.append(t.val) if t.left: self.preTraversal(t.left, ans) if t.right: self.preTraversal(t.right, ans) ### 2. 迭代实现，栈class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: ans = [] stack = [] if not root: return ans p = root while(p or len(stack)): if p: ans.append(p.val) stack.append(p) p = p.left else: p = stack[-1] stack.pop(-1) p = p.right return ans ## ---------------split line-------------------## 中序序遍历### 1. 递归实现class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: ans = [] if not root: return ans self.inTraversal(root, ans) return ans def inTraversal(self, t, ans): ans.append(t.val) if t.left: self.inTraversal(t.left, ans) if t.right: self.inTraversal(t.right, ans) ### 2. 迭代实现class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: ans = [] stack = [] if not root: return ans p = root while(p or len(stack)): if p: stack.append(p) p = p.left else: p = stack[-1] ans.append(p.val) stack.pop(-1) p = p.right return ans ## ---------------split line-------------------## 后序序遍历### 1. 递归实现class Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: ans = [] if not root: return ans self.postTraversal(root, ans) return ans def postTraversal(self, t, ans): ans.append(t.val) if t.left: self.postTraversal(t.left, ans) if t.right: self.postTraversal(t.right, ans) ### 2. 迭代实现，因为前序是root-&gt;left-&gt;right, 而后序是left-&gt;right-&gt;root，刚好反过来class Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: ans = [] stack = [] if not root: return ans p = root while(p or len(stack)): if p: ans.append(p.val) stack.append(p) p = p.right else: p = stack[-1] stack.pop(-1) p = p.left return [val for val in reversed(ans)] 广度优先 层次遍历(level-order) 利用队列(queue)来实现 根节点先入队列 迭代当前队列上的所有元素 若该元素所指节点的左右孩子节点非空，则将其左右孩子的指针入队列，把当前元素出队列，并保存其数值到结果数组中。 循环重复2-4，直到队列为空。 12345678910111213141516171819class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: queue = [root] res = [] if not root: return [] while queue: templist = [] templen = len(queue) for i in range(templen): temp = queue.pop(0) templist.append(temp.val) if temp.left: queue.append(temp.left) if temp.right: queue.append(temp.right) res.append(templist) return res 链表(Linked list)，树(Tree)，图(Graph)的关系 链表是特殊的树，树是特殊的图。 reference-参考 二叉树基础知识+Python实现 树的遍历 - 介绍 中国MOOC-二叉树的遍历-video","categories":[{"name":"技能-修行-进步","slug":"技能-修行-进步","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5/"}],"tags":[{"name":"Tree","slug":"Tree","permalink":"http://example.com/tags/Tree/"},{"name":"binary tree","slug":"binary-tree","permalink":"http://example.com/tags/binary-tree/"},{"name":"binary search tree","slug":"binary-search-tree","permalink":"http://example.com/tags/binary-search-tree/"},{"name":"pre-order","slug":"pre-order","permalink":"http://example.com/tags/pre-order/"},{"name":"in-order","slug":"in-order","permalink":"http://example.com/tags/in-order/"},{"name":"post-order","slug":"post-order","permalink":"http://example.com/tags/post-order/"}]},{"title":"rebuild my own blog after system changed - Ubuntu","slug":"小而美-工具/rebuild-my-own-blog-after-system-changed","date":"2020-02-03T06:09:27.000Z","updated":"2024-03-16T15:23:24.359Z","comments":true,"path":"2020/02/03/小而美-工具/rebuild-my-own-blog-after-system-changed/","link":"","permalink":"http://example.com/2020/02/03/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/rebuild-my-own-blog-after-system-changed/","excerpt":"","text":"System info Ubuntu 16.04 Git Node Todosinstall nodeks and npm1234567891011121314# 更新sudo apt-get update# 安装低版本的node，然后再升级最新sudo apt-get install nodejssudo apt install nodejs-legacysudo apt install npm#安装更新版本的工具N，执行：sudo npm install n -g#跟新node版本，执行：sudo n stablesudo node -v# install hexo-clisudo npm install -g hexo-cli install and config git ref1, how to use git quickly Part 1 ref2, how to use git quickly part 2 install hexo with npm12345678910111213141516171819-(1) delete origiginal your own github.io repository-(2) create the new one-(3) git clone to local-(4) hexo init &lt;folder&gt;, and move the contents into local github.io repository-(5) move your own theme files and confg.yaml file to the proper location-(6) install the node libs what your theme needs to satisfy- for example, I use the indigo theme, I should run below commandscd &lt;github.io folder&gt;# 主题默认使用 less 作为 css 预处理工具。npm install hexo-renderer-less --save# 用于生成 rss。npm install hexo-generator-feed --save# 用于生成静态站点数据，用作站内搜索的数据源。npm install hexo-generator-json-content --save# 用于生成微信分享二维码。npm install hexo-helper-qrcode --save# error, hexo d后 ERROR Deployer not found: gitnpm install --save hexo-deployer-git write posts and deploy123456hexo cleanhexo ghexo shexo d# only fit for me to update my own blog. reference http://www.longmuchen.cn/2019/04/18/tools/2019-04-18-zai-ubuntu-14.04-fu-wu-qi-shang-bu-shu-hexo-bo-ke/","categories":[{"name":"小而美-工具","slug":"小而美-工具","permalink":"http://example.com/categories/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://example.com/tags/blog/"},{"name":"rebuild","slug":"rebuild","permalink":"http://example.com/tags/rebuild/"},{"name":"myself","slug":"myself","permalink":"http://example.com/tags/myself/"}]},{"title":"Review on 轻量级卷积神经网络的设计","slug":"ML/light-framework-for-CNN","date":"2019-11-17T04:54:30.000Z","updated":"2023-07-22T02:19:48.865Z","comments":true,"path":"2019/11/17/ML/light-framework-for-CNN/","link":"","permalink":"http://example.com/2019/11/17/ML/light-framework-for-CNN/","excerpt":"","text":"为什么需要轻量网络？经典backbone网络存在的问题 尽管随着近年来backbone网络的快速发展，由AlexNet到VGG，由VGG到GoogleNet，由GoogleNet到ResNet等等。模型的精度越来越高， 但是通常模型占用内存很大，模型参数很多，这样的话在边缘设备上运行就会很慢。 所以我们需要设计一些参数量更少的网络结构，这样的模型占用内存小，在边缘设备上跑的更快。 怎么解决这个问题1. 网络压缩 2. 轻量网络的设计 本Review只是讨论轻量网络的设计 轻量网络设计的发展历程，我们按照提出的时间可以分为3个版本 （1）Version 1， 【2016-2017】，SqueezeNet–&gt; MobileNet –&gt; ShuffleNet –&gt; Xception （2）Version 2， 【2017-2018】，SqueezeNext–&gt; MobileNetV2 –&gt; ShuffleNetV2 （3）Version 3， 【2018-2019】，AutoShuffleNet–&gt; MobileNetV3 这里我们总结一下5个轻量网络，SqueezeNet，MobileNet，ShuffleNet，MobileNetV2，ShuffleNetV2 SqueezeNet 核心思想a. 用更多的1*1卷积核替代3*3卷积核的使用，因为1*1卷积核可以在保output&#x3D;input的同时减少了通道数b. 在3*3卷积核中用更少的通道数，这样直接减少了模型的参数c. 延迟下采样 模块化卷积fire module fire module包含2个部分：Squeeze Layer和Expend Layer。 Squeeze Layer直接用1*1降低了通道数并保持output&#x3D;input Expend Layer是1*1卷积和3*3卷积的混合使用 实验结果 SqueezeNet的参数比AlexNet少50x，但是模型性能(accuracy)与AlexNet结晶。 MobileNet 核心思想，深度可分离卷积结构 depthwise separable convolution 深度可分离卷积是把一个传统卷积层分解成了2个卷积层，depthwise -wise和point-wise convolutiion. depthwise -wise卷积是单独在通道上做的卷积，是分组卷积中groups&#x3D;channels的极端情况。 point-wise卷积是用1*1卷积核连接通道之间的特征信息。 可以计算参数如下 结构图如下 实验结果 深度可分离卷积实现了和传统卷积相同的输入和输出操作，在保证准确率的条件下，但是计算参数量减少约为原来的1&#x2F;7，计算时间减少约为原来的1&#x2F;9。 MobileNetV2 核心思想，Inverted Residuals &amp; Linear Bottlenecks 首先说一下ResNet中的Residual block的思想，就是在进行3*3卷积之前，插入1*1卷积进行通道数的“压缩”，在3*3卷积之后又插入1*1卷积进行通道数的“扩张”（input~&#x3D;output）。 而Inverted Residuals则是反了过来，先用1*1卷积进行通道数的“扩张”，然后经过3*3的depthwise separable convolution，最后插入1*1卷积进行通道数的“压缩”(input~&#x3D;output). Linear Bottlenecks，original bottlenecks是在卷积层之后做elwise + Relu，而linear bottlenecks则是elwise + withou relu。原因是本来参数量不多的情况下，如果用relu让负半轴为0，那么模型的学习能力就更有限了，所以直接删除relu。 利用stride&#x3D;2的卷积层做下采样。结构图如下 ShuffleNet 核心思想，用1*1Group Conv做channel shuffle。 shuffle unit ShuffleNetV2 核心思想，Time &#x3D; T(FLOPS) + T(I&#x2F;O)。 提出了4个指导原则， a, 当input channel&#x3D;output channel，卷积计算所需的MAC(memory access cost)最为节省。 b, 过多的group convolution操作会加大MAC开销。 c, 网络结构整体的碎片化会减少其可并行优化的程序。 d, Else-wise操作小号的时间较多。 Summary 实践中，首选是ShuffleNet-V2&#x2F;MobileNet-V2，第二选择是MoblileNet ReferencesSqueezeNet https://arxiv.org/abs/1602.07360MobileNet https://arxiv.org/abs/1704.04861ShuffleNet https://arxiv.org/abs/1707.01083MobileNetV2 https://arxiv.org/abs/1801.04381ShuffleNetV2 https://arxiv.org/abs/1807.11164Resnet https://arxiv.org/abs/1512.03385 SqueezeNethttps://zhuanlan.zhihu.com/p/31558773https://blog.csdn.net/csdnldp/article/details/78648543 MobileNethttps://www.cnblogs.com/adong7639/p/7918527.html MobileNetV2https://blog.csdn.net/u011995719/article/details/79135818 ShuffleNetV2https://www.jianshu.com/p/71e32918ea0a https://zhuanlan.zhihu.com/p/35405071","categories":[{"name":"技能-修行-进步-ML","slug":"技能-修行-进步-ML","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-ML/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"light framwork","slug":"light-framwork","permalink":"http://example.com/tags/light-framwork/"},{"name":"convolution","slug":"convolution","permalink":"http://example.com/tags/convolution/"}]},{"title":"pa-prepare","slug":"alogrithms/pa-prepare","date":"2019-09-12T05:26:17.000Z","updated":"2023-07-22T01:38:21.567Z","comments":true,"path":"2019/09/12/alogrithms/pa-prepare/","link":"","permalink":"http://example.com/2019/09/12/alogrithms/pa-prepare/","excerpt":"","text":"数据结构与算法 快排 算法描述 先从序列中取出一个数作为基准数 分区过程, 将比这个数大的数全部放到它的右边, 小于或等于它的数全部放到它的左边 再对左右区间重复第二步, 直到各区间只有一个数 算法时间复杂度分析 $$T(n) &#x3D; 2T(\\frac{n}{2}) + f(n)$$ 假设m次递归后结束，则 $$T(n) &#x3D; 2^{m}T(1)+mn$$ $$n &#x3D; 2^{m}T(1)$$ 由于T(1)是常量，所以 $$n &#x3D; 2^{m}, m &#x3D; log(n)$$ 得到 $$T(n) &#x3D; nT(1) + nlog(n)$$ 因为n&gt;2时，nlog(n) &gt; n，所以快排最优情况下的时间复杂度是 $$O(nlogn)$$ 12345678910111213141516def quick_sort(array, l, r): if l &lt; r: q = partition(array, l, r) quick_sort(array, l, q-1) quick_sort(array, q+1, r)# partition algorithmdef partition(array, l, r): x = array[r] i = l - 1 for j in range(l, r): if array[j] &lt;= x: i += 1 array[i], array[j] = array[j], array[i] array[i+1], array[r] = array[r], array[i+1] return i + 1 二分查找 原数组必须是有序的 123456789101112def binary_search(array, num): left = 0 right = len(array) - 1 while left &lt;= right: mid = (left + right) // 2 if num &lt; array[mid]: right = mid - 1 elif num &gt; array[mid]: left = mid + 1 else: return mid return -1 最大堆和最小堆，一般求无序数组中最大(小)的K个数 计算机视觉图形学基础 图像本身就是一个函数 low-level feature 图片锐化，拉普拉斯 边缘检测，sobel 图片模糊，中值滤波&#x2F;高斯滤波 图像二值化，灰度图 图像resize，插值（临近插值，双线性插值） 机器学习 Logistic regression SVM 首先它是一个二类分类器，核心思想是在特征空间中寻找间隔最大化的分离超平面的线性分类器。 当训练样本线性可分时，通过硬间隔最大化，学习一个线性分类器，即线性可分支持向量机； 当训练数据近似线性可分时，引入松弛变量，通过软间隔最大化，学习一个线性分类器，即线性支持向量机； 当训练数据线性不可分时，通过使用核技巧及软间隔最大化，学习非线性支持向量机。 SVM 核函数之间的区别 一般选择线性核和高斯核，也就是线性核与 RBF 核。 线性核：主要用于线性可分的情形，参数少，速度快，对于一般数据，分类效果已经很理想了。 RBF 核：主要用于线性不可分的情形，参数多，分类结果非常依赖于参数。有很多人是通过训练数据的交叉验证来寻找合适的参数，不过这个过程比较耗时。 如果 Feature 的数量很大，跟样本数量差不多，这时候选用线性核的 SVM。 如果 Feature 的数量比较小，样本数量一般，不算大也不算小，选用高斯核的 SVM。 PCA Kmeans K-means的基本算法流程： 初始化$k$个聚类中心$c1,c2,…,ck$ 对于每个样本$x_i$和每个聚类中心$c_j$，计算样本与聚类中心之间的距离$d_{ij}$ 对于每个样本$x_i$，基于其最小的$d_{ij}$把其分配到第$j$个类$C_j$ 对于每个类$C_j$，计算其所有样本的均值作为新的聚类中心，重复步骤2和步骤3直至样本点所属的类不再变化或达到最大迭代次数 L1和L2 regulation 从参数W更新，即求梯度的角度来看， L1是在原来式子上加多了一个$-\\eta\\frac{\\lambda sgn(W)}{n}$ 上式可知，当w大于0时，更新的参数w变小；当w小于0时，更新的参数w变大；所以，L1正则化容易使参数变为0，即特征稀疏化。 L2是在原来式子上加多了一个$-\\eta\\frac{\\lambda}{n}W$ 上式可知，当w趋向于0时，参数减小的非常缓慢，因此L2正则化使参数减小到很小的范围，但不为0。 L1使权重稀疏，L2使权重平滑，一句话总结就是：L1会趋向于产生少量的特征，而其他的特征都是0，而L2会选择更多的特征，这些特征都会接近于0 深度学习 基础网络 VGG 1*1 多个小卷积代替一个大的卷积 网络更深 Inception 网络更宽 让网络自己选择合适的卷积核 ResNet 解决网络加深时难以训练的问题 skip connection，计算残差 总结： Inception V1——构建了1x1、3x3、5x5的 conv 和3x3的 pooling 的分支网络，同时使用 MLPConv 和全局平均池化，扩宽卷积层网络宽度，增加了网络对尺度的适应性； Inception V2——提出了 Batch Normalization，代替 Dropout 和 LRN，其正则化的效果让大型卷积网络的训练速度加快很多倍，同时收敛后的分类准确率也可以得到大幅提高，同时学习 VGG 使用两个3´3的卷积核代替5´5的卷积核，在降低参数量同时提高网络学习能力； Inception V3——引入了 Factorization，将一个较大的二维卷积拆成两个较小的一维卷积，比如将3´3卷积拆成1´3卷积和3´1卷积，一方面节约了大量参数，加速运算并减轻了过拟合，同时增加了一层非线性扩展模型表达能力，除了在 Inception Module 中使用分支，还在分支中使用了分支（Network In Network In Network）； Inception V4——研究了 Inception Module 结合 Residual Connection，结合 ResNet 可以极大地加速训练，同时极大提升性能，在构建 Inception-ResNet 网络同时，还设计了一个更深更优化的 Inception v4 模型，能达到相媲美的性能。 原文链接 1×1卷积的作用 增加非线性, 实现跨通道的交互和信息整合 进行卷积核通道数的降维和升维 目标检测 RCNN-series Yolo-series SSD 目标检测的一些发展趋势 在目标检测算法中，two stage的算法比one stage在检测小物体上更有效，此说法同意吗，为什么？ 基本上同意这个说法。 要说明这个问题主要从感受野的角度去看，one stage的方法，对于SSD，其采取多个特征图进行分类，但由于依赖网络中比较深的层（特征图），感受野很大，因而小物体检测不准确。同样，对于Yolo，由于在方法设计中就把原图分块，即设定了最后用于判断的特征图尺寸，其感受野也很大，因而对小物体判断也不准确。 相对于one stage方法要求同时分离前景和背景以及做出分类，two stage的方法由于proposal的存在可以先用简单的结构分出前景和背景（此时感受野小，特征图分辨率高），再通过深层网络做进一步分类和精修，提高准确率。 one stage的方法也有针对这个问题进行过优化，SSD增加相对不那么深的特征图层作判断，以减小感受野增加分辨率，但层数不深的特征图的判别能力有限，无法大幅增加准确率；Yolo v3增加了FPN，用多尺度特征来判断，增加了对小物体判别能力；RetinaNet也是one stage方法，用了FPN判别，此处对小物体检测更有效，另外其设计了focal loss的训练方式，此方式可认为把two stage中proposal达到的正负样本平衡以修改损失函数的方式达到类似效果，提高了训练效率和整体的准确率。 MAP，mean average precision Precision &amp; Recall 预测为Positive当中真正是Positivede比例 $$Precision &#x3D; \\frac{TP}{TP+FP}&#x3D;\\frac{TP}{all-detections}$$ 实际为Postivie当中被预测为Positive的比例 $$Recall &#x3D; \\frac{TP}{TP+FN}&#x3D;\\frac{TP}{all-ground-truths}$$ mAP的步骤 对于某个类别$C$，在某一张图片上，首先计算$C$在一张图片上的$Precision$: $$Precision &#x3D; 在一张图片上类别C识别正确的个数（也就是IoU&gt;0.5）&#x2F; 一张图片上类别C的总个数}$$ 依然对于某个类别$C$，可能在多张图片上有该类别，下面计算类别C的AP指数： $$AP &#x3D; 每张图片上的Precision求和 &#x2F; 含有类别C的图片数目$$ 对于整个数据集，存在多个类别$C1、C2、C3$： $$mAP &#x3D; 上一步计算的所有类别的AP和 &#x2F; 总的类别数目$$ 相当于所有类别的AP的平均值","categories":[{"name":"技能-修行-进步","slug":"技能-修行-进步","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5/"}],"tags":[{"name":"interview","slug":"interview","permalink":"http://example.com/tags/interview/"},{"name":"computer vision","slug":"computer-vision","permalink":"http://example.com/tags/computer-vision/"}]},{"title":"物体识别算法-RCN, Fast-RCNN, Faster-RCNN和YOLO","slug":"ML/Object-Detection-algo-RCNN-Fast-RCNN-Faster-RCNN-Yolo","date":"2019-08-27T01:37:35.000Z","updated":"2023-07-22T02:00:44.384Z","comments":true,"path":"2019/08/27/ML/Object-Detection-algo-RCNN-Fast-RCNN-Faster-RCNN-Yolo/","link":"","permalink":"http://example.com/2019/08/27/ML/Object-Detection-algo-RCNN-Fast-RCNN-Faster-RCNN-Yolo/","excerpt":"","text":"Origin link, R-CNN, Fast R-CNN, Faster R-CNN, YOLO — Object Detection Algorithms 简介 计算机视觉是一个交叉学科，(自从CNN发展以来)它已经取得了极大的进步并且无人驾驶汽车已经占据了舞台中心。另一个计算机视觉的组成部分是物体检测。物体识别在姿态预估，车辆识别和无人监控等地方都提升了应用。物体检测算法和分类算法的不同是，我们尝试在图片中利用bounding box来定位出我们感兴趣的物体。另外，你可能在一张图片上不止画出一个bouding box， 你可能会画出多个bouding box来表示我们预先不知道的我们所感兴趣的不同物体。 解决物体检测问题，为什么不能直接建立一个标准的CNN+FC的网络结构呢？主要的原因是输出层的长度是可变的，而不是固定的，因为我们感兴趣的物体出现的次数也是可变的。一个最naive的方法来解决这个问题就是我们从图片上划出大小不同的区域，然后利用CNN来进行分类。而这个方法的难点是物体出现的区域是大小不同的，有着不同的长宽比。所以，你需要选择巨量的区域框，而这是一个指数增长的计算量。所以，像RCNN和YOLO这些算法就被提出用来找到这些区域框，并且是要快速的找到。 RCNN 为了绕过要选择巨量的区域框的问题，Ross Girshick et al ，提出了一个方法，我们利用selective serach这个算法从一张图片上提取出2k个区域框，我们称之为区域候选框。然后，我们就直接对这2k个区域候选框进行分类，而不是像之前的巨量的区域框了。selective serach算法步骤如下：1234Selective search:1. Generate initial sub-segmentation, we generate many candidate regions2. Use greedy algorithm to recursively combine similar regions into larger ones 3. Use the generated regions to produce the final candidate region proposals 想了解更多的selective serach算法，请参考以下链接 。得到的2k个区域候选框会被压缩成一个正方形，然后喂给了CNN网络，它的输出是一个4096维的特征向量。CNN就是一个特征提取器，输出层包含了图片的特征，然后这个特征层就会喂给了SVM用以分类。另外，为了预测候选框上是否存在物体，算法同样预测了4个groud truth的偏移量，一增加bouding box的精度。譬如，给定一个区域候选框，算法可能预测了人的存在，但是那个人的头一半是在候选框之外，所以这个偏移量是用来调整bouding box的。 RCNN的问题 每张图片要训练2k次网络是一个非常耗时的操作 测试的时候每张图片需要花费47秒 selective serach算法是一个固定的算法，所以，这个算法是没有学习的过程的。这样就容易产生一些差的区域候选框 Fast RCNN RCNN相同的作者提出了解决RCNN本身存在的问题的算法， 我们称之为Faster RCNN。这个算法和RCNN有比较多的相同之处，不同的是Faster RCNN不是喂区域候选框给CNN网络，而是直接喂原图片，然后生成一个卷积feature map。从这个卷积feature map中，我们生产候选框，然后压缩成正方形，再利用ROI pooling 处理成固定大小的feature map，然后喂给了全连接层。输出的ROI特征向量，我们利用softmax层来预测候选框中的物体类别和bounding box的偏移量。 Fast RCNN比RCNN快的原因是你不需要每次都喂2k个候选框给CNN网络，进行2k次CNN的操作。而是一张图只进行一次CNN网络的操作，然后得到feature map。 由以上对比图，我们可知fast-rcnn在训练和测试阶段都比rcnn提升了非常多的时间。当你看到fast rcnn的测试时间， 区域候选框的提取成为了fast rcnn的bottlenecks。这就是我们在faster rcnn中需要解决的问题。 Faster RCNN RCNN和Fast RCNN都使用了selective search算法来找出候选框。而selective search是一个非常耗时的过程，这严重影响了算法的性能。所以， Shaoqing Ren et al ，提出了一个物体检测算法，它剔除了selective search算法，而是让网络自己学习找多区域候选框。 和Fast RCNN相似，图片直接喂给CNN网络进行特征提取，得到feature map。然后我们不用selective search来提前候选框，而是利用另一个CNN网络来预测区域候选框。预测的区域候选框之后再通过ROI pooling层，得到输出的特征层，最后在这个特征层上做区域候选框的预测和bounding box的偏移量预测。 由以上图可见到，Faster RCNN比RCNN和Fast RCNN在测试速度方面都提升了非常多。所以，它甚至是可以用到实时的物体检测了。 YOLO-你只需看一次via GIPHY - **RCNN系列**的检测算法都是利用区域来定位图片中的物体。CNN网络并没有看到完整的图片。但是，图片的某些部分是非常有可能存在物体的。YOLO和**RCNN系列**算法有很大的不同。在YOLO当中，单个CNN网络预测了bouding boxes和这些boxes中的物体的类别。 ![yolo](/img/media-od-rcnn-yolo/yolo.png \"yolo\") - **YOLO**算法直接把一张图片分成**SxS**的网格，在每个网格中我们取m个bounding boxes。对每个bounding box，网络输出了类别概率和bounding box的偏移量。bounding boxes满足类别概率大于设定阈值的被用来定位图片中的物体。 - YOLO是比其他检测方法快一个数量级的（达到45/fps）。YOLO的限制是对小物体的识别比较难。譬如，它很男检测到一群鸟。这是由于算法的空间限制。 ### 总结 - 计算机视觉会议每年都收到大量新的新颖的想法，我觉得我们会一步步的利用AI迈向了更好的检测表现。会越来越好。我希望这些你们能够清晰的读懂了这些概念。谢谢！ via GIPHY","categories":[{"name":"技能-修行-进步-ML","slug":"技能-修行-进步-ML","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-ML/"}],"tags":[{"name":"translation","slug":"translation","permalink":"http://example.com/tags/translation/"},{"name":"物体识别","slug":"物体识别","permalink":"http://example.com/tags/%E7%89%A9%E4%BD%93%E8%AF%86%E5%88%AB/"},{"name":"Faster-RCNN","slug":"Faster-RCNN","permalink":"http://example.com/tags/Faster-RCNN/"},{"name":"RCNN","slug":"RCNN","permalink":"http://example.com/tags/RCNN/"},{"name":"YOLO","slug":"YOLO","permalink":"http://example.com/tags/YOLO/"}]},{"title":"simple pyopenpose usage","slug":"ML/simple-pyopenpose-usage","date":"2019-08-01T02:59:47.000Z","updated":"2023-07-22T02:27:24.388Z","comments":true,"path":"2019/08/01/ML/simple-pyopenpose-usage/","link":"","permalink":"http://example.com/2019/08/01/ML/simple-pyopenpose-usage/","excerpt":"","text":"Before last post, the introduction of installation of openpose . For now, as you are a learner of python, so you should learn how to use the python api of openpose. Test your pyopenpose Fisrt way (Recommand)123python&gt;&gt;&gt; import openpose&gt;&gt;&gt; from openpose import pyopenpose as op Second way123python&gt;&gt;&gt; import pyopenpose as op&gt;&gt;&gt; So if that’s OK, then you are OK. Simple Usage of pyopenpose Main Steps Initializing the parameters, refer to include&#x2F;openpose&#x2F;flags.hpp for more parameters Process inputs (images, videos etc.) Get outputs Example, hand detection from image, video or webcam. Remember to set the path of your openpose models 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#!/usr/bin/python3#!--*-- coding:utf-8 --*--#! Author: Tim Chan, motoleisure@gmail.comimport cv2import timeimport os.pathimport sysimport argparseimport numpy as npfrom openpose import pyopenpose as opdef readCap(args): outputFile = &quot;openpose_out_py.mp4&quot; if (args.image): # Open the image file if not os.path.isfile(args.image): print(&quot;Input image file &quot;, args.image, &quot; doesn&#x27;t exist&quot;) sys.exit(1) cap = cv2.VideoCapture(args.image) outputFile = args.image[:-4]+&#x27;_openpose_out_py.jpg&#x27; elif (args.video): # Open the video file if not os.path.isfile(args.video): print(&quot;Input video file &quot;, args.video, &quot; doesn&#x27;t exist&quot;) sys.exit(1) cap = cv2.VideoCapture(args.video) outputFile = args.video[:-4]+&#x27;_openpose_out_py.mp4&#x27; else: # Webcam input cap = cv2.VideoCapture(0) cap.set(3, 720) cap.set(4, 1280) return cap, outputFiledef processing_openpose(args): # Initialize the openpose parameters # Custom Params (refer to include/openpose/flags.hpp for more parameters) params = &#123;&#125; params[&quot;model_folder&quot;] = &quot;/home/ares2/openpose/models&quot; params[&quot;hand&quot;] = True # Starting OpenPose opWrapper = op.WrapperPython() opWrapper.configure(params) opWrapper.start() # cv2 display setups winName = &#x27;Deep learning object detection in OpenCV&#x27; cv2.namedWindow(winName, cv2.WINDOW_NORMAL) cap, outputFile = readCap(args) # Get the video writer initialized to save the output video if (not args.image): vid_writer = cv2.VideoWriter(outputFile, cv2.VideoWriter_fourcc(&#x27;M&#x27;, &#x27;J&#x27;, &#x27;P&#x27;, &#x27;G&#x27;), 30, (round(cap.get(cv2.CAP_PROP_FRAME_WIDTH)), round(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))) while cv2.waitKey(1) &lt; 0: start_time = time.time() # get frame from the video hasFrame, frame = cap.read() # Stop the program if reached end of video if not hasFrame: print(&quot;Done processing !!!&quot;) print(&quot;Output file is stored as &quot;, outputFile) cv2.waitKey(3000) # Release device cap.release() break # openpose input datum = op.Datum() datum.cvInputData = frame opWrapper.emplaceAndPop([datum]) # openpose output frame = datum.cvOutputData end_time = time.time() t = end_time - start_time label = &#x27;Inference time: %.2f ms&#x27; % ( 1.0 / t) cv2.putText(frame, label, (0, 15), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255)) # Write the frame with the detection boxes if (args.image): cv2.imwrite(outputFile, frame.astype(np.uint8)) else: vid_writer.write(frame.astype(np.uint8)) cv2.imshow(winName, frame)if __name__ == &#x27;__main__&#x27;: parser = argparse.ArgumentParser(description=&#x27;Openpose Python API usage example&#x27;) parser.add_argument(&#x27;--image&#x27;, help=&#x27;Path to image file.&#x27;) parser.add_argument(&#x27;--video&#x27;, help=&#x27;Path to video file.&#x27;) args = parser.parse_args() processing_openpose(args) Just have a try and be happy.References Openpose Github Github 项目 - OpenPose Python API V1.5.0","categories":[{"name":"技能-修行-进步-ML","slug":"技能-修行-进步-ML","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-ML/"}],"tags":[{"name":"openpose","slug":"openpose","permalink":"http://example.com/tags/openpose/"},{"name":"pyopenpose","slug":"pyopenpose","permalink":"http://example.com/tags/pyopenpose/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"how_to_install_openpose_in_ubuntu1604","slug":"ML/how-to-install-openpose-in-ubuntu1604","date":"2019-07-02T03:40:16.000Z","updated":"2023-07-22T02:28:59.861Z","comments":true,"path":"2019/07/02/ML/how-to-install-openpose-in-ubuntu1604/","link":"","permalink":"http://example.com/2019/07/02/ML/how-to-install-openpose-in-ubuntu1604/","excerpt":"","text":"reference1 reference2 reference3 Download source from the github1git clone --recursive git@github.com:CMU-Perceptual-Computing-Lab/openpose.git Remember to use the –recursive to download other source Install the cmake-gui12sudo apt-get updatesudo apt-get install cmake-gui Download the models12cd openpose/models/./getModels.sh if it doesn’t work for you, you can try to download them directly BODY_25 - pose_iter_584000.caffemodel COCO - pose_iter_440000.caffemodel MPI - pose_iter_160000.caffemodel Face - pose_iter_116000.caffemodel Hand - pose_iter_102000.caffemodel Complie First you should have caffe&amp; OpenCV installed in your PC Open the cmake-gui and fill the source code and build path Click the configure and choose the default button Then set up your path of Caffe and click the Configure button, after that, click the Generate button When you see the Generating Done, you should do this 12cd buildmake -j `nproc` caffe issue If you install the latest caffe, you may occur the problem like that 1can&#x27;t read the caffemodel or parase the model files It may be two reasons caffe issue. the model file is broken, you can try to download it again. So if it’s the caffe issue, you can download the caffe from openpose github and complie it alone. Some issues You may occur some issues like these 123456789SOLVED BY MUUPAN!You need to generate caffe.pb.h manually using protoc as follows.In the directory you installed Caffe toprotoc src/caffe/proto/caffe.proto --cpp_out=.mkdir include/caffe/protomv src/caffe/proto/caffe.pb.h include/caffe/proto After that you complie again, you may incur the other issue about the version of protoc1/home/visionml/caffe-master/include/caffe/proto/caffe.pb.h:12:2: error: #error This file was generated by a newer version of protoc which is You could try the older version of protoc Python API complie12cd build/python/sudo make install -j `nproc` Add path to bash Fisrt way (Recommand)123vim ~/.bashrc# (Add this line to the end of the file)export PYTHONPATH=/path/to/openpose/build/python: Second way12345678910a. After a successful build, go look for the file - build/python/openpose/pyopenpose.cpython-35m-x86_64-linux-gnu.so and copy to /usr/local/lib/python3.5/dist-packagesb. in /usr/local/lib/python3.6/dist-packages I create a symbolic link -- sudo ln -s pyopenpose.cpython-35m-x86_64-linux-gnu.so pyopenposec. Verify that your LD_LIBRARY_PATH from env has the entry /usr/local/lib/python3.5/dist-packagesd. Now, go to build/examples/tutorial_api_python and do some modification to 1_body_from_image.pyi) look for the line from openpose import pyopenpose as op and change to import pyopenpose as op Try a test of python Fisrt way (Recommand)123python&gt;&gt;&gt; import openpose&gt;&gt;&gt; from openpose import pyopenpose as op Second way123python&gt;&gt;&gt; import pyopenpose as op&gt;&gt;&gt;","categories":[{"name":"技能-修行-进步-ML","slug":"技能-修行-进步-ML","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-ML/"}],"tags":[{"name":"openpose","slug":"openpose","permalink":"http://example.com/tags/openpose/"}]},{"title":"可视化证明：神经网络可以计算任何函数","slug":"ML/visual-proof-of-neural-networks","date":"2017-06-14T09:49:20.000Z","updated":"2023-07-22T01:36:25.175Z","comments":true,"path":"2017/06/14/ML/visual-proof-of-neural-networks/","link":"","permalink":"http://example.com/2017/06/14/ML/visual-proof-of-neural-networks/","excerpt":"","text":"Original Post 神经网络当中一个最显著的事实是：神经网络能够计算任何的函数。也就是说，假如有人给你一个复杂的，波形弯弯曲曲的函数，$f(x):$ 无论是什么的函数，我们都可以保证能找到一个网络，对于所有可能的输入，$x$，$f(x)$的值(或者其他的逼近)就是网络的输出，譬如： 这个网络即使是网络的输入很多的时候也是成立的。$f&#x3D;f(x_1,…,x_m)$，然后还有很多的输出。譬如，以下就是一个网络，计算的函数，输入$m&#x3D;3$和输出$n&#x3D;2$： 以上的网络告诉我们神经网络是有一种泛化性的。无论我们想要计算任何的函数，肯定存在一个网络可以满足我们的需求。 另外，更进一步，即使这个网络限制到只有一层隐含层，这个泛化理论也是成立的。这个网络就是所谓的单层隐含层。所以，即使是很简单的网络也是很厉害的。 搞神经网络的人都应该熟知这个泛化性理论，可是事实上它并没有让很多人能理解。大多数的解释都是偏技术性的。譬如，其中一篇原始的论文利用$Hahn-Banach$理论，$Riesz Representation$理论和一些傅里叶分析来证明这个泛化性理论。如果你不是一个数学家的话，你很难读懂里面的解释。很遗憾，这样很多人就很难懂这个泛化性理论了。但是其实背后的原理是非常简单和美好的。 在本章中，我会给出一个关于泛化性理论的简单的和非常可视化的解释。我们会循序渐进，一步一步来理解这个idea。你将会明白为什么神经网络能够计算任意的函数。你也会理解到这个理论的一些限制的地方。你会理解到这个理论和深度学习之间的关系。 要理解这章的内容，你并不需要读前面的内容。反而这一章是一个结构乐见和完整的文章。我会给你们讲一些神经网络的基本知识，这样你们会更容易看懂解释。我会提供一些临时的链接，以防填补你某一部分知识的缺口。 泛化性理论是计算机科学中一个老生常谈的东西，以至于我们有时候都忘记了它到底有多厉害了。但是我们应该时刻提醒自己：有能力去计算任意的函数真的是一件很厉害的事情。几乎你可以想象得到的任何进程都可以被认为是一个函数的计算。譬如，根据一些短的音乐片段去给一段音乐命名。这也是看作计算一个函数。又或者把中文翻译成英文，又或者给计算机一个mp4视频资料，它会生成一个关于视频的描绘图还有这个视频的拍摄质量。泛化性意味着，原则上，神经网络可以做任何的事情而且更多。 当然，仅仅因为我们知道存在一个网络能够把中文翻译成英文，那不意味着我们就很容易构造甚至识别出这个网络。这样的约束对于模型的传统的泛化性理论，譬如布尔回路，都是适用的。但是，像这本书前面所说的，神经网络对于学习函数有非常强的算法。学习算法和泛化性是一个绝妙的结合。直到现在，这本书还是关注在学习算法。在这一章，我们关注在泛化性理论，和它所代表的意思。 两个说明 在我们解释为什么泛化性理论成立之前，我想要提两个关于“一个神经网络能够计算任何的函数”的说明。 首先，并不是说一个神经网络被用来准确地计算任何的函数。而是，我们能够得到一个关于这个函数的一个很好的逼近。通过增加隐层神经元的个数，我们可以不断改进逼近的程度。譬如，前面我们谈到的神经网络，包含一个隐层。对于很多函数，只有3个隐层神经元的神经网络是一个并不好的逼近。通过增加隐层的神经元(假如，增加到5)，我们可以得到更好的逼近： 如果我们继续增加神经元的个数，这个逼近就能做得更好。 更精确的说，假如给定我们一个函数$f(x)$，我们想要计算它的误差$\\epsilon &gt; 0$。只要我们增加足够的隐层神经元，我们就能找到一个神经网络，它的输出$g(x)$满足$g(x)-f(x) &lt; \\epsilon$,对于所有的输入$x$。换句话说，这个逼近函数$g(x)$对于所有可能的输入都在可预计的准确度范围之内。 第二个说明是能够用逼近的方式的函数类型是连续函数。如果一个函数是不连续的，譬如，突然断开的，或者跳动的函数，然后是没法用神经网络来进行逼近的。这并没有什么奇怪的，因为我们的网络计算输入的连续函数。然而，即使我们想要计算不连续的函数，但是利用连续的逼近来的效果更好。既然这样，那么我们就可以用神经网络。实际上，这并不是一个很重要的限制。 总结一下，关于泛化性理论的一个精确的说法是一个单隐层的神经网络能够用来逼近任何的连续函数到任何想要的精度。在本章中，我们实际上证明了一个微弱版本的理论，用两个隐层的神经网络代替单隐层的神经网络。在以下的我们将要解释的问题中，利用一些小技巧，适合的给出了单隐层的神经网络的证明。 一个输入和一个输出的泛化理论 要理解为什么泛化性理论是可行的，让我们从理解如何构造一个能够逼近函数的只包含一个输入和一个输出的神经网络说起： 其实最简单的神经网络(包含一个输入和一个输出)就是泛化性理论的核心。一旦我们能够理解这个简单的网络，那么我们也很容易扩展到其他的(包含多个输入和输出)复杂网络了。 想要深入理解如果构造能够计算函数$f$的网络，我们先来构造一个简单的神经网络，包含单个输入，一个包含2个神经元的隐层，单个输出的神经网络： 为了感受一下神经网络中的组件是如何工作的，让我们先看上面的隐层神经元。在下面的图中，用鼠标点击然后拖动来改变权重$w$的值。你就可以立刻看到右边的函数图是如何变化的(原网页才能操作)： 本书的前面讲过，$\\sigma(wx+b)$是怎么计算的，其中$\\sigma(z)&#x3D;1&#x2F;(1+e^{-z})$就是sigmoid函数。到现在，我们一直频繁的使用这种代数形式进行计算。但是要证明泛化性理论，我们应该忽视这种数学形式，然后通过通过操作和观察以上的图来获得更深的理解。 要开始证明这个理论，请试着用鼠标点击偏置$b$，然后往右拉来增加它的数值。你会看到增加偏置$b$只会把图像往左移动，而不会改变图像的形状。 接下来，你试着鼠标往左拉，偏置$b$的数值减小，你会看到图像是往右边移动的，同样的，图像的形状并没有改变。 然后，我们来改变权重$w$的数值，把它的值改变到2或者3。你会看到减小权重$w$，曲线变得更宽了。你可能需要同时改变一下偏置$b$，以免图像跑出了框内。 最后，把权重$w$的数值增加到100。你会发现，曲线变得更陡峭了，直到它看起来像一个step函数。可以观察一下下面的小视频： 我们可以通过增加权重$w$直到它变成了一个step函数(逼近的精度越来越高)来简化我们的分析。下面右边的图像是当$w&#x3D;999$时的函数图。 其实step函数比一般的sigmoid函数表现更好。原因是输出层是前面所有的隐层的神经元计算来决定的。去分析一堆step函数的总和是件更容易的事，但是去分析一堆sigmoid函数的曲线计算后的结果就不是一件易事了。而且，把隐层的神经元输出step函数是一件更容易的事情。更确切的说，我们把权重$w$的值调得非常大，这样就可以得到了step函数了。然后通过调整偏置$b$来改变step(跃阶)的位置。当然，把输出当成一个step函数也是一种逼近，而且是一个很好的逼近，而现在我们正是这样做的。我稍后会再讨论这种逼近的求导的影响。 当$x$的数值是多少时达到跃阶(step)呢？换一种说法，step的位置是如何由权重$w$和偏置$b$来决定的？ 要回答这个问题，我们再来试一下改变权重$w$和偏置$b$的数值。你可以弄清楚跃阶(step)和权重$w$与偏置$b$的关系吗？通过不断的观察图像的变化，你可能就会发现，跃阶(step)的位置是和偏置$b$成正比的，和权重$w$成反比的。 事实上，跃阶(step)的位置$s$满足$s&#x3D;-b&#x2F;w$. 这会大大简化了我们的生活，如果我们只是单单利用一个参数$s$来描述隐层的神经元的话。$s$就是跃阶(step)的位置，$s&#x3D;-b&#x2F;w$。 上面有提到，我们可以偷偷地把输入的权重$w$调到非常大，大到出来的step函数是一个很好的逼近。我们就可以很容易的在传统的模型当中把神经元参数按这样子来调整，偏置$b&#x3D;-ws$. 以上我们都是讨论上层神经元。现在我们来讨论一下整个网络。我们假设上层神经元通过step函数参数化跃阶(step)为$s_1$，下层神经元通过step函数参数化跃阶(step)为$s_2$.他们分别有输出权重$w_1$和$w_2$。以下就是网络： 右上方的图像是输出权重$(w_1a_1+w_2a_2)$的结果。其中$a_1$和$a_2$分别是上层神经元和下层神经元的输出。输出用$a$来表示是因为神经元通常包含一个激活函数(activation)。 让我们来看一下$s_1$和$s_2$相遇时会发生什么情况呢？看图： 可以看到，当我们操作$s_1$时，$S_1$和$s_2$相遇时，$S_1$就会带动$s_2$走。所以，图像的变动，我们也要分是$s_1$先动还是$s_2$先动。 $h_t$","categories":[{"name":"技能-修行-进步-ML","slug":"技能-修行-进步-ML","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-ML/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"可视化证明","slug":"可视化证明","permalink":"http://example.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96%E8%AF%81%E6%98%8E/"}]},{"title":"排序算法总结","slug":"alogrithms/sort-algorithms","date":"2017-05-06T11:41:47.000Z","updated":"2023-07-22T02:16:08.665Z","comments":true,"path":"2017/05/06/alogrithms/sort-algorithms/","link":"","permalink":"http://example.com/2017/05/06/alogrithms/sort-algorithms/","excerpt":"","text":"排序算法是一个非常重要而且在日常生活中最常用的一种算法之一。面试官往往也是会常考的题目。所以，以下对排序算法做一下总结，而且排序顺序都是由小到大。 冒泡排序(Bubble Sort) 核心思想：按从小到大的排序，前面一个数和后面一个数比较，大的永远靠后，每次可以确定一个最大的数排到了最后，然后下次比较就可以忽略这个排好的数。 伪代码 do swapped = false for i = 1 to indexOfLastUnsortedElement if leftElement > rightElement swap(leftElement, rightElement) swap = true while swapped GIF process Python code123456789101112def bubbleSort(alist): for passnum in range(len(alist)-1,0,-1): #print alist,passnum for i in range(passnum): if alist[i]&gt;alist[i+1]: temp = alist[i] alist[i] = alist[i+1] alist[i+1] = temp return alistalist = [54,26,93,17,77,31,44,55,20] print(bubbleSort(alist)) 选择排序(Select Sort) 核心思想：从左往右，设还没排序的数中的第一个数为最小的数(minimum)，并且记住最小数(minimum)的下标(index)，然后和它后面的所有数进行比较，如果发现有更小的数，就更新下标，比完一轮之后，如果下标有改变，就把下标位置上的数和第一个数进行交换，那么这个数就是已排序的了，往下移一个位置继续以上的动作，直到最后要给数为止。 伪代码 repeat (numOfElements - 1) times set the first unsorted element as the minimum for each of the unsorted elements if element < currentMinimum set element as new minimum swap minimum with first unsorted position GIF proce Python code12345678910111213def selectionSort(alist): for i in range(len(alist)-1): minimun = i for j in range(i, len(alist)): if alist[j]&lt;alist[minimun]: minimun = j temp = alist[i] alist[i] = alist[minimun] alist[minimun] = temp return alistalist = [54,26,93,17,77,31,44,55,20] print(selectionSort(alist)) 快速排序(Quick sort) 核心思想： 选定一个基准值(pivot) 将比基准值(pivot)小的数移到它的左边，形成左子序列 将比基准值(pivot)大的数移到它的右边，形成右子序列 分别对左子序列、右子序列作上述三个步骤,直到左子序列和右子序列都只剩一个数为止&#x3D;&#x3D;》 递归(Recursive) 伪代码： for each (unsorted) partition set first element as pivot storeIndex = pivotIndex + 1 for i = pivotIndex + 1 to rightmostIndex if element[i] < element[pivot] swap(i, storeIndex); storeIndex++ swap(pivot, storeIndex - 1) GIF process Python code1234567891011121314151617181920212223242526272829def quickSort(arr, left, right): # 只有left &lt; right 排序 if left &lt; right: pivot_index = partition(arr, left, right) quickSort(arr, left, pivot_index - 1) quickSort(arr, pivot_index + 1, right)def partition(arr, left, right): &quot;&quot;&quot;找到基准位置, 并返回&quot;&quot;&quot; pivot_index = left pivot = arr[left] for i in range(left + 1, right + 1): if arr[i] &lt; pivot: # 如果此处索引的值小于基准值, 基准值的位置后移一位 # 并将后移一位的值和这个值交换, 让基准位置及之前的始终小于基准值 pivot_index += 1 if pivot_index != i: arr[pivot_index], arr[i] = arr[i], arr[pivot_index] # 将基准值移动到正确的位置 arr[left], arr[pivot_index] = arr[pivot_index], arr[left] return pivot_indexalist = [54,26,93,17,77,31,44,55,20] quickSort(alist, 0, len(alist)-1) print(alist) 插入排序(Insert sort) 核心思想：在已排序的数中插入一个未排序的数。 伪代码 mark first element as sorted for each unsorted element 'extract' the element for i = lastSortedIndex to 0 if currentSortedElement > extractedElement move sorted element to the right by 1 else: insert extracted element GIF process Python code1234567891011def insertSort(a): for i in range(len(a)-1): #print a,i for j in range(i+1,len(a)): if a[i]&gt;a[j]: temp = a[i] a[i] = a[j] a[j] = temp return aalist = [54,26,93,17,77,31,44,55,20] print(insertSort(alist)) 归并排序 核心思想：把原始数组分成若干子数组,对每一个子数组进行排序,继续把子数组与子数组合并,合并后仍然有序,直到全部合并完,形成有序的数组 伪代码： split each element into partitions of size 1 recursively merge adjancent partitions for i = leftPartStartIndex to rightPartLastIndex inclusive if leftPartHeadValue","categories":[{"name":"技能-修行-进步","slug":"技能-修行-进步","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"循环神经网络 Part 1-简介","slug":"ML/RNN-tutorial-Part-1-Introduction","date":"2017-03-29T13:02:30.000Z","updated":"2023-07-16T01:44:09.384Z","comments":true,"path":"2017/03/29/ML/RNN-tutorial-Part-1-Introduction/","link":"","permalink":"http://example.com/2017/03/29/ML/RNN-tutorial-Part-1-Introduction/","excerpt":"","text":"本文翻自WILDML 循环神经网络(RNNs)是一个目前在许多的自然语言处理(NLP)任务当中表现了出色的性能的模型。但是，除了它最近的火热之外，我能找到的关于RNNs模型的工作原理和实现的资源非常的有限。所以我才着手写了这个tutorial。我分了几个部分来写RNN的tutorial： RNNs简介(本tutorial) 用Python和Theano实现RNN 理解定时后向传播算法和梯度消失的问题 实现一个GRU&#x2F;LSTM RNN 在本tutorial中我们实现了一个基于语言模型的RNN。这个语言模型应用包括两个部分：第一，它允许我们对一个可能出现在现实当中的抽象句子做一个评分，这个分数可以用来评判句子的语法和语义的准确性。这样的模型是典型的机器翻译系统当中的一个部分。第二，一个语言模型允许我们生成一个新的文本(我认为这是一个非常cool的应用)。在Shakespeare(莎士比亚)文章上训练一个语言模型，它可以生成一个新的类莎士比亚的文本。Andrej Karpathy写的贴子很好地阐明了基于RNN的字符level的语言模型能够干什么。 我假设你们对于基本的神经网络都熟悉了。如果你们并不熟悉的话，你可以先去看一下这个贴子,从零开始实现一个神经网络，它会指导你非RNN背后神经网络的思想和实现。 什么是RNNs? RNN的核心思想是利用序列信息。在传统的神经网络中，我们假设所有的inputs和outputs都是彼此独立的。但是在很多的任务当中，这是一个非常不合理的想法。如果你想预测一个句子当中的下一个单词，你最好能知道它前面跟着的是什么单词。RNNs当中的”recurrent”，递归，是因为它对于序列当中的每一个元素都执行了同样的任务，当前的output和之前的计算有依赖关系。RNNs的另一种理解就是它有一个“记忆体”记住了到目前为止所计算的信息。理论上RNNs能够利用任意长序列上的信息，但是实际上它们只是局限于能回看前面几步上的信息(以后会更多)。这就是一个典型的RNN模型图： 上面这张图就是RNN展开成全连接的网络图。展开的意思就是我们把所有的序列写出来。譬如，如果我们关注的序列是包含5个单词的，那么展开的网络图就是5层的网络，每一层对应一个单词。图中的公式参数意义如下： $x_t$是在时间$t$时的输入。譬如，$x_1$可以是序列中对应到第二个单词的one_hot向量。($X_0$是第一个) $s_t$是在时间$t$时的隐层状态。它是网络的“记忆体”。$s_t$是基于前一个隐层状态和当前的输入计算出来的: 这个函数f通常是一个非线性函数，如tanh或者ReLU。$s_{-1}$是用来计算第一个隐层的，通常初始化为全0。 $o_t$是在步骤$t$时的输出。譬如，如果我们想去预测句子当中的下一个单词，结果会是一个概率向量，它对应着我们字典中的每一个单词。$o_t&#x3D;softmax(V*s_t)$ 以下是一些我们需要注意的地方： 你可以把$s_t$看作是网络的记忆体。$s_t$捕获了前一步所发生的信息。输出$o_t$是单独基于时间$t$时的记忆算出来的。像以上简单提到的，实际上它有点复杂，因为$s_t$一般不能够捕获太多次之前的信息。 不想传统的深度学习网络，每一层都用了不同的参数，RNN当中的每一层是共享一组参数的($U,V,W$)。这也说明了我们每一层都是做了相同的操作的，只是每次的inputs不同了。这就大大减少了我们要学习的参数的数量。 上面的图当中每一层都有一个输出，但是有些任务当中这些输出并不是必须的。譬如，在做句子的情感分析当中，我们可能就是需要最后一个输出而已，而不是每一层的outputs。简单来说，我们不是每一层都需要输入。RNN的主要特点是它的的隐层状态，它捕获了序列当中的一些信息。 RNN能够干什么？ RNN在许多的自然语言处理(NLP)任务中当中获得非常好的结果。这里我不得不提到的一个常用到的RNN模型就是LSTMs。相比普通的RNN模型，它能更好的捕获到长期的依赖信息。但是不要担心，LSTMs也是我们这个tutorial中的RNN差不多，只是它的隐层状态的计算会有所不同。我们会在下一个贴子当中详解LSTMs。这里我们只是列举一些RNN在NLP当中应用的例子。 语言建模和生成文本 给定一个序列的单词，我们要预测当给定前一个单词时，下一个单词会出现的概率。语言模型会让我们评判一个什么序列的单词如何才可能是一个句子。这也是机器翻译当中的一个重要的输入(通常概率高的句子都是正确的)。预测下一个单词的另一个作用是我们会得到一个生成模型，这个模型可以通过从输出概率当中进行采样来生成新的文本。利用我们的训练数据，我们可以生成各种各样的单词序列。在语言模型当中，我们的输入通常是一个单词的序列(譬如加密成一个one-hot向量)，然后我们的输出就是预测的单词的序列。当我们训练网络时，我们把$o_t&#x3D;x_{t+1}$，因为我们希望时间$t$时的输出是真实的下一个单词。 语言模型和生成文本的相关论文： Recurrent neural network based language model Extensions of Recurrent neural network based language model Generating Text with Recurrent Neural Networks 机器翻译 机器模型和语言模型非常的相似，它的输入也是一种语种的单词序列(譬如德语)。我们想要输出的是目标语种的单词序列(譬如英语)。一个主要的不同就是我们的输出是当所有的输入都计算过了才开始的，因为我们翻译的句子中的第一个单词是需要所有的输入序列的信息才能确定的。 机器翻译的相关论文： A Recursive Recurrent Neural Network for Statistical Machine Translation Sequence to Sequence Learning with Neural Networks Joint Language and Translation Modeling with Recurrent Neural Networks 语音识别 给定一个从声波中得到的声学信号的输入序列，我们能够利用它们的概率来预测一个序列的语音片段。 语音识别的相关论文： Towards End-to-End Speech Recognition with Recurrent Neural Networks 生成图片描述 结合卷积神经网络(CNN)和RNN的模型能够对没标签的图片生成描述。这是一个非常惊人的工作。这个组合模型还能把图片当中找到的特征和生成的单词一一对应。 训练RNNs 训练RNN和训练传统的神经网络很相似。我们也用到后向传播(backpropagtion)算法，但是有小小不同。因为参数在整个网络中的每一层是共享的，而每一层输出的梯度不仅仅依赖于当前这一步的计算，还依赖前一步的计算。譬如，为了计算$t&#x3D;4$时的梯度，我们需要往后传播3层，并且把它们的梯度加起来。这就是定时后向传播(BPTT)。如果这还是没有那么清晰的话，不要担心，我们之后还会有更多的详情。现在，我们要注意到用BPTT来训练普通的RNNs，因为梯度消失的问题，所以很难学习到长期的依赖信息(譬如，每一层之间的信息相差甚远)。但还是有一些模型来解决这个问题的，像特定的RNNs模型(LSTMs)就是特别设计用来解决这些问题的。 RNNs扩展 经过研究者们那么多年的研究，他们已经发展了更为复杂的RNNs模型来解决普通的RNN模型的一些不足。我们接下来的贴子会讲到更多的细节，但是我想在本部分中做一个简单的总结，这样我们才能对RNNs模型的分类更为熟悉。 **双向RNNs(Bidirectional RNNs)**就是基于这样的思想：时间$t$的输出可能不仅仅依赖鱼序列当中的前面的元素，还包括了未来的元素。譬如，预测一个序列当中的缺失的单词，你可能要看到前面和后边的内容。双向RNNs非常容易。他们就是把两个RNNs堆叠在一起。输出是基于两个RNNs模型的隐层计算得到的。 深度(Bidirectional)RNNs和双向RNNs很相似，就是我们现在每一个时间点有多层。实际上这给了我们一个更高的学习容量(但是我们也需要大量的训练数据)。 LSTM网络现在非常流行。LSTMs和RNNs在架构上没什么大的不同，但是它们利用了不同的函数来计算隐层状态。LSTMs中的记忆体叫做cells，你可以把它们当成一个黑盒子，它吃进了前一个状态$h_{t-1}$和当前的输入$x_t$。这些cells内部决定哪些应该保持，哪些应该删除。然后它们就会合并前一个状态，当前状态和当前的输入。结果证明了这类型的units非常有效地捕获了长期的依赖信息。LSTMs一开始可能很疑惑，但是如果你感兴趣的话，可以读一下这篇详细的解释。 总结 目前还是理解的不错的。我希望你现在对RNNs已有了一个基本的理解。在下一个贴子中我们会利用Python和Theano实现我们RNN语言模型的第一个版本，请在留言区留下你的问题。","categories":[{"name":"技能-修行-进步","slug":"技能-修行-进步","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"循环神经网络","slug":"循环神经网络","permalink":"http://example.com/tags/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]},{"title":"how to use git quickly part 2","slug":"小而美-工具/how-to-use-git-quickly-part2","date":"2017-03-02T06:55:59.000Z","updated":"2024-03-16T15:23:02.007Z","comments":true,"path":"2017/03/02/小而美-工具/how-to-use-git-quickly-part2/","link":"","permalink":"http://example.com/2017/03/02/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/how-to-use-git-quickly-part2/","excerpt":"","text":"One simple example to push your code to your github account After you’re done with Part 1 , Let’s practice now. Create a new repository in your github Just log into your github account and create a new repository Clone the repository to local After that, you go to the new repository page to copy the SSH or HTTPS url to clone the repository into local Then go back to git bash and type git clone url The repository is in your local destination now. Edit your code on local Like you can add a new python script Push your code to github Add the code into buffering1$ git add . Notice there is a dot in the end of the command. It means add all things into the buffer. And there is a frequently-used command git status. It can check the status of your local repository now. Now commit your buffer1$ git commit -m &quot;first commit&quot; -m means the message you can record here. Now you can push your code into your github now1$ git push origin main And you can see the response message like this That means you push your local code into your github repository. And you can you can check your websit repository right now. Congratulations ! You finished the simple use of git and github. Try to play it to get more fun yourself, good luck!!!","categories":[{"name":"小而美-工具","slug":"小而美-工具","permalink":"http://example.com/categories/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"}]},{"title":"how to use git quickly Part 1","slug":"小而美-工具/how-to-use-git-quickly-part1","date":"2017-03-02T04:34:23.000Z","updated":"2024-03-16T15:22:56.711Z","comments":true,"path":"2017/03/02/小而美-工具/how-to-use-git-quickly-part1/","link":"","permalink":"http://example.com/2017/03/02/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/how-to-use-git-quickly-part1/","excerpt":"","text":"Suppose you are new to git and github and you want to use it quickly. This is the situation I write this post. Get a free account of github, that’s easy for you guys. Install the git on Windows or Linux, that’s easy too. Then I use the Ubuntu as an example. configure your git local After you install git, open git bash and configure you git, like your user name and email of your github account.git official tutorial12$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com Generating a new SSH key Then get your local ssh key and copy it to your github account, git official tutorial1$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; This creates a new ssh key, using the provided email as a label.1Generating public/private rsa key pair. When you’re prompted to “Enter a file in which to save the key,” press Enter. This accepts the default file location.1Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] At the prompt, type a secure passphrase. And if you want to skip the password, just press Enter twice and it will be done.12Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] Adding your SSH key to the ssh-agent After you generate your ssh key, go to the destination and open the id_rsa.pub and copy the contents like this: Then log in your github account and find the setting part And then from the left menu to find the SSH and GPG Keys Click the right button and add new ssh key You will be asked add the title and ssh key Testing your ssh connection with github Now go back to your git bash, and type into 1ssh -T git@github.com You will get the response like this That means you connect to your github successfully! Congratuations! Next step Since you have configured your git and github, let’s do a simple practice now. Go to Part2 how to use git quickly part 2","categories":[{"name":"小而美-工具","slug":"小而美-工具","permalink":"http://example.com/categories/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"}]},{"title":"什么是神经网络？","slug":"ML/03-what-is-neural-network","date":"2017-02-21T09:39:55.000Z","updated":"2023-07-22T02:30:46.419Z","comments":true,"path":"2017/02/21/ML/03-what-is-neural-network/","link":"","permalink":"http://example.com/2017/02/21/ML/03-what-is-neural-network/","excerpt":"","text":"为什么需要神经网络？ 神经网络原本是生物学当中的知识。如上图所示，就是一个神经网络的放大图，在图中我们可以看到好几个大的节点，生物术语叫做神经元，而神经元之间可以看到连接着小的神经线。这就如同一个图的结构一样，包含了节点和连接节点的边。那么不同的神经元是有不同的功能的，而神经线(非专业术语)可以给不同的神经元传递信息。这样的一个神经网络可以完成很多不同的功能，如我们的大脑一样，我们的大脑遍布着神经网络，而我们的大脑是我们身体的控制中心，实现了非常多的功能。 所以在机器学习当中为什么需要机器学习呢？因为机器学习当中现时的模型简单，有时候解决不了复杂的问题。所以为了对付复杂的模式，就用到了神经网络。 神经网络的架构 一般的神经网络架构是包含输入层(input layer)，隐藏层(hidden layer)和输出层(output layer)。 神经网络的计算 那么神经网络是如何计算的呢？在神经网络中，神经元都是有功能的，我们称之为激活函数，当input输入网络时，会经过神经元，神经元会通过激活函数判断当前的输入是否应该激活，如果激活了就会进入下一层，如果没有激活，那么这个input就不会进入到下一层了。同样的input输入到不同的节点时得到的结果不一样，是因为节点上的激活函数不同，激活函数不同也就是weighs和bias不同。 当input到达输出层时会得到一个预测值，神经网络通过比较预测值和实际值的误差，并不断地调整节点的weights和bias，从而使得预测值和实际值之间的误差越来越小，预测效果会越来越好，这个过程就叫做training。 最简单的神经网络-感知器(Perceptron) 感知器是一个简单的二类分类模型，也是最简单的神经网络结构。它是由心理学家Frank Rosenblatt于1957年提出的。它的结构模型如下： 它就是一个简单的输入层和输出层。输入的每个样本会有两个feature，x1和x2。x1和x2对应的权重是w1和w2。中间的f函数是一个点乘函数，就是f(X) &#x3D; x1 * w1 + x2 * w2。然后接着的是一个阈值函数，也可以叫做分段函数。只要函数值大于预定的阈值，那么就会输出1，相反，就会输出-1。这就实现了一个二类分类器。 感知器是一个简单的二分类的分类器，但是它只能解决线性问题。什么是线性问题呢？就是用一个条直线就能划分的问题。那么，像我们学过的“逻辑与”与“逻辑或”这样的线性问题是怎么用感知器来实现的呢？ 感知器实现“逻辑与”(AND)和“逻辑或”(OR) 我们先来看一下“逻辑与”的真值表和它的函数图吧： 然后“逻辑或”的真值表和它的函数图： 那么感知器是如何解决线性问题的呢？上面我们提到的一个阈值函数，假设我们的阈值为T，那么函数的定义可以写成： 所以划分分类的直线就是：","categories":[{"name":"技能-修行-进步-ML","slug":"技能-修行-进步-ML","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-ML/"}],"tags":[{"name":"Tensorflow tutorial","slug":"Tensorflow-tutorial","permalink":"http://example.com/tags/Tensorflow-tutorial/"},{"name":"ML","slug":"ML","permalink":"http://example.com/tags/ML/"},{"name":"DL","slug":"DL","permalink":"http://example.com/tags/DL/"}]},{"title":"KNN Example 01 To predict the cancer of breast cancer","slug":"技能-修行-进步-R语言/KNN-example01-breast-cancer-predict","date":"2017-02-15T05:44:32.000Z","updated":"2023-07-22T02:19:01.546Z","comments":true,"path":"2017/02/15/技能-修行-进步-R语言/KNN-example01-breast-cancer-predict/","link":"","permalink":"http://example.com/2017/02/15/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-R%E8%AF%AD%E8%A8%80/KNN-example01-breast-cancer-predict/","excerpt":"","text":"Set the path12setwd(&quot;D:/git-ware/machine-learning-R-examples/01_KNN&quot;)getwd() Get the data from the Internet and do the explorationDownload the data from Internet Data: https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/wdbc.data Description: https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/wdbc.names 1234567891011121314151617# download the data from the Internetlibrary(RCurl)data_url = &quot;https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/wdbc.data&quot;name_url = &quot;https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/wdbc.names&quot;download.file(data_url, &quot;wdbc.data&quot;, method=&quot;libcurl&quot;)download.file(name_url, &quot;wdbc.names&quot;, method = &quot;libcurl&quot;)# loading datasetwdbc = read.csv(&quot;wdbc.data&quot;, header = FALSE)# set the column names wdbc.names=c(&quot;Radius&quot;,&quot;Texture&quot;,&quot;Perimeter&quot;,&quot;Area&quot;,&quot;Smoothness&quot;,&quot;Compactness&quot;,&quot;Concavity&quot;,&quot;Concave points&quot;,&quot;Symmetry&quot;,&quot;Fractal dimension&quot;)wdbc.names=c(wdbc.names,paste(wdbc.names,&quot;_mean&quot;,sep=&quot;&quot;),paste(wdbc.names,&quot;_worst&quot;,sep=&quot;&quot;))names(wdbc)=c(&quot;id&quot;,&quot;diagnosis&quot;,wdbc.names)str(wdbc)dim(wdbc) So from the output above, we can see that the dataset includes 569 samples and 32 features. From the description file, we know that the first feature(column) is id, and the second feature(column) is the diagnosis, it has two labels: “B” is benign cancer, and the “M” means malignant cancer. And the rest are the features which include the means, standard error and maximum, etc. We explore the ratio of two labels 1table(wdbc$diagnosis) We see that the dataset has 357 benign cancer and 212 malignant cancer. Since the id column has no significance to the model, so we delete the it 123wdbc$diagnosis=factor(wdbc$diagnosis,levels=c(&quot;B&quot;,&quot;M&quot;),labels=c(&quot;Benign&quot;,&quot;Malignant&quot;))round(prop.table(table(wdbc$diagnosis)) * 100, digits = 1)wdbc=wdbc[-1] 1summary(wdbc[c(&quot;Radius_mean&quot;, &quot;Area_mean&quot;, &quot;Smoothness_mean&quot;)]) We can see that the scale between features are far too much, so we have to do the normalization. Here is the function of what define. 123normalize &lt;- function(x) &#123; return ((x - min(x)) / (max(x) - min(x)))&#125; 12wdbc_n &lt;- as.data.frame(lapply(wdbc[2:31], normalize))summary(wdbc_n[c(&quot;Radius_mean&quot;, &quot;Area_mean&quot;, &quot;Smoothness_mean&quot;)]) After the normalization, we can see the scale of the features are on the same level. Split the data and build the modelSplit the data into two parts: training data and testing data divide the data into two parts with the interval directly123456wdbc_train = wdbc_n[1:469, ]wdbc_test = wdbc_n[470:569, ]wdbc_train_label = wdbc[1:469, 1]wdbc_test_label = wdbc[470:569, 1]mal_rate=table(wdbc_train_label)round(mal_rate[2]/sum(mal_rate), digits = 2) There is a problem that if the first 469 cloumn includes most of the benign cancer data, that is not good for the partition. So we have to sample the data. 12345678set.seed(2017)inTrain = sample(1:dim(wdbc_n)[1],469,replace=F)wdbc_train=wdbc_n[inTrain,]wdbc_test=wdbc_n[-inTrain,]wdbc_train_label=wdbc[inTrain,1]wdbc_test_label=wdbc[-inTrain,1]mal_rate=table(wdbc_train_label)round(mal_rate[2]/sum(mal_rate), digits = 2) otherwise, we can use the createDataPartition function of the caret package to do the job.123456789require(caret)set.seed(2017)inTrain=createDataPartition(y=wdbc$diagnosis,p=0.8,list=FALSE)wdbc_train=wdbc_n[inTrain,]wdbc_test=wdbc_n[-inTrain,]wdbc_train_label=wdbc[inTrain,1]wdbc_test_label=wdbc[-inTrain,1]mal_rate=table(wdbc_train_label)round(mal_rate[2]/sum(mal_rate), digits = 2) Build the KNN model12require(class)wdbc_test_pred &lt;- knn(train = wdbc_train, test = wdbc_test,cl = wdbc_train_label, k=21) K&#x3D;21 here is based on the sqrt of the length(wdbc_train_label). the parameters of the knn funciton train: training data test: testing data cl: the labels of training data Model validation and improvementModel validation This is a classification problem, so we use the crossTable to validate the model12require(gmodels)CrossTable(x = wdbc_test_label, y = wdbc_test_pred,prop.chisq=FALSE) From the cross table, we can get that: TN &#x3D; 69,TP &#x3D; 39, FN&#x3D;3,FP&#x3D;2 So accuracy &#x3D; (TN+TP)&#x2F;113&#x3D;97.345% sensitivity&#x3D;TP&#x2F;(TP+FN)&#x3D; 92.86% Specificity&#x3D;TN&#x2F;(TN+FP)&#x3D; 100% And the sensitivity is how much we predict the benign breast cancer correctly, and the specificity is how much we predict the malignant breast cancer correctly. Model improvement Since before we have used the max-min normalization, it maybe reduce the influence of the minimum. So we now try to use the z-score normalization12345678910wdbc_z=as.data.frame(scale(wdbc[-1]))summary(wdbc_z$Area_mean)set.seed(2017)inTrain=createDataPartition(y=wdbc$diagnosis,p=0.8,list=FALSE)wdbc_train=wdbc_z[inTrain,]wdbc_test=wdbc_z[-inTrain,]wdbc_train_label=wdbc[inTrain,1]wdbc_test_label=wdbc[-inTrain,1]wdbc_test_pred = knn(train = wdbc_train, test = wdbc_test,cl = wdbc_train_label, k=21)CrossTable(x = wdbc_test_label, y = wdbc_test_pred,prop.chisq=FALSE) From the cross table, we can get: TN &#x3D; 71,TP &#x3D; 37, FN&#x3D;5,FP&#x3D;0 so we can calculate: accuracy &#x3D; (TN+TP)&#x2F;113&#x3D;96.46% sensitivity&#x3D;TP&#x2F;(TP+FN)&#x3D; 90.47% Specificity&#x3D;TN&#x2F;(TN+FP)&#x3D; 100% But it’s out of our expect, it gets worse now. So we can try to tune the k value too.","categories":[{"name":"技能-修行-进步-R语言","slug":"技能-修行-进步-R语言","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-R%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://example.com/tags/ML/"},{"name":"KNN","slug":"KNN","permalink":"http://example.com/tags/KNN/"},{"name":"Classification","slug":"Classification","permalink":"http://example.com/tags/Classification/"}]},{"title":"40 道ML/Data Science的初创公司(可能)的面试题","slug":"ML/40","date":"2016-10-03T08:19:38.000Z","updated":"2023-07-16T01:44:24.214Z","comments":true,"path":"2016/10/03/ML/40/","link":"","permalink":"http://example.com/2016/10/03/ML/40/","excerpt":"","text":"By Manish Saraswat, Original Link 09&#x2F;16&#x2F;2016 Introduction 留心，这些问题你要三思！ 在今天，机器学习和数据科学家被认为是下一代工业改革的驱动力。这也意味着有很多新进的初创公司在寻找数据科学家。那么，该如何给你振奋人心的职业生涯一个更好的开始呢？ 当然，想进入这个行业并不容易。显然你必须要对公司的理念，团队和远景感兴趣。你可能在你的职业之路上遇到一写很棘手的技术问题。本题集和初创公司做的东西有紧密联系。他们会不会提供咨询？他们会不会创建ML产品？你在面试之前就该提前考虑这个问题？ 为了帮助你准备下一场面试，我整理了40个看似可信但是其中暗藏端倪的问题，它们都有可能出现在你的面试当中。如果你能够轻松应对并且深刻理解问题，那么请放心，你可以在面试中打一场硬仗。 备注：轻松应对这些问题的核心是你对ML有实际操作经验和了解相关的统计概念。 机器学习的面试问题 Q1，给你一个1000列，100万行的数据集。这个数据集是一个分类问题。你经理要求你减少这个数据集的维度以减少模型计算所花的时间。你的机器有内存限制。你会怎么做？(你可以做出实际的假设) 答：在一台内存有限的机器上处理高纬度的数据是一个很费力的任务，你的面试官肯定意识到这一点。以下是你可以拿来应对的方法： 由于我们的内存有限，我们首先应该关闭所有不需要的程序，包括浏览器，这样我们才能把内存的利用最大化。 我们可以随机对数据集进行抽样。这就意味着我们可以创建一个更小的数据集，假如，1000个变量，30万行的数据集，然后做计算。 要减少维度，我们可以把数值型和分类型的变量分开，然后去掉相关的变量。对于数值型数据，我们利用相关性分析，对于分类型数据，我们利用卡方检验。 另外，我们可以做PCA，然后挑出数据集中能够解释最大方差的变量。 利用在线学习算法，像Vowpal Wabbit (Python提供)，也是一个选择。 利用随机梯度下降来创建一个线性模型也是有帮助的。 我们也可以把数据集的商业理解考虑进去，然后估计哪些predictors能够影响respone variable。但是这是一个凭直觉的方法，如果分析错误就会造成信息的损失。 备注：对于第4，5点，请务必了解在线算法和随机梯度下降算法。另外还有更高级的算法。 Q2， PCA中的旋转是必须的吗？如果是，那么你没有旋转的话，会发生什么？ 答：是的，旋转(正交直线)是必须的，因为它能最大化捕捉到的变量之间的差异。这会使变量更容易解释。不要忘记，这确切是PCA的动机所在，我们的目标是选择更少的components，这些变量能够解释数据集的最大方差。通过旋转，components的相关位置不会改变，她仅仅改变这些点的实际坐标。 如果我们没有进行旋转，PCA的作用就会减少，而我们需要选择更多的components来解释数据集的方差。 了解更多：PCA Q3，给你一个数据集，这个数据集包含这样的缺失值，它的分布是沿着中位数，标准差是1。那么，有百分之几的数据不受影响？为什么呢？ 答：这道题有足够的提示让你思考。由于数据是沿着中位数分布的，我们假设它是一个正态分布。我们知道在一个正态分布中，68%的数据包含在均值(或者众数，中位数)为中心1为标准差的范围内，那么就有32%的数据是不受影响的。所以，32%的数据将会不受缺失值的影响。 Q4，给你一个癌症检测的数据，你建了一个分类模型并且模型的准确率达到了96%。为什么你不能对你模型的表现感到满意？你会怎么做？ 答：如果你处理了足够多的数据集，你可以推断癌症检测造成了不平衡的数据。在一个不平衡的数据集中，准确率不应该被当作表现的衡量标准，因为96%仅仅是预测对了大多数的类别，但是我们感兴趣的类别是小部分的4%，它恰恰是被用来用作癌症的诊断。所以，为了评估模型的表现，我们应该利用Sensitivity(True Positive Rate)，Specificity(True Negative Rate)，F measure用来诊断分类器的性能。如果小部分的分类性能是很无力的，我们可以采取一下的措施： 我们可以利用欠采样，过采样或者SMOTE(一种采样技术)使得数据平衡。 我们可以通过概率校正来改变预测阈值，然后利用AUC-ROC曲线找到一个最优的阈值。 我们可以给类别赋予权重，让小部分的类别得到更大的权重。 我们可以做异常检测。 了解更多：Imbalanced Classification Q5，为什么朴素贝叶斯那么“朴素”？ 答：朴素贝叶斯“朴素”是因为它假设了数据集中的特征都是平等重要且相互独立的。我们知道，这些假设在现实生活中存在的几率是很小的。 Q6，解释朴素贝叶斯中的概念：先验概率，似然和边缘似然。 答：先验概率就是数据集中独立(二分类)变量的比重，就是一个最简单的分类。譬如，一个数据集中，独立变量是二分类的(0或者1)。1(垃圾邮件)的比重是70%，0(正常邮件)的比重是30%。所以，我们可以估计新邮件有70%的几率被分作垃圾邮件。 似然就是给定的观测量在其他变量的条件下被分作1的概率。譬如，在之前的垃圾邮件中“FREE”这个词的概率就是似然。边缘似然就是，“FREE”这个词被用在任何信息当中的概率。 Q7，你正在处理一个时间序列的数据集。你经理要求你创建一个高准确率的模型。你一开始就用决策树算法，因为你知道它对任意类型的数据都处理得不错。然后，你试了一个时间序列的回归模型并且得到了更高的准确率。这会发生吗？为什么呢？ 答：时间序列数据是受线性限制的。另一方面，我们知道决策树算法是适用于检测非线性的交互。决策树不能很好地提供robust的预测是因为它没有像线性模型那样能很好地map到数据的线性关系。所以，我们知道，线性回归模型可以对给定的线性数据提供更robust的预测。 Q8，你被分配了一个新的project，这个project是帮助某公司的食物派送减低成本的。问题是：公司的派送团队没能及时地派送食物，结果，顾客就不开心。然后为了让驳回顾客的芳心，公司最后决定免派送费。你认为哪一个机器学习方法能够拯救他们呢？ 答：你可能很快的在脑海中扫描了一遍机器学习算法。但是，请放松一下，这个问题考的是你的机器学习的基础。 这不是一个机器学习的问题。这是一个路径优化的问题。一个机器学习的算法包括三个基本要素： 问题中存在一个模式 你不能通过数学计算来解决它(即使是写指数方程) 你要有数据 我们通常找出这三个要素来决定是否能把机器学习当成一个解决实际问题的工具。 Q9，你发现你的模型出现了低偏差高方差的问题，你应该怎么解决？为什么呢？ 答：低偏差说明模型的预测值非常接近真实值。换句话说，这个模型能够很灵活地模仿到训练数据分布。看似这是很成功，但是不要忘记，一个灵活的模型往往没有泛化能力。这意味着，当模型对新数据进行预测时，它可能会给出很差的结果。 这样的话，我们可以利用bagging算法(譬如随机森林)来解决高方差的问题。Bagging算法通过重复的随机采样把数据集分成很多个子集。然后，用这些样本来做不同的算法得到一个模型的集合。之后，最终的预测是对模型集中的模型进行不同的组合，分类的话就用投票的方式，回归的话就用求均值的方式。 另外，为了防止高方差，我们可以： 利用正则化技术，对模型的高系数进行惩罚，从而降低模型的复杂度 对特征的重要性进行排序然后利用前n个。因为，如果全部的特征都用上，算法可能没办法很好地找到有意义的信号。 Q10，给你一个数据集，它包含了很多变量，但是你已经知道其中的一些有很高的关联性变量了。你的经理要求你利用PCA进行处理。你会先把有关联性的变量删掉吗？为什么呢？ 答：可能你会说NO，但是这是不对的。抛开有关联性的数据对PCA有实质的影响不说，如果没有删掉有关联性的变量，那么一个特定的成分的方差就会膨胀。 譬如，你有3个变量的数据集，其中2个是有关联性的。如果你对数据进行PCA处理，那么第一个主要的成分就会展示2倍的方差，比没有关联性变量存在的时候。另外，添加有关联性的变量会使得PCA把更多的重要性给以它们，这恰恰是误导的。 Q11，运行了几个小时之后，你很焦急想要创建一个准确率高的模型。结果，你建了一个5GB的模型集合，考虑到一个boosting算法会产生奇迹。但是，很不幸的，没有一个模型的表现能比基准分(benchmark score)更好。最后，你决定组合这些模型。我们都知道ensemble模型都会得到很高的准确率，但是你的却没有。请问到底是哪里出了问题呢？ 答：总所周知，ensemble learners的核心思想是通过组合简单的弱模型来得到一个强模型。但是当模型之间是独立的时候，组合出来的模型才会表现得很好。所以，我们建立了5GB的模型集合，但是准确率却没有提升，这就暗示着模型之间是有关联性的。有关联性的模型的问题是它们都提供了相同的信息。 譬如，如果模型1，2，3都是关联的，那么当模型1把User122分类为1时，模型2和模型3也会得到同样的分类结果，即使它的真实值是0。所以，ensemble learners是建立在没有关联性的弱模型集合的基础上，这样的组合才能得到更好的predictions。 Q12，kNN和kmeans聚类有什么不同？ 答：不要给名字中的k误导了。你应该知道这两个算法之间最基本的不同是：kmeans是一个无监督学习方法而kNN是一个有监督的学习方法。kNN是一个分类(或者回归)的方法。 kmeans算法是对一个数据集进行划分以至于组成有同质性族群，其中的点与点之间的距离是相近的。这个算法尽量保持这些族群之间的可划分性。而无监督的学习方法中的族群是没有标签的。 kNN算法试着对没有标签的数据按临近的距离进行k(k可以是任何小于sample的数)分类。它又被称作懒惰学习方法因为它涉及到模型的最小训练集。所以，它不会用训练数据对新的数据进行泛化。 Q13，True Positive Rate和Recall是什么关系？写出公式。 答：True Positive Rate &#x3D; Recall。是的，它们有相同的公式(TP&#x2F;(TP+FN))。 了解更多：Evaluation Metrics Q14，你建立了一个多重回归模型。模型的R方并没有你预期的那么好。为了改进，你去掉了截距，模型的R方由原来的0.3升到了0.8。请问这是可能的吗？是如何做到的？ 答：是的，是有可能的。我们需要理解截距在回归模型中的重要性。截距说明模型的预测是没有任何的独立变量的，如预测的均值。公式：R² &#x3D; 1 – ∑(y – y´)²&#x2F;∑(y – ymean)²，其中y´ 是预测值。 当截距存在的时候，R方值把模型的wrt评估到均值模型当中。当截距不存在的时候，模型就不会这样做。巨大的分母∑(y - y´)²&#x2F;∑(y)²就把等式的值变得比实际的要小，然后造成了高的R方。 Q15，分析了模型之后，你的经理得知你的模型有多重共线性。你会怎么验证模型？没有信息的流失，你可以建立一个更好的模型吗？ 答：要检查多重共线性，我们可以创建一个相关系数矩阵来辨识或者删除相关系数达到75%的变量(这个阈值的设置是主观的)。另外，我们可以计算方差膨胀因子(Variance Inflation Factor)来检查多重共线性。 VIF的值&lt;&#x3D;4意味着没有多重共线性，VIF的值&gt;&#x3D;10预示着有严重的多重共线性。最后，我们还可以利用公差来判断多重共线性的出现与否。 但是删除相关变量可能导致信息流失。为了保持变量，我们可以用惩罚性回归模型，像lasso回归或者ridge回归。还有，我们可以加入一些随机噪声变量到相关变量当中，这样变量间就会变得不同。但是，加入噪声可能影响预测准确率。所以，这个方法也要小心使用。 了解更多：Regression Q16，什么时候Ridge回归比Lasso回归更好用？ 答：你可以引用ISLR这本书的作者Hastie Tibshirani的话，他说：In presence of few variables with medium&#x2F; large sized effect, use lasso regression. In presence of many variables with small&#x2F; medium size effect, use ridge regression. 理论上说，lasso回归(L1)既做了变量选择也做了参数的收缩，而Ridge回归(L2)只是做了参数的收缩，最后把所有的系数都会算进了模型中。当存在相关变量时，ridge回归回事更好的选择。而且，ridge回归在最小二乘因子有比较高的方差时表现最好。所以，她取决于模型的客观性。 了解更多：Ridge and Lasso Regression Q17，全球平均气温的提升导致了海盗数量的减少。那么我们可以说海盗数量的减少造成了全球气温的变化吗？ 答：读完题目后，你应该这就是典型的“因果与相关”的问题。不，我们不能得出海盗数量的减少造成了气温的改变，因为可能是其他因素(潜伏或者混淆的变量)影响着气候。 所以，或许全球平均气温和海盗数量有一定的关系，但是基于这样的信息我们不能说海盗减少是因为全球平均气温的升高。 了解更多：Causation and Correlation Q18，在处理数据的时候，如何选择重要的变量？请解释你的方法。 答：以下是一些常用的变量选择方法： 在选择重要变量之前，先把有相关性的变量删掉 利用线性回归基于P值选择变量 利用前向选择，后向选择和逐步选择法 利用随机森林，Xgboost或者对变量的重要性列表 利用Lasso回归 对所有变量做信息增益，然后选择前n个特征 Q19，相关性系数和方差有什么不同？ 答：相关性系数是协方差的标准形式。 协方差不容易进行比较。譬如，如果我们计算了工资和年龄的协方差，我们不能把他们进行比较，因为他们之间的scales不一样。为了解决这个情况，我们计算相关性系数，得到一个在-1和1之间的数值，就不用考虑它们之间不同的scales了。 Q20，有没有可能求连续变量和分类变量之间的相关性系数吗？如果可以，怎么做？ 答：是的，我们可以利用ANCOVA(协方差分析)技术来获得连续性和分类变量之间的相关性系数。 Q21，同样是基于树的算法，随机森林和梯度提升算法(GBM)之间有什么不同？ 答：最基本的不同是，随机森林利用bagging技术来做预测，GBM是用boosting技术来做预测。 在bagging技术当中，一个额数据集被随机抽样法分成了n个样本。之后利用单个学习方法对所有的样本进行建模。之后，最终的预测结果是通过对多个模型的预测值进行投票或者求均值的方法得到的。bagging是并行化的。在boosting当中，在第一轮的模型进行预测之后，这个算法就会把误分类模型的权值加大，这样就可以在随后的建模过程中对模型进行修正。这种顺序性的过程直到最后的预测值满足停止标准值为止。 随机森林通过减低方差改善了模型的准确率。树的生长和最大化方差的降幅没有关系。另外，GBM同时减低了bias和方差来改善模型的准确率。 了解更多：Tree based modeling Q22，运行一个二分类树算法并不难。那你知道树是如何分割的吗？譬如，树是如何决定哪一个结点作为根节点，哪一个结点作为后继节点的吗？ 答：一个分类树的生成是基于基尼系数和结点的熵。简单的说，树算法会找到最适合把数据集划分成子节点的变量。 基尼系数是说，如果我们随机选择了两个群体，那么它们必须是属于同一类的，然后概率和为1。我们可以这样来计算基尼系数： 计算子节点的基尼系数，用概率的成功和失败的平方和公式： (p^2+q^2)。 利用每个分割节点的权重基尼得分计算它们的基尼系数 熵是衡量混乱程度的标准，即是否更适合分割： 这里的p和q分别代表节点成功和失败的概率。熵是0当一个节点是同质的时候。它最大的时候是当一个节点的两个分类各占50%。我们要求小的熵。 Q23，你利用1000棵树建立了一个随机森林。你非常高兴因为你得到了训练错误率是0。但是，验证错误率是34.23。发生了什么事了？你训练的模型完美吗？ 答：这个模型是过拟合了。训练错误率是0意味着分类器在某程度上很好的拟合了你的训练数据，但是它对未知数据的预测性很差。所以，当我们用这个分类器来预测新数据时，它找不到新数据的模式并且返回了很高的错误率。在随机森林中，当我们用了超过了我们所需要的树时就会发生这种情况。所以，为了避免这种问题，我们就要用交叉验证来调节树的数量。 Q24，你得到了一个数据集，他的变量数p&gt;样本数n。为什么OLS是一个不好的方法？你应该用什么技术来解决，为什么呢？ 答：在如此高纬度的数据集中，我们不可以利用经典的回归技术，因为假设都会失败。当p&gt;n时，我们不能计算一个最小二乘系数了，变量是非常大的时候，OSL就不可行了。 为了解决这种情况，我们可以利用惩罚性回归方法，像lasso，LARS，ridge这些能够收缩系数的方法来减少变量。更准确的说，ridge回归表现最好，当最小二乘因子有高方差的时候。 其它的方法还有取子集回归，前向逐步回归。 Q25，什么是凸多边形(convex hull)？(思考一下SVM) 答：在可分割的数据中，convex hull就是两组数据点的边界部分。一旦convex hull创建了，我们就可以得到最大边界超平面(MMH)，它是两个convex hulls之间的垂直平分线。MMH是一条能最大化的分割两组数据的直线。 Q26，我们知道一位热编码会增加数据集的维度。但是，标签编码却不会，为什么呢？ 答：不要给这个问题给搞混了。它只是问你两个编码之间的差别。 利用一位热编码，数据集的维度(变量)就会增加因为它为分类变量的每一个level表现创建了一个新的变量。譬如，一个变量叫“颜色”。这个变量有3个level，红，蓝和绿。一位热编码就会产生3个新的变量Color.Red, Color.Blue, Color.Green，然后它们的值包含0和1。 在类标签编码中，分类变量被编成0和1，所以没有产生新的变量。类标签编码通常用在二分类变量当中。 Q27，在时间序列的数据集中，你会用哪一种交叉验证方法，k折叠还是留一验证？ 答：都不是。 在时间序列问题中，k折叠会产生问题，因为可能有些模式在第4年和第5年中，但是没有在第3年中。重采样会分离这些，然后我们可以用去年来做验证，这是不对的。但是我们可以用5-fold的正向推理策略： fold 1: training [1], test[2] fold 2: training[1,2], test[3] fold 3: training[1,2,3], test[4] fold 4: training[1,2,3,4], test[5] fold 5: training[1,2,3,4,5], test[6] 1,2,3,4,5,6代表年。 Q28，给你一个数据集，但是它包含了缺失值的变量，且缺失值占了超过30%，譬如，50个变量，有8个变量的缺失值超过了30%。你会怎么处理？ 答：我们可以做以下处理： 给缺失值赋一个唯一分类值，谁知道缺失值会不会破译一些趋势呢 我们可以直接删掉它们 或者，我们可以根据目标变量检查它们的分布，如果我们能找到模式，那么我们就赋于缺失值一个新的分类，否则就删掉它们。 Q29，亚马逊上的“浏览此商品的顾客也同时浏览。。。”这个推荐系统是什么算法的结果？ 答：推荐系统的核心思想是协同过滤。 协同过滤算法是通过用户行为来推荐物品。它是通过物品的交易记录，评价，选择以及购买信息来挖掘其他用户的行为。其他用户对物品的行为和爱好被用来当作给新用户推荐的依据。这个例子中，物品的特征是不知道的。 了解更多：Recommender System Q30，你怎么理解Type one and Type two error ? 答：Type I error 是指统计学中的一类错误，意思是本来是错误的结论却被接受了。TypeII error 是指统计学中的二类错误，也就是本来是正确的错误却被拒绝了。简而言之，就是存伪和弃真。 在混淆矩阵当中，我们可以说Type I error就是当我们把实际的0预测分类为1，Type II error就是当我们把实际的1预测分类为0. Q31，你正在做一个分类的问题。为了达到验证的目标，你随机的从训练集抽样分为训练集和验证集。你对你的模型的泛化能力很有信心因为它的验证错误率非常高。但是，结果却是十分失望，你的测试准确率很低。到底是怎么了？ 答：在分类问题当中，我们应该常常用分层抽样而不是随机抽样。因为随机抽样并没有考虑到目标类别的比例。相反，分层抽样就会保证目标变量的分布也会保证样本的分布。 Q32，你被要求利用R², adjusted R² 和tolerance来对回归模型进行评价。你会用哪一个作为标准？ 答：Tolerance(1 &#x2F; VIF)是用作多重共线性的预示。它是衡量一个预测中的变量的百分比不能给另一个预测占据的程度。Tolerance越大越好。 我们认为adjusted R² 和R² 来评估模型是截然不同的，因为当我们增加变量的时候，无论预测准确率有没有改进，R²都会增加 。但是adjusted R²仅仅是在增加变量而提高了模型的准确率的时候才会增加。很难去确定adjusted R²的通常值，因为它会随着数据的不同而不同。譬如，基因变异数据集中，低的adjusted R²值的模型依然会有比较不错的预测能力，但是对比于股票数据，低的adjusted R²值就会得到不好的模型。 Q33，在k-means或者kNN中，我们计算相近点之间的距离是用欧几里得距离，为什么我们不用曼哈顿距离呢？ 答：我们不用曼哈顿距离是因为它真能垂直计算或者平行计算距离，它有维度限制。另外，欧几里得距离是用在任意空间当中计算的。因为，数据是可以表示在任何的维度空间当中的，所以欧几里得距离是更好的选择。 譬如，在一个棋盘上，象和车的移动就是通过曼哈顿距离来计算的，因为他们只能垂直做或者平行的移动。 Q34，像一个5岁的孩子来介绍一下机器学习。 答：非常简单。就像宝宝学走路一样。每一次的跌倒，他们都会无意识地学习并且意识到他们下一次就应该挺直的走而不是弯下来走。当下一次他们跌倒，他们会感到疼，他们会哭，但是，他们就不会再那样走了。为了避免疼痛，他们会更努力尝试。为了成功，他们会借助门后或者墙的力量或者任何接近他们的东西，这样他们就会站的更稳。 这是机器如何从它的周围环境学习和发展直觉的过程。 注：这道面试题就是考你能不能很好把复杂的文件简单化解释一下。 Q35，我知道一个线性回归通常是用adjusted R²或者F值来评估的。那你如何评估一个罗吉斯特回归模型呢？ 答：我们可以用以下方法： 因为逻辑斯特回归是用来预测概率的，我们可以用混淆矩阵的AUC-ROC曲线来评估它的性能。 另外，逻辑斯特回归当中类似adjusted R²的评估标准是AIC。AIC是通过模型系数的数量来惩罚模型的拟合标准。所以，我们要的是有最小AIC值的模型。 空异常(Null Deviance)说明模型仅仅通过截距来预测。数值越小，模型越好。残差(Residual deviance)说明模型添加了独立变量来进行预测的。数值越小，模型越好。 了解更多：Logistic Regression Q36，有那么多的机器学习方法，给你一个数据集，你会决定用什么方法呢？ 答：你应该说，选择用哪一种机器学习方法取决于数据的类型。如果给你的数据集是一个线性的，那么线性回归算法最适合。如果你处理的是图像，语音数据，那么神经网络可以建一个更稳固的模型。 如果数据包含一些非线性的关系，那么boosting或者bagging算法就是一个选择。如果商业需求是建一个能够发布的模型，那么我们会用回归或者决策树模型(容易解释)而不是一些黑箱的方法，像SVM，GBM等等。 简单来说，没有绝对的方法，我们应该要认真的理解我们要用的算法。 Q37，你认为把分类变量当成连续的变量来处理，会使得预测模型更好吗？ 答：为了得到更准确的预测，分类变量只有在它是有序的时候才被当成连续的变量，这样才合理。 Q38，在机器学习当中，什么时候用到规则化技术(regularization)？ 答：当模型变得过拟合或者欠拟合时，规则化(Regularization)变得越来越重要了。这个技术在很多特征的模型中加入了一个惩罚项。所以，它试着把很多的变量的系数变成0以至于减少成本。这样可以帮助降低模型的复杂度从而可以提高模型的泛化能力。 Q39，你怎么理解bias variance权衡？ 答：当模型能在数学上表示成3个成分的时候，这个错误就会出现。以下就是这些成分： 偏差错误是将预测的均值和真实值的差异程度量化了。一个高的偏差错误意味着我们得到的是一个欠拟合模型，它总是偏离了真实的趋势。而方差则是模型预测值和真实值的分散程度。高方差说明模型在训练数据上过拟合了，然后在新数据上预测很差。 Q40，OLS(最小二乘法)对应线性回归，最大似然对应逻辑斯特回归。请解释这句话。 答：简单来说，最小二乘法和最大似然都是对回归方法进行未知参数的预估的方法。 最小二乘法(Ordinary least square)用在线性回归中估计参数，目的是要真实值和预测值之间的距离最小。最大似然是帮助选择一个参数值，使得模型能够最大化产生观测数据。 后记 你可能很轻松地回答了所有问题，但是我们的目标是要理解它们并且可以举一反三，理解透相关的问题。如果你没能很好应对这些问题，也不用担心，从现在开始学习，从现在开始关注学习的问题。 这些问题是为大家提供了初创公司的面试问题的概况。我相信这些问题引起了你深入学习机器学习的欲望，现在开始计划吧。","categories":[{"name":"技能-修行-进步","slug":"技能-修行-进步","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"基于SVM技术的手写数字识别-毕业设计博客系列-连载","slug":"毕业设计系列/手写数字识别-毕业设计博客系列-连载","date":"2015-12-30T14:33:42.000Z","updated":"2023-07-22T02:17:18.840Z","comments":true,"path":"2015/12/30/毕业设计系列/手写数字识别-毕业设计博客系列-连载/","link":"","permalink":"http://example.com/2015/12/30/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97/%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97-%E8%BF%9E%E8%BD%BD/","excerpt":"","text":"写在前面的话 本系列博客是为记录本人大学毕业设计过程所有点滴而设。因为人生只有一次毕业设计，它如流水，一去不复返，错过了就永远失去了。很多时候，每件事情的发生，都会带着甜酸苦辣，而文字可以记录它们的痕迹，日后可让我细细品味这段曾经的奋斗。 毕业设计简介 本人的毕业设计的题目和其他同学的选题都不大相同，同学一般都选了做个系统或网站，而我选的是“基于SVM技术的手写数字识别的设计和实现”，它是属于模式识别的范畴，模式识别这个名字看上去就感觉到好高大上。根据百度百科的解释：模式识别（英语：Pattern Recognition），就是通过计算机用数学技术方法来研究模式的自动处理和判读。通俗的来说，就是想让机器模仿人的认知，比如“听”懂人说的话(语音识别)，“看”懂人写的文字(自然语言处理)，甚至乎拥有人的思维能力。而我的“手写数字识别”就是看“懂”人写的文字的一部分，它是属于光学字符识别的一个子分支。所以，这个毕业设计还是比较有难度的，对我来说，如果我能很好的完成了这个选题，那么无论是对我个人能力的提升，还是以后的发展都是有很大的帮助的。所以，我要好好对待我的毕业设计，用心做好它。 毕业设计时间安排 毕业设计流程开题报告(11月30日)什么是开题报告 开题报告是是指开题者对科研课题的一种文字说明材料。开题报告包括综述、关键技术、可行性分析和时间安排等四个方面 。由于开题报告是用文字体现的论文总构想,因而篇幅不必过大,但要把计划研究的课题、如何研究、理论适用等主要问题写清楚。开题报告一般为表格式，它把要报告的每一项内容转换成相应的栏目，这样做，既避免遗漏；又便于评审者一目了然，把握要点。 百度百科 开题报告格式 毕业论文开题报告提纲 一、开题报告封面：论文题目、系别、专业、年级、姓名、导师 二、目的意义和国内外研究概况 三、论文的理论依据、研究方法、研究内容 四、研究条件和可能存在的问题 五、预期的结果 六、进度安排 参考模板 参考文献规范 参考文献的书写也是有一定的要求，所以这个不可随意乱写的。参考文献书写格式要符合GB7714-2005《文后参考文献著录规则》。 文献标注 参考文献类型 专著[M]，论文集[C]，报纸文章[N]，期刊文章[J]，学位论文[D]，报告[R]，标准[S]，专利[P]，论文集中的析出文献[A] 电子文献类型 数据库[DB]，计算机[CP]，电子公告[EB] 电子文献的载体类型 互联网[OL]，光盘[CD]，磁带[MT]，磁盘[DK] 参考示例 专著、论文集、学位论文、报告 [序号]主要责任者.文献题名[文献类型标识].出版地：出版者，出版年.起止页码（任选）. [1]刘国钧，陈绍业，王凤翥. 图书馆目录[M]. 北京：高等教育出版社，1957.15-18. 期刊文章 [序号]主要责任者.文献题名[J].刊名，年，卷（期）：起止页码. [8] Heider,E.R.&amp; D.C.Oliver. The structure of color space in naming and memory of two languages [J]. Foreign Language Teaching and Research,1999⑶： 62-67. 百度百科 360图书馆 我的开题报告本地内存中 我的毕业设计规划(12月22日) 由于我的毕业设计偏向理论，所以我给自己定了两条计划路线，一条是系统实现路线(偏软件实现的)，另一条是理论学习路线(偏理论的)。整体规划如下图： 系统实现这一块，算法实现用的是Python语言，GUI用PyGame库实现；理论学习这一块，只要是参考了July的博客支持向量机通俗导论（理解SVM的三层境界）为主线对SVM进行系统的学习。其只要学习路线如下： 中期检查(12月24日)毕业设计完成情况 由于课程安排，本人在前一个月中都在做HIS系统的实训，搁置了毕业设计，所以毕业设计的完成情况还是处于初始阶段。在初始阶段，我主要做了以下工作。 系统的原型设计 手写画板的实现 学习线性分类器-感知机 做了哪些工作 系统实现路线 系统的原型设计 系统主面板的设计 数据集训练等待过程面板的设计 数据集训练完成面板的设计 手写画板的实现(Demo) 参考资料 理论实现路线 学习线性分类器-感知机 最小二乘法论文翻译 梯度下降法 对偶形式 感知机 线路图完成度(中期检查) 遇到了哪些问题哪些问题已经解决了，哪些没有解决下一步的计划 根据线路图，下一步的计划是继续完善面板框架，学习SVM理论知识，实现SVM识别手写数字的算法。 末期检查参加答辩答辩成绩个人总结后记","categories":[{"name":"毕业设计系列","slug":"毕业设计系列","permalink":"http://example.com/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"手写数字SVM","slug":"手写数字SVM","permalink":"http://example.com/tags/%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97SVM/"}]},{"title":"支持向量网络论文原文-Vapnik-论文翻译","slug":"毕业设计系列/支持向量网络论文原文-Vapnik-论文翻译","date":"2015-03-13T10:58:23.000Z","updated":"2023-07-13T04:02:43.358Z","comments":true,"path":"2015/03/13/毕业设计系列/支持向量网络论文原文-Vapnik-论文翻译/","link":"","permalink":"http://example.com/2015/03/13/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E7%BD%91%E7%BB%9C%E8%AE%BA%E6%96%87%E5%8E%9F%E6%96%87-Vapnik-%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/","excerpt":"","text":"摘要： 支持向量网络是一种新的用于二类分类问题的学习机。这个机器(方法)概念地实现了以下想法：非线性的输入向量被映射到高维度的特征空间。在这个特征空间中找出一个线性决策超平面。决策超平面的特殊属性可以保证学习机的强泛化能力。这个支持向量网路的思想在训练资料严格线性可分的情况下已被实现。现在我们来谈一下在训练资料非线性可分的情况下的结果。 支持向量网络的高泛化能力是利用多项式输入转换。我们同样比较了支持向量网络和和其他经典的学习算法在OCR(光学字符识别)这个基准上的表现。 关键字： 模式识别， 有效的学习算法， 神经网络， 径向基函数分类器， 多类分类器 简介 60多年前R.A. Fisher(Fisher, 1936)提出了模式识别的第一个算法。有两个服从正态分布的模型，和，n维向量X，其中均值向量分别是m1和m2，方差分别是和，最后得到的最优解(贝叶斯)是一个二次规划函数： 若果，那么上式化简为一个线性函数： 要解式子(1)中的二次规划函数，必须有个自由参数。要解式子(2)中线性函数仅仅要n个自由参数。观测量的数量小(比如说小于个)估算个参数是不可靠的。因此Fisher推荐，即使是在的情况下，仍然对线性判别函数(2)使用以下的形式： 上式中的是一个常量。Fisher另外推荐了当两个分布不是服从正态的时候，利用一个线性决策函数。 模式识别的算法最开始就和线性决策超平面的构建有关。 在1962年Rosenblatt(Rosenblatt, 1962)发明了一种新型的学习机：感知机或者神经网络。感知机包含多个相连的神经元，每个神经元实现一个分离超平面，所以整个感知机实现了分段的线性分离超平面。见图Fig.1。 在Rosenblatt时期还没有算法通过调整网络的权值来最小化向量集的错误。根据其他权值的固定值，输入向量被非线性地转换到特征空间Z中,在单元的最后一层。在这个空间中一个线性决策函数被构造： 通过调节从第i层隐藏层到输出单元的的权值以最小化在整个训练资料上的一些误差。根据Rosenblatt的方法的结果来看，决策规则的构造再一次联系到信息超平面的构造，在某些空间上。 第一次出现一个算法允许通过调整神经网络的权值来最小化属于模式识别问题的向量集的局部误差是在1986年,(Rumelhart, Hinton &amp; Williams, 1986, 1987; Parker, 1985; LeCun 1985)因为那个时候发现了反向传播算法。它的解法是一个轻微修改的神经元的数学模型。所以，神经网络实现了“分段线性类型”的决策函数。 在本文中，我们构造一个新型的学习机(方法)，所谓的“支持向量网络”。支持向量网络实现了一下想法：它通过一些事先选择好的非线性的映射规则把输入向量映射到高维度的特征空间Z。在这个空间当中，通过一些特殊属性来构造线性决策超平面来保证网络的高泛化能力。 例子：要求得二次多项式的决策超平面，可以创建一个特征空间Z，它有 N&#x3D; 个坐标形式： 上面的方法中有两个新的问题：一个是概念上的，一个是技术上的。概念上的问题是怎么才能找到一个推广能力较好的分离超平面：特征空间的维数将会很大，而且并不是所有的可分离训练资料的超平面都有很好的推广能力。然后技术上的问题是面对如此高维的空间，怎么简化计算量：在一个200维德空间中构造一个4次方或者5次方的多项式可能需要构造一个数以数以亿计的维数的空间。 概念上的问题在1965(Vapnik, 1982)被解决了，鉴于为线性可分的类寻找最佳化的分离超平面这个case.这里定义的最佳化的超平面是两个可分的向量中寻找最大的分类间隔，看Fig.2.被证明说要构造这样一个最佳化的超平面只需要很少的训练数据，这些数据就被称为支撑向量，它们是用来决定间隔的。资料表明，如果训练资料被一个最佳化的超平面完美无误地分离，那么在测试例子中预测新数据的误差期望值等于支持向量的数量的期望值和训练向量的数量的比： 注意到这个约束并没有明显的包含可分空间的维数。这个约束遵循这个规则的：如果构造最佳化的超平面包含的支持向量的数量越少，那么这个模型的泛化能力就越高–即使是在无穷的维数空间中。在Section 5我们会通过一个实际生活问题说明上面(5)式子的比值可以低到0.03，而且这个最佳化超平面在数以亿计的维数的特征空间中的推广能力很好。 让 作为空间中最佳化超平面的表示。我们会把特征空间中的最佳化超平面的权值写成支持向量的线性组合式 特征空间中的线性决策函数会相应地变成以下形式： 表示的是再特征空间中的支持向量zi和z的点积。决策函数能够被描述为一个两层的网络。(Fig.3.) 然而，即使最佳化超平面的推广能力比较好，但是关于怎样处理高维度空间的技术的问题还没解决。在1992年(Boser, Guyon, &amp; Vapnik, 1992)，构造决策函数的操作顺序是可以互换的：我们可以先比较输入空间中的两个向量(比如，计算它们的点积，或者一些距离测量)对结果的值做非线性转换，而不是拿特征空间中两个点积的向量做非线性的转换。这样促成了更多分类的决策超平面的构造，例如，任意次方的多项式决策超平面。我们把这种类型的学习机叫做支持向量网络。 支持向量网络的技巧当初是为了毫无误差地找到更精准的分类训练数据的超平面。在这篇文章当中，我们对支持向量网络进行拓展，拓展到当不能毫无误差的进行分类数据的情况下也能使用。在这种情形之下，我们把支持向量网络当成一种新的学习机。一种像神经网络一样更强大更通用的学习机。在Section 5我们会对在一个高维空间(维度256)，多项式次方高达7的情形下，支持向量网络的泛化能力还能有多好进行说明。这种学习机的表现可以与那些经典的学习机(像线性分类器，k邻近分类器和神经网络等)相媲美。Section 2，3和4主要讲算法的推导和它的一些属性的讨论。关于推导的细节请看附录部分。 最佳化超平面 在这个section当中，让我们来回顾一下0误差分离训练资料的最佳化超平面的方法(Vapnik, 1982).而在下一个section，我们介绍软间隔的记号，它允许在分类的过程当中存在误差。 最佳超平面算法 训练模式的标签集 被认为是线性可分的，如果向量W和标量b满足以下不等式条件： 被认为说是对(8)中的所有的训练集都是有效的。然后把(9)中的不等式写成一下形式： 最佳化超平面是： 它是唯一一个把训练资料分离出最大间隔：它保证了两个不同类别的训练向量映射在方向上的距离是最大的。回顾Fig.2.这个距离表示如下： 最佳化超平面是使得(12)中距离最大的参数。它符合(12)和(10)的约束 这就是说最佳化超平面在符合(10)式当中的约束的条件下是唯一一个可以最小化的.所以构造最佳化超平面的问题就是一个二次规划问题。 当中的向量学术上被称为支持向量。在附录A.1中，我们说明了能够决定最佳化超平面的向量可以写成一个训练向量的线性组合形式： (14)中当.因为仅仅是符合支持向量(看附录)，(14)当中的表达式是的简写形式。我们也说明了要找参数的向量： 必须要解决以下的二次规划问题： 其中满足的约束条件是： 其中是一个维的单位向量，是一个维的标签向量，是一个带元素的对称的矩阵 (16)当中的不等式描述的是非负象限。所以我们在(17)的约束条件下最大化(15)中的二次规划式。 当(8)中的训练资料可以0误差的分离时，我们同样在附录中进行了说明，(15)中的最大值，对和(13)中的最大间隔的关系： 对于某些和大的常量，不等式 是合理的，有一个可以断言的是所有的可分离训练资料(8)的超平面都满足 如果(8)中的训练资料不能被一个超平面分离，那么两个模式类别之间的间隔将会非常小，导致函数的值非常大。在约束条件(16)和(17)下最大化函数(15)的值，其中一个达到最大值时(这种情况是其中一个通过最大间隔构建了一个超平面)，或者其中一个找到了最大值超过了给定的常量(这种情况是训练资料的分离超平面比还要大是不可能的)。 在约束条件(16)和(17)下最大化函数(15)的问题很有效地通过以下模式解决。把训练资料合理的分成多个不大的部分。首先利用第一部分的训练资料来解决二次规划的问题。对于这样的处理会有两种可能的结果：这部分的训练资料不能找打一个可分离的超平面(这样的话整个资料也是找不到可分离的超平面的)，或者在第一部分的训练资料中就找到了最佳化的分离超平面。 如果是在第一部分的训练资料中就找到了分离超平面，我们把它称作向量，让它来最大化函数(15).在向量当中有一些值是等于0的。它们对应于这部分资料的非支持向量。创建一个新的训练资料集，其中包含第一部分资料的支持向量和第二部分资料的那些不符合约束(10)的向量，其中是由决定的。在这个新的资料集当中创造了一个新的函数和这个函数在处达到最大。然后重复这样的做法，覆盖到所有的训练资料中，不断增加新的解法向量，如果找不到0误差的分离超平面，或者对所有训练资料可以构造一个最佳化分离超平面.请注意，在这个过程当中，函数的值是单调递增的，因为越来越多的训练向量被划分为最佳化，导致两个类别之间的分隔越来越小。 软间隔超平面 考虑到那种不能0误差的把训练资料分离的情况。这样的话，我们想说要达到误差的最小化来分离资料。要正式地表达这个，让我们先引入一些非负变量 我们现在最小化函数 其中，约束于 足够小，函数(21)描述的是训练错误的个数。 最小化(21)，我们要找出一些最小的训练错误的子集： 如果这些误差资料不包含在训练资料中，那么训练资料就可以毫无误差的进行分离，并且在两个类别之间找到一个超平面。 这个想法可以正式的表达为：最小化函数 约束条件为(22)和(23)，其中是一个单调的凸函数，是一个常量。 足够大的和足够小的，在约束条件(22)和(23)下的最小化函数(24)的向量和常数，可以决定一个超平面，这个超平面是最小化在训练集上的错误个数和把剩余的元素利用最大间隔进行分离。 注意到，在训练集上构造一个能够最小化错误数的超平面是一个正常的NPC问题(因不能用多项式算法而使问题无法解决的；非完全多项式).为避免我们的问题出现NPC问题，我们设定","categories":[{"name":"毕业设计系列","slug":"毕业设计系列","permalink":"http://example.com/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"SVM入门","slug":"SVM入门","permalink":"http://example.com/tags/SVM%E5%85%A5%E9%97%A8/"}]},{"title":"毕设报告-2015-03-10","slug":"毕业设计系列/毕设报告-2015-03-10","date":"2015-03-10T03:58:21.000Z","updated":"2023-07-13T04:09:46.831Z","comments":true,"path":"2015/03/10/毕业设计系列/毕设报告-2015-03-10/","link":"","permalink":"http://example.com/2015/03/10/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97/%E6%AF%95%E8%AE%BE%E6%8A%A5%E5%91%8A-2015-03-10/","excerpt":"","text":"毕业设计完成情况我的感受 写论文绝不是一件轻松的工作，特别是如果你选的题目和你现在的水平相差甚远时。自从上一次的毕业论文中期检查之后，我实习了一个月，然后回家过了个年，所以把时间分配到做毕设的也不多，而且我现在明白到了做理论这一块的论文，特别是面对一连串关数学的推导，一大片难懂的公式，那就更是不知所云。不过就像我的指导老师易老师说的那样，写论文不是简单的拼凑文章，而是需要大量的去阅读前人在你的这个领域范围内的文章，去慢慢吸收里面的知识，然后可以通过自己的话来描述清楚一个问题。“读书千遍，其义自见”这句谚语的个中滋味我也终有领会。特别是偏理论的问题，读第一遍，不知所云，读第二遍，不知所云，读第三遍，不知所云。。。然后突然再读下一遍，就发现自己找到了头绪，那感觉就好像身陷死角里摸不着头了好久，然后突然看到了一线光明一样，整个人都开朗了起来。 完成情况概述 我的毕设规划是分两个路线进行，一个是理论学习路线，一个是系统实现路线。 上次的完成情况如下图： 现在的完成进度则如下： 所以到目前为止，还是注重于理论这一块的学习，因为这一块的难度比重是占的比较大的。 做了哪些工作阅读了以下优秀的博客文章： 支持向量机通俗导论（理解SVM的三层境界） SVM入门系列博文-转自Jasper’s Java Jacal 支持向量机SVM（一） 翻译了一下国外优秀的文章： Support Vector Machines-scikielearn-翻译-毕设系列 手写数字识别-Kernel Support Vector Machine-论文翻译-毕设系列 最小二乘法论文翻译-毕设系列 草拟了论文目录框架 利用pygame实现系统的UI，完成了模块的划分 利用scikit-learn软件包实现了SVM算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#-*- coding: utf-8 -*-### Support Vector Machine for Handwritten Digit Recognitionimport csvimport numpy as npfrom sklearn import svm, datasets, cross_validationfrom sklearn.grid_search import GridSearchCVfrom time import gmtime, strftimeprint &quot;1- Start 载入训练数据&quot;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, gmtime())### Load Training datatrainTargetArray = []trainDataArray = []with open(&#x27;./train.csv&#x27;, &#x27;r&#x27;) as trainFile: trainReader = csv.reader(trainFile, delimiter = &#x27;,&#x27;) for row in trainReader: trainTargetArray.append(row[0]) trainDataArray.append(row[1:])print &quot;1- End 载入训练数据&quot;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, gmtime()) print &quot;2- Start 删除列头&quot;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, gmtime()) ### Delete Column Headersdel trainTargetArray[0]del trainDataArray[0]trainData = np.array(trainDataArray)trainTarget = np.array(trainTargetArray)trainData = trainData.astype(np.float)/255.0trainTarget = trainTarget.astype(np.float)print &quot;2- End 删除列头&quot;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, gmtime())print &quot;3-Start 载入测试数据&quot;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, gmtime())### Load Testing datatestDataArray = []with open(&#x27;./test.csv&#x27;, &#x27;r&#x27;) as testFile: testReader = csv.reader(testFile, delimiter = &#x27;,&#x27;) for row in testReader: testDataArray.append(row)print &quot;3- End 载入测试数据&quot;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, gmtime())print &quot;4 -Start 删除列头&quot;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, gmtime())# Delete column Headersdel testDataArray[0]testData = np.array(testDataArray)testData = testData.astype(np.float)/255.0print &quot;4-End 删除列头&quot;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, gmtime())print &quot;5-Start 设置分类器并训练模型&quot;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, gmtime())# Set up classification and fit he model datasvc = svm.SVC(gamma=0.128, C=1)svc.fit(trainData, trainTarget)print &quot;5-End 模型训练完成&quot;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, gmtime())print &quot;6- Start 利用模型预测测试数据中的手写数字&quot;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, gmtime())# Predict / Determine Value of New imagesprediction = svc.predict(testData)print &quot;6-End 预测&quot;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, gmtime())print &quot;7- Start 保存输出文件&quot;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, gmtime())# Save output to fileoutput = open(&#x27;./output.csv&#x27;, &#x27;w&#x27;)for x, value in np.ndenumerate(prediction): output.write(str(int(value))) output.write(&quot;\\n&quot;)output.close()print &quot;7- End 结束！&quot;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, gmtime()) 本次SVM的实现是利用了网上比较健全的开源机器学习工具—scikit-learn,Scikit-Learn是基于python的机器学习模块，基于BSD开源许可证。这个项目最早由DavidCournapeau 在2007 年发起的，目前也是由社区自愿者进行维护。 scikit-learn的SVM说明，也是我翻译了一篇文章Support Vector Machines-scikielearn-翻译-毕设系列 然后本次的数据是Kaggle上的数字识别的数据Digit Recognizer。Kaggle是一个数据建模和数据分析竞赛平台。企业和研究者可在其上发布数据，统计学者和数据挖掘专家可在其上进行竞赛以产生最好的模型。这一众包模式依赖于这一事实，即有众多策略可以用于解决几乎所有预测建模的问题，而研究者不可能在一开始就了解什么方法对于特定问题是最为有效的。Kaggle的目标则是试图通过众包的形式来解决这一难题，进而使数据科学成为一场运动。Kaggle的Wiki简介 SVM的训练日志：12345678910111213141516171819202122232425262728293031323334353637log-11- Start Load Training data2015-03-09 14:15:331- End Load Training data2015-03-09 14:15:372- Start Delete Column Headers2015-03-09 14:15:372- End Delete Column Headers2015-03-09 14:15:513-Start Load Testing data2015-03-09 14:15:513- End Load Testing data2015-03-09 14:15:554 -Start Delete column Headers2015-03-09 14:15:554-End Delete column Headers2015-03-09 14:16:055-Start Set up classification and fit he model data2015-03-09 14:16:055-End Set up classification and fit he model data2015-03-09 15:40:126- Start Predict / Determine Value of New images2015-03-09 15:40:126-End Predict / Determine Value of New images2015-03-09 15:57:347- Start Save output to file2015-03-09 15:57:347- End Save output to file2015-03-09 15:57:34 由日志可以看出，用时最长的是在第5步，有开始到结束共用时1小时10秒。这一步是利用训练数据训练SVM模型，也即是通过支持向量机训练出一个手写数字识别的分类器模型的过程。 第七步是利用生成的模型来对新的数据进行预测，即是对新的手写数字进行识别。用时17分22秒。 12345678910111213141516171819202122232425262728293031323334353637log-21- Start 载入训练数据2015-03-10 02:43:271- End 载入训练数据2015-03-10 02:43:452- Start 删除列头2015-03-10 02:43:452- End 删除列头2015-03-10 02:43:593-Start 载入测试数据2015-03-10 02:43:593- End 载入测试数据2015-03-10 02:44:214 -Start 删除列头2015-03-10 02:44:214-End 删除列头2015-03-10 02:44:305-Start 设置分类器并训练模型2015-03-10 02:44:305-End 模型训练完成2015-03-10 04:04:196- Start 利用模型预测测试数据中的手写数字2015-03-10 04:04:196-End 预测2015-03-10 04:21:187- Start 保存输出文件2015-03-10 04:21:187- End 结束！2015-03-10 04:21:18 第二次训练，模型生成的时间是1小时19分39秒。预测用时16分59秒。 遇到了那些问题？那些问题已经解决了，哪些没有解决？ 梳理SVM流程如下 上图中涉及的理论较繁，而且理解难度不小。对于各方面还需要多加理解。 下一步的计划 下一步的计划从以下三个路线出发 手写数字识别这个问题的描述 SVM如何应用到手写数字识别 pygame实现手写数字识别系统","categories":[{"name":"毕业设计系列","slug":"毕业设计系列","permalink":"http://example.com/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"SVM入门","slug":"SVM入门","permalink":"http://example.com/tags/SVM%E5%85%A5%E9%97%A8/"}]},{"title":"程序员必须知道的10大基础实用算法及其讲解-@慕可网制作","slug":"alogrithms/程序员必须知道的10大基础实用算法及其讲解-慕可网制作","date":"2015-02-08T03:24:07.000Z","updated":"2023-07-16T01:39:35.560Z","comments":true,"path":"2015/02/08/alogrithms/程序员必须知道的10大基础实用算法及其讲解-慕可网制作/","link":"","permalink":"http://example.com/2015/02/08/alogrithms/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%8410%E5%A4%A7%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%94%A8%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E8%AE%B2%E8%A7%A3-%E6%85%95%E5%8F%AF%E7%BD%91%E5%88%B6%E4%BD%9C/","excerpt":"","text":"算法一：快速排序算法 快速排序算法是由东尼.霍尔所发展的一种排序算法。在平均状况下，排序n个项目要O(nlog n)次比较。在最坏状况下则需要O(n2)次比较，但这种状况并不常见。事实上，快速排序O(n log n)通常明显比其他算法更快，因为它的内部循环结构(inner loop)可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法(Divide and conquer)策略来把一个串行(list)分为两个子串行(sub-lists)。 gif动图 算法步骤： 从数列中挑出一个元素，称为“基准”(pivot)。 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆放基准的后面(相同的数可以到任一边)。在这个分区退出之后，该基准就处在数列的中间位置。这个称为分区(partition)操作。 递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序。 递归的最底部情形，数列的大小是零或者一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代(iteration)中，它至少会把一个元素摆到它最后的位置去。 算法二：堆排序算法 堆排序(Heapsort)是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于(或者大于)它的父节点。 堆排序的平均时间复杂度为O(nlog n)。 gif动图 算法步骤： 创建一个堆H[0…n-1]。 把堆首(最大值)和堆尾互换。 把堆的尺寸缩小1，并调用shift_down(0)，目的是把新的数组顶端数据调整到相应位置。 重复步骤2，直到堆的尺寸为1。 算法三：归并排序 归并排序(Merge sort，台湾译作：合并排序)是建立在归并操作上的一种有限的排序算法。该算法是采用分治法(Divide and conquer)的一个非常典型的应用。 算法步骤： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。 设定两个指针，最初位置分别为两个已经排序序列的起始位置。 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。 重复步骤3直到某一指针达到序列尾。 将另一序列剩下的所有元素直接复制到合并序列尾。 gif动图 算法四：二分查找算法 二分查找算法是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或小于中间元素，则在数组大于或者小于中间元素的那一半查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为O(log n)。 算法五：BFPRT(线性查找算法) BFPRT算法解决的问题十分经典，即从某n个元素的序列中选出第k大(第k小)的元素，通过巧妙的分析，BFPRT可以保证在最坏情况下仍为线性时间复杂度。该算法的思想与快速排序思想相似，当然，为使得算法在最坏情况下，依然能达到O(n)的时间复杂度，五位算法作者做了精妙的处理。 算法步骤： 将n个元素每5个一组，分成n&#x2F;5(上界)组。 取出每一组的中位数，任意排序方法，比如插入排序。 递归地调用selection算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个。 用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k。 用i &#x3D;&#x3D; k， 返回x;若i&gt;k，在大于x的元素中递归查找第i-k的元素。终止条件：n &#x3D; 1时，返回的即使i小元素。 算法六：DES(深度优先搜索) 深度优先搜索算法(Depth-First-Search)，是搜索算法的一种。它沿着树的深度遍历 树的节点，尽可能深的搜索树的分支。当节点v的所有边都已被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。DFS属于盲目搜索。 深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现DFS算法。 深度优先遍历图算法步骤： 访问顶点v。 依次从v的未被访问的临接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问。 若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。 上述描述可能比较抽象，举个例子： DFS在访问途中某一起始顶点v后，由v出发，访问它的任一邻接顶点w1;再从w1出发，访问与w1邻接但还没有访问过的顶点w2；然后再从w2出发，进行类似的访问，。。。如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止。 接着，退回一步，退回前一次刚访问过的顶点，看是否还有其他没有被访问的邻接顶点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。 算法七：BFS(广度优先搜索) 广度优先搜索算法(Breadth-First-Search),是一种图形搜索算法。简单的说，BFS是从跟节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均未被访问，则算法终止。BFS同样属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。 算法步骤： 首先将根节点放入队列中。 从队列中取出第一个节点，并检验它是否为目标。如果找到目标，则结束搜寻并回传结果，否则将它所有尚未检验过的直接子节点加入队列中。 若队列为空，表示整张图都检查过了–亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。 重复步骤2. gif动图。 算法八：Dijkstra算法 戴克斯特拉算法(Dijkstra’s algorithm)是有荷兰计算机科学家艾兹赫尔.戴克斯特拉提出。迪克斯切算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到了一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。 该算法的输入包含了一个有权重的有向图G，以及G中的一个来源顶点S。我们以V表示G中所有顶点的集合。每一个图中的边，都是两个顶点所形成的有序元素树。(u, v)表示从顶点u到v有路径相连。我们以E表示G中所有边的集合，而边的权重则由权重函数w: E –&gt; [0, 无穷大]定义。因此，w(u, v)就是从顶点u到顶点v的非负权重(weight)。边的权重可以想象成两个顶点之间的距离。任何两点间的路径的权重，就是该路径上所有边的权重总和。已知有V中有顶点s及t,Dijkstra算法可以找到s到t的最低权重路径(例如，最短路径)。这个路径也可以在一个图中，找到从一个顶点s到任何其他顶点的最短路径。对于不含负权的有向图，Dijkstra算法是目前已知的最快的单源最短路径算法。 算法步骤： 初始时令 S&#x3D;{V0}，T&#x3D;{其他顶点}，T中为顶点对应的距离值，若存在，d(V0,Vi)为弧上的权值，若不存在，d(V0,Vi)为无穷大。 从T中选取一个其距离值为最小的顶点W且其不再S中，加入S。 对其余T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值缩短，则修改此距离值。 重复上述步骤2，3，直到S中包含所有顶点，即W&#x3D;Vi为止。 图片 算法九：动态规划算法 动态规划(Dynamic Programming)是一种在数学，计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题求解复杂问题的方法。动态规划常常适用于重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往少于朴素解法。 动态规划背后的基本思想非常简单。大致上，若要了解一个给定问题，我们需要解其不同的部分(即子问题)，再合并子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 关于动态规划最经典的问题当属背包问题。 算法步骤： 最优子结构性质。如果问题的最优解所包含的子问题也是最优的，我们就称该问题具有最优子结构性质(即满足最优化原理)。最优子结构性质为动态规划算法解决问题提供了重要线索。 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对美一个子问题只计算一次，然后将子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。 算法十：朴素贝叶斯分类算法 朴素贝叶斯分类算法是一种基于贝叶斯定理的简单概率分类算法。贝叶斯分类的基础是概率推理，就是在各种条件的存在不确定，仅知其出现概率的情况下，如何完成推理和决策任务。概率推理是与确定性推理相对应的。而朴素贝叶斯分类器是基于独立假设的，即假设样本每个特征与其他特征都不相关。 朴素贝叶斯分类器依靠精确的自然概率模型，在有监督学习的样本集中能获得非常好的分类效果。在许多实际应用中，朴素贝叶斯模型参数估计使用最大似然估计方法，换言之朴素贝叶斯模型能工作并没有用到贝叶斯概率或者任何贝叶斯模型。 尽管是带着这些朴素思想和过于简单化的假设，但朴素贝叶斯分类器在很多复杂的现实情形中仍能够取得相当好的效果。 文章来源：36大数据","categories":[{"name":"技能-修行-进步","slug":"技能-修行-进步","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5/"}],"tags":[{"name":"10大基础实用算法","slug":"10大基础实用算法","permalink":"http://example.com/tags/10%E5%A4%A7%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%94%A8%E7%AE%97%E6%B3%95/"}]},{"title":"Django-1-7-3-Tutorial-Part-3-视图和模板","slug":"技能-修行-进步-Django/Django-1-7-3-Tutorial-Part-3-视图和模板","date":"2015-01-27T08:46:50.000Z","updated":"2023-07-22T01:33:42.702Z","comments":true,"path":"2015/01/27/技能-修行-进步-Django/Django-1-7-3-Tutorial-Part-3-视图和模板/","link":"","permalink":"http://example.com/2015/01/27/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Django/Django-1-7-3-Tutorial-Part-3-%E8%A7%86%E5%9B%BE%E5%92%8C%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"本教程是接着上一节教程继续的。我们继续讨论网页投票(Web-poll)应用程序，然后关注与创建公共接口–“视图”。 哲学 一个视图是在你的Django应用中一种有特定应用功能和有一个模板的网页的“类型”。譬如，在一个博客应用中，你可能需要以下视图： 博客首页–显示最新的博客 “具体”页面的入口–单独入口的固定链接 把博客按照年排序的架构页面–给定年份，按月列出所有的文章 把博客按照月排序的架构页面–给定月份，按日列出所有的文章 把博客按照日排序的架构页面–给定日期，列出所有的文章 评论操作–给指定的文章下评论 在我们的投票应用中(poll)，我们已经有了以下四个页面： 问题“首页”–显示最新的问题 问题“具体页”–显示一个问题文本，不能显示结果，但是提供投票表格 问题“结果页”–为指定的问题显示投票结果 投票操作–在给定的问题中投给定的选项 在Django中，网页和其他的内容页是通过视图展示的。每一个视图是通过一个简单的Python功能展示的(或者方法，如果在基于类的视图下)。Django通过测试请求的URL而选择视图(更准确的说，是跟在域名后面的URL部分)。 现在你在浏览网页的时候可能看过这样的网页链接：“ME2&#x2F;Sites&#x2F;dirmod.asp?sid&#x3D;&amp;type&#x3D;gen&amp;mod&#x3D;Core+Pages&amp;gid&#x3D;A6CD4967199A42D9B65B1B”。但是更值得我们高兴的是，Django允许我们使用比以上更优雅的链接模式。 一个URL模式是一个简单的URL通常格式–譬如： 要从一个URL得到一个视图，Django利用了我们熟知的’URLconfs’。一个URLconf把一个URL模式(通常被描述为正则表达式)映射到一个视图。 本节教程提供了URLconfs的基本用法，然后你可以参考django.core.urlresolvers得到更多信息。 写你的第一个视图 让我们开始写第一个视图吧。打开文件polls&#x2F;views.py然后写入以下python代码： polls&#x2F;views.py 1234from django.http import HttpResponsedef index(request): return HttpResponse(&quot;Hello, world. You&#x27;re at the polls index.&quot;) 这可能是Django中最简单的视图了。要调用这个视图，我们需要把它映射到一个URL–然后我们就需要一个URLconf。 在polls目录下创建一个URLconf，创建一个urls.py文件。你的app目录应该看起来是这样： 在polls&#x2F;urls.py文件中加入以下代码： polls&#x2F;urls.py 123456from django.conf.urls import patterns, urlfrom polls import viewsurlpatterns = patterns(&#x27;&#x27;, url(r&#x27;^$&#x27;, views.index, name=&#x27;index&#x27;),) 下一步就是在polls.urls模块中指定根URLconf。在mysite&#x2F;urls.py中插入一个**include()**，像这样： mysite&#x2F;urls.py 1234567from django.conf.urls import patterns, include, urlfrom django.contrib import adminurlpatterns = patterns(&#x27;&#x27;, url(r&#x27;^polls/&#x27;, include(&#x27;polls.urls&#x27;)), url(r&#x27;^admin/&#x27;, include(admin.site.urls)),) 和你所见的不匹配吗？如果你在urlpatterns定义之前就看见了**admin.autodiscover()**，你可能是在用一个和本教程不匹配的版本，你应该更改Django的版本。 你现在可以把**首页(index)视图转换为URLconf。在你的浏览器中输入http://localhost:8000/polls/，按下Enter键，你应该可以看到文本“Hello, world. You’re at the polls index.”，它是在首页(index)**视图所定义的。 url()函数有四个参数，其中两个是必须的：regex(正则表达式)和view(视图),两个是可选的：kwargs和**name(名字)**。现在，让我们来了解一下这些参数具体是什么来的。 url()参数：regex 术语regex通常是**regular expression(正则表达式)**的缩写，它是一个字符串匹配的语法规则，在这里，它是url模式的匹配。Django从第一个正则表达式开始，然后把它们造一个列表，把请求的URL和每一个正则表达式单元进行比较，然后找到匹配的那一个。 请注意，这些正则表达式不会搜寻GET和POST的参数或者域名。譬如，在请求URLhttp://www.example.com/myapp/**中，URLconf会寻找**myapp/**。而在请求URL**http://www.example.com/myapp/?page=3中，URLconf也会寻找**myapp&#x2F;**。 如果你不了解正则表达式，请看Wikipedia’s entry或者re模块的文档。另外，O’Reilly的书–Jeffrey Friedl著的《Mastering Regular Expressions》非常不错。实际上，你不需要成为正则表达式方面的专家，如果你仅仅需要知道一些简单的模式匹配的话。事实上，复杂的正则表达式有比较弱的检查能力，所以，你不太可能依赖正则表达式。 最后，性能笔记：这些正则表达式在URLconf模块加载时会被首次编译。它们非常快(只要查找的不是太复杂的正则表达式)。 url()参数：view 当Django匹配到了正则表达式时，Django调用指定的视图函数，第一个参数是一个HttpRequest对象，其他的参数是根据需要从正则表达式中捕捉的任意值。如果正则表达式是用简单的捕捉，值就会当成位置参数来传递；如果正则表达式是用命名捕捉，值就会被当成关键字参数来传递。我们稍后会给出例子进行说明。 url()参数：kwargs 任意的关键字参数都可以传递到目标视图中的字典。在这个教程中我们不会讨论这个特性。 url()参数：name 对你的URL命名可以让你清楚地从Django中的任何地方中引用，特别是在模板中。这个有力的特性让你对项目中的url模式做全局的修改，当你仅仅创建了单个文件时。 写更多的视图 现在让我们在polls&#x2F;views.py文件中添加更多的视图。这些视图可能有小小的不同，因为它们有一个参数。 polls&#x2F;views.py 123456789def detail(request, question_id): return HttpResponse(&quot;You&#x27;re looking at question %s.&quot; % question_id)def results(request, question_id): response = &quot;You&#x27;re looking at the results of question %s.&quot; return HttpResponse(response % question_id)def vote(request, question_id): return HttpResponse(&quot;You&#x27;re voting on question %s.&quot; % question_id) 把这些新的视图通过添加以下的url()调用写进polls.urls模块： polls&#x2F;urls.py 1234567891011121314from django.conf.urls import patterns, urlfrom polls import viewsurlpatterns = patterns(&#x27;&#x27;, # ex: /polls/ url(r&#x27;^$&#x27;, views.index, name=&#x27;index&#x27;), # ex: /polls/5/ url(r&#x27;^(?P&lt;question_id&gt;\\d+)/$&#x27;, views.detail, name=&#x27;detail&#x27;), # ex: /polls/5/results/ url(r&#x27;^(?P&lt;question_id&gt;\\d+)/results/$&#x27;, views.results, name=&#x27;results&#x27;), # ex: /polls/5/vote/ url(r&#x27;^(?P&lt;question_id&gt;\\d+)/vote/$&#x27;, views.vote, name=&#x27;vote&#x27;), ) 在浏览器中打开**”&#x2F;polls&#x2F;34&#x2F;“浏览一下。它运行detail()方法并且根据你的URL提供的ID显示你的东西。试一下“&#x2F;polls&#x2F;34&#x2F;results&#x2F;”和&#x2F;polls&#x2F;34&#x2F;vote&#x2F;**–这些会显示占位符结果和投票页面。 当某人从你的网站请求网页时–譬如，**&#x2F;polls&#x2F;34&#x2F;,Django将会加载mysite.urls模块，因为它是被ROOT_URLCONF设置所指向的。它找到名叫urlpatterns的变量然后遍历正则表达式。include()函数只是引用了其他的URLconfs。注意到关于include()方法的正则表达式没有$(字符串匹配的结束符)而只有末尾斜杠。无论何时Django遇上了include()**方法，它会发送剩余的字符串到包含的URLconf给下一步做准备，而砍掉其他的部分。 **include()背后的思想是使得URLs即插即用，用起来非常简单。由于polls在它们自己的URLconf(polls&#x2F;urls.py)中，它们可以被放在&#x2F;polls&#x2F;或者&#x2F;fun_polls&#x2F;或者&#x2F;content&#x2F;polls&#x2F;**或者其它的根路径后面，应用还是可以运行的。 如果用户去到系统中的**&#x2F;polls&#x2F;34&#x2F;**，它会发生以下事情： Django会对**^polls&#x2F;**进行匹配 然后，Django会去掉匹配的文本(“polls&#x2F;”)并且把剩下的文本34&#x2F;发送到polls.urlsURLconf作进一步的操作，**34&#x2F;是匹配,然后对detail()**视图进行调用： **question_id&#x3D;’34’是来自。用圆括号把匹配到的模式文本括起来当成一个参数传到视图函数；定义了将要确定匹配模式的名字；而\\d+**是一个匹配一串数字的正则表达式。 因为URL模式是一个正则表达式，它们没有任何限制。没必要添加URL烂尾，譬如**.html**,除非你想要加，然后你可以这样做： 但是不要这样做，它看起来傻傻的。 写一些起作用的视图 每一个视图都应该做一到两样事情：返回一个包含请求页的内容的HttpResponse对象，或者产生一个像Http404这样的异常。剩下的就由你决定。 你的视图能够从数据库中读取记录，或者不读。它能够使用一个像Django这样的模板系统，或者第三方模板系统，又或者不用。它能够生成一个PDF文件，输出XML，飞速创建一个ZIP文件，或者任何你想要的文件，使用任何你想要的Python库。 Django想做的就是一个HttpResponse，或者一个异常。 由于方便，我们使用Django默认的数据库API，就是我们在教程1当中介绍的。下面是我们在**index()**视图中插入新的东西，它显示了系统中最新的5个投票问题，根据发布日期通过逗号隔开： polls&#x2F;views.py123456789from django.http import HttpResponsefrom polls.models import Questiondef index(request): latest_question_list = Question.objects.order_by(&#x27;-pub_date&#x27;)[:5] output = &#x27;,&#x27;.join([p.question_text for p in latest_question_list])# leave the rest of views (detail, results, vote) unchanged 但还有一个问题：页面的设计是在视图硬性写定了。如果你像更改页面的设计，你需要重新编辑Python 代码。所以让我们使用Django的模板系统把设计和Python代码通过创建一个视图可调用的模板来分开。 首先，在你的polls目录下创建一个名为templates的文件。Django会在那里进行搜寻的。 Django的TEMPLATE_LOADERS设置包含一系列知道如何从不同资源中导入模板的可调用方法。其中默认的方法是django.template.loaders.app_directories.Loader，它在每一个INSTALLED_APPS中寻找一个“模板”子目录。这就是为什么Django在没有修改TEMPLATE_DIRS的情况下知道怎么找到poll模板的原因。 组织模板我们可以把所有的模板放在一起，在一个大的模板目录中，而且它可以工作的很顺利。但是，这个模板是属于polls应用的，所以不像上一个教程中我们介绍的管理员模板那样，我们把它放在程序的模板目录而不是项目的模板目录。我们会讨论更多关于这个更多的可重用的app教程，并对其进行解释。 在你刚刚创建的template模板目录中，创建另外一个叫做polls的目录，然后再里面创建一个index.html文件。换句话说，你的模板应该是在polls&#x2F;templates&#x2F;polls&#x2F;index.html目录中。正是由于上面我们讨论的关于app_directories模板加载器是如何工作的，你可以像polls&#x2F;index.html一样通过Django简单的找到模板文件。 模板命名空间现在我们可能不需要把我们的模板放进polls&#x2F;templates目录(而不是在polls的子目录下新建一个)，但这确实是一个坏主意。Django会选择它第一个匹配到的模板名字，如果你在不同的目录下有相同的名字的应用，Django就不会对它们进行分辨。我们应该要为Django正确指定哪一个模板，最简单的方法来保证这样的事情就是通过给它们创建命名空间。也就是说，把那些模板放进另一个为本应用命名的目录。 在模板中写进以下代码： polls&#x2F;templates&#x2F;polls&#x2F;index.html123456789&#123;% if latest_question_list %&#125; &lt;ul&gt; &#123;% for question in latest_question_list %&#125; &lt;li&gt;&lt;a href=&quot;/polls.&#123;&#123; question.id &#125;&#125;/&quot;&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&#123;% else %&#125; &lt;p&gt;No polls are available.&lt;/p&gt;&#123;% endif %&#125; 现在让我们更新polls&#x2F;views.py中的视图来使用模板： polls&#x2F;views.py123456789101112from django.http import HttpResponsefrom django.template import RequestContext, loaderfrom polls.models import Questiondef index(request): latest_question_list = Question.objects.order_by(&#x27;-pub_date&#x27;)[:5] template = loader.get_template(&#x27;polls/index.html&#x27;) context = RequestionContext(request, &#123; &#x27;latest_question_list&#x27;: latest_question_list, &#125;) return HttpResponse(template.render(context)) 上面的代码加载了polls&#x2F;index.html模板，然后传递了一个context。context是一个匹配模板变量名到Python对象的字典。 在你的浏览器里点击**”&#x2F;polls&#x2F;“加载页面，你会看到包含Tutorial_1中的“What’s up”**问题的无序列表。这个链接指向问题详细内容页。 一个快捷键:render() 这是一种常用的语法：加载一个模板，传递一个context，然后返回一个对显示模板结果的HttpResponse对象。Django提供一个快捷键。下面是完整的**index()**视图，重写： polls&#x2F;views.py123456789from django.shortcuts import renderfrom polls.models import Questiondef index(request): lastest_question_list = Question.objects.order_by(&#x27;-pub_date&#x27;)[:5] context = &#123;&#x27;lastest_question_list&#x27;: lastest_question_list&#125; return render(request, &#x27;polls/index.html&#x27;, context) 既然我们搞好了所有的视图，我们不需要去导入loader,RequestContext和HttpResponse(如果你需要detail和results，vote的根方法，你需要保留HttpResponse对象)。 render()方法的第一个参数是Request对象，第二个参数是一个模板名，然后第三参数是可选的，它是一个字典类型。方法返回的是一个带根据给定的context而呈现的给定的模板的HttpResponse对象。 报告404错误 现在，让我们浏览一下问题详细视图-根据给定的poll显示问题文本的页面。这就是视图： polls&#x2F;views.py123456789101112from django.http import Http404from djang.shortcuts import renderfrom polls.models import Question# ...def detail(request, question_id): try: question = Question.objects.get(pk = question_id) except Question.DoesNotExist: raise Http404(&quot;Question does not exist&quot;) return render(request, &#x27;polls/detail.html&#x27;, &#123;&#x27;question&#x27;: question&#125;) 新的概念：如果问题的请求ID不存在，那么视图就会产生要给404异常。 我们会在稍后讨论你能够在polls&#x2F;detail.html模板中放入什么，但是如果你想快速地运行上面的例子，文件应该包含如下： polls&#x2F;templates&#x2F;polls&#x2F;detail.html1&#123;&#123; question &#125;&#125; 会让你现在开始。 快捷键：get_object_or_404() 这是一种常用的语法：如果对象不存在，利用get()方法报告一个Http404异常。Django提供一个快捷键。下面是detial视图，重写： polls&#x2F;views.py1234567from django.shortcuts import get_object_or_404, renderfrom polls.models import Question# ...def detail(request, question_id): question = get_object_or_404(Question, pk = question_id) return render(request, &#x27;polls/detail.html&#x27;, &#123;&#x27;question&#x27;:question&#125;) get_object_or_404()函数的第一个参数是要给Django模型，然后有数个关键字参数，它们是被传递到模型管理的get()函数。如果对象不存在，它会报告Http404异常。 Philosophy为什么我们在更高的水平上使用帮助函数get_object_or_404()而不是自动获取ObjectDoesNotExist异常，或者通过模型API报告Http404异常而不是ObjectDoesNotExist异常。因为这样会把模型层结合视图层。Django的一个最重要的设计目标是保持低耦合。在Django.shortcuts模型中引入了一些强耦合。 还有一个get_list_or_404()函数，它就像get_object_or_404()函数一样工作。用filter()而不是get()方法。它会报告Http404异常，如果列表是空的话。 使用模板系统 回到我们的poll应用的detail()视图。给定context变量question，这就是polls&#x2F;detail.html模板的代码：","categories":[{"name":"技能-修行-进步-Django","slug":"技能-修行-进步-Django","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Django/"}],"tags":[{"name":"Django-Models","slug":"Django-Models","permalink":"http://example.com/tags/Django-Models/"}]},{"title":"Django-1-7-3-Tutorial-Part-2-管理站点","slug":"技能-修行-进步-Django/Django-1-7-3-Tutorial-Part-2-管理站点","date":"2015-01-19T01:27:02.000Z","updated":"2023-07-22T01:33:36.700Z","comments":true,"path":"2015/01/19/技能-修行-进步-Django/Django-1-7-3-Tutorial-Part-2-管理站点/","link":"","permalink":"http://example.com/2015/01/19/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Django/Django-1-7-3-Tutorial-Part-2-%E7%AE%A1%E7%90%86%E7%AB%99%E7%82%B9/","excerpt":"","text":"本节教程接着Part-1-模型继续，我们继续网络民意调查(Web-poll)应用，然后把焦点放在Django的自生成的管理员站点。 哲学为你的员工或客户自动生成管理员站点，让它可以很方便的对内容进行增删改是一件不需要太多创新的比较乏味的事情。Django是在一个新闻工作室的环境下编写的，“内容出版商”站点和“公共”站点之间有比较清晰的界限。站点管理员利用系统添加新闻故事，事件，体育等等，然后内容会显示在公共站点。Django为站点管理员编辑内容创建了统一的接口。 新建一个管理用户 首先我们需要创建一个能够登入管理站点的用户。运行以下命令：1$ python manage.py createsuperuser 然后输入你想要的用户名：1Username: admin 然后继续输入你的邮箱地址：1Email address: admin@example.com 最后一步就是输入你的密码。你需要输入2次来确认你的密码：123Password: **********Password (again): *********Superuser created successfully. 我的截图： 打开开发者服务器 Django管理站点默认是激活的。让我们开启开发者服务器对它一探究竟吧。 回想一下Part-1-模型，你是怎么开始服务器的：1$ python manage.py runserver 现在，打开浏览器，然后再输入以下地址http://127.0.0.1:8000/admin/。你就可以看到管理员登陆界面了： 由于页面是自动翻译的，所以可能登陆页面是以你的语言显示的，取决于你的浏览器的设置了。 和你的不同吗？如果你的登陆界面打不开，而是出现了这样的错误： 123ImportError at/admin/cannot import name patterns... 进入管理站点 现在，利用你刚才设置的账户和密码登录管理员站点，你应该看到这样的页面： 你应该会看到两种可编辑的内容：Groups和Users。它们是由django.contrib.auth提供的，这个认证框架是由Django支持的。 使投票(poll)应用在管理站点中被修改 但是我们的投票(poll)应用在哪里？它并不再管理首页上展示。 只需要做一件事情：我们需要告知管理站点Question对象有一个管理接口。打开polls&#x2F;admin.py文件，然后对它们进行以以下编辑： polls&#x2F;admin.py1234from django.contrib import adminfrom polls.models import Questionadmin.site.register(Question) 探索免费的管理功能 既然我们注册了Question，那么Django就会在管理首页进行显示了。 点击Question。你就进入了question的修改列表。这个页面显示了数据库中的所有的问题，然后让你选择哪个进行修改。这里显示了问题“What’s up?”在上一部分教程中： 点击“What’s up?”，然后编辑它： 这里要注意的是： 这个表格是根据Question模型自动生成的。 这个不同的模型的域类型(DateTimeField,CharField)对应到合适的HTML输入小部件。每一个字段类型明白自己在Django的管理站点中如何展示。 每一个DateTimeField都有一个免费的Javascript快捷方式。日期(Date)会有一个“今天(today)”的快捷方式和日历弹框选择，然后时间(Time)会有一个“现在(now)”的快捷方式和一个便利的弹框，它有常用时间的输入。 页面的底部给你一些选项： 保存(save)—保存修改和返回当前对象类型的修改列表页面。 保存并且继续编辑(Save and continue editing)—保存修改并且重载当前对象的管理页面。 保存并且继续添加(Save and add another)—保存修改并且为当前对象加载一个新的空白的表格。 删除(Detele)—显示一个删除确认页面。 如果发布日期(“Date published”)的值和你在第一部分创建的时间不相同，那很有可能你没有设置正确的时区。修改时区，然后重载当前页面看看是否准确。 通过点击“今天”和“现在”快捷键来修改“发布日期”，然后点击“保存并且继续编辑”。点击上方的“历史记录”，你会看到一个通过Django管理对当前对象做的所有修改的列表页面，有时间戳和修改者的用户名： 添加相关的对象 OK，我们有了Question管理页面。但是一个Question有多个Choices，而管理页面不显示choices. 但是。 有两种方法可以解决这个问题。第一个通过用户admin注册Choice就像我们注册Question一样。非常简单： polls&#x2F;admin.py1234from django.contrib import adminfrom polls.models import Choice, Question#...admin.site.register(Choice) 现在，Choices在Django中是一个可用的选项。添加choice（Add choice）的页面应该像这样： 在这个表格当中，Question属性是一个选择框(select box)，它包含了数据库当中的每一个问题(question)。Django知道**外键(ForeignKey)在管理页面中应该是一个**框。在我们的例子中，只有一个问题。 注意到”Add Another”这个链接到下一个“Question”。每一个带外键的对象都会自动生成这个链接。当你点击”Add Another”这个链接时，你可以得到一个带有“Add question”表格的弹出窗口。如果你在那个窗口中添加一个问题，然后点击“保存”按钮，Django会把问题保存到数据库，并且动态把它添加为一个你所见到的在“Add choice”表格中可选的选项。 但实际上，这并不是一个有效的添加Choice对象到系统的方法。如果能在创建Question的同时直接添加多个Choice，那样更好。让我们来试试吧。 为Choice模型删除register()方法。然后，编辑Question注册代码如下： polls&#x2F;admin.py12345678910111213141516171819from django.contrib import admin# Register your models here.from polls.models import Question, Choiceclass ChoiceInline(admin.StackedInline): &quot;&quot;&quot;docstring for ChoiceInline&quot;&quot;&quot; model = Choice extra = 3class QuestionAdmin(admin.ModelAdmin): fieldsets = [ (None, &#123;&#x27;fields&#x27;:[&#x27;question_text&#x27;]&#125;), (&#x27;Date information&#x27;, &#123;&#x27;fields&#x27;:[&#x27;pub_date&#x27;], &#x27;classes&#x27;:[&#x27;collapse&#x27;]&#125;), ] inlines = [ChoiceInline]admin.site.register(Question,QuestionAdmin) 它告诉Django：Choice对象在Question管理页面上边界。默认情况下，提供3个choice填写属性。 加载“Add question”页面来看一下： 它是这样子工作的：相关的Choice有三个可填—由Extra指定的，每一次你返回一个已经创建好的对象的Change页面，你又可以得到3个额外的choice可填。 在3个choice的底部，你可以找到一个“Add another Choice”链接。如果你点击它，一个新增的choice就可诞生。如果你像删除新增的choice，那么你可以点击这个choice的右上角的X。注意原来的3个choice是不可删除的。 但是有一个小问题，它占用了太多的屏幕空间。所以，Django提供了一个列表的形式显示相关的行内对象，你只需要修改ChoiceInline代码： polls&#x2F;admin.py12class ChoiceInline(admin.TabularInline): #.... 用TabularInline而非StackedInline，相关的对象就会以表格的形式显示得更简洁。 注意到以上还有一个删除的按钮，它可以删除新增的行。 自定义管理表格 对你还没写的代码感到惊叹吧。通过admin.site.register(Question)来注册Question模型，Django能够构建一个默认的表格表现形式。通常，你会想自定义自己的管理表单，你只要通过注册告知Django你想怎么注册这个对象就OK了。 通过重新排序表格中字段，我们来看看效果。修改**admin.site.register(Question)**这一行： polls&#x2F;admin.py12345678from django.contrib import adminfrom polls.models import Questionclass QuestionAdmin(admin.ModelAdmin): fields = [&#x27;pub_date&#x27;, &#x27;question_text&#x27;]admin.site.register(Question, QuestionAdmin) 你遵循这种模式—创建一个模型管理对象，然后把它当成第二参数传给admin.site.register()—任何时候都可以修改。 以上的修改是把“发布日期”(Date published)放在了“问题”(Question)这个字段的前面： 虽然两个字段看起来不够酷，但是对于数十个字段的表格来说，选择一个符合直觉的排序是一个非常重要的实用细节。 说到数十个字段的表格，你可能想到把一个表格分离成多个属性(字段). polls&#x2F;admin.py123456789from django.contrib import adminfrom polls.models import Questionclass QuestionAdmin(admiin.ModelAdmin): fieldsets = [ (Node, &#123;&#x27;fields&#x27;:[&#x27;Question_text&#x27;]&#125;), (&#x27;Date information&#x27;, &#123;&#x27;fields&#x27;:[&#x27;pub_date&#x27;]&#125;), ]admin.site.register(Question, QuestionAdmin) 在**属性(fieldsets)**中的每一个元组的第一个元素是这个属性的标题。以上的表格就是这样： 你可以为属性(fieldsets)注入任意的HTML类。Django提供了一个**折叠(collapse)**类用于展示默认是折叠的特定的属性。如果你有一个包含了许多个不常用的属性的很长的表格，那么这个类是非常有用的： polls&#x2F;admin.py123456789from django.contrib import adminfrom polls.models import Questionclass QuestionAdmin(admin.ModelAdmin): fieldsets = [ (None, &#123;&#x27;fields&#x27;:[&#x27;question_text&#x27;]&#125;), (&#x27;Date information&#x27;, &#123;&#x27;fields&#x27;:[&#x27;pub_date&#x27;], &#x27;classes&#x27;:[&#x27;collapse&#x27;]&#125;), ]admin.site.register(Question, QuestionAdmin) 添加相关的对象 OK，我们有了Question管理页面。但是一个Question有多个Choices，而管理页面不显示choices. 但是。 有两种方法可以解决这个问题。第一个通过用户admin注册Choice就像我们注册Question一样。非常简单： polls&#x2F;admin.py1234from django.contrib import adminfrom polls.models import Choice, Question#...admin.site.register(Choice) 现在，Choices在Django中是一个可用的选项。添加choice（Add choice）的页面应该像这样： 在这个表格当中，Question属性是一个选择框(select box)，它包含了数据库当中的每一个问题(question)。Django知道**外键(ForeignKey)在管理页面中应该是一个**框。在我们的例子中，只有一个问题。 注意到”Add Another”这个链接到下一个“Question”。每一个带外键的对象都会自动生成这个链接。当你点击”Add Another”这个链接时，你可以得到一个带有“Add question”表格的弹出窗口。如果你在那个窗口中添加一个问题，然后点击“保存”按钮，Django会把问题保存到数据库，并且动态把它添加为一个你所见到的在“Add choice”表格中可选的选项。 但实际上，这并不是一个有效的添加Choice对象到系统的方法。如果能在创建Question的同时直接添加多个Choice，那样更好。让我们来试试吧。 为Choice模型删除register()方法。然后，编辑Question注册代码如下： polls&#x2F;admin.py12345678910111213141516171819from django.contrib import admin# Register your models here.from polls.models import Question, Choiceclass ChoiceInline(admin.StackedInline): &quot;&quot;&quot;docstring for ChoiceInline&quot;&quot;&quot; model = Choice extra = 3class QuestionAdmin(admin.ModelAdmin): fieldsets = [ (None, &#123;&#x27;fields&#x27;:[&#x27;question_text&#x27;]&#125;), (&#x27;Date information&#x27;, &#123;&#x27;fields&#x27;:[&#x27;pub_date&#x27;], &#x27;classes&#x27;:[&#x27;collapse&#x27;]&#125;), ] inlines = [ChoiceInline]admin.site.register(Question,QuestionAdmin) 它告诉Django：Choice对象在Question管理页面上边界。默认情况下，提供3个choice填写属性。 加载“Add question”页面来看一下： 它是这样子工作的：相关的Choice有三个可填—由Extra指定的，每一次你返回一个已经创建好的对象的Change页面，你又可以得到3个额外的choice可填。 在3个choice的底部，你可以找到一个“Add another Choice”链接。如果你点击它，一个新增的choice就可诞生。如果你像删除新增的choice，那么你可以点击这个choice的右上角的X。注意原来的3个choice是不可删除的。 但是有一个小问题，它占用了太多的屏幕空间。所以，Django提供了一个列表的形式显示相关的行内对象，你只需要修改ChoiceInline代码： polls&#x2F;admin.py12class ChoiceInline(admin.TabularInline): #.... 用TabularInline而非StackedInline，相关的对象就会以表格的形式显示得更简洁。 注意到以上还有一个删除的按钮，它可以删除新增的行。 自定义管理修改列表 既然Question管理页面开启来不错，让我们对“修改列表”页面做一些更改–让一页显示系统中的所有问题。 现在的页面是： 默认情况下，Django显示每个对象的str()内容。但是有时候我们想显示单独的每个属性。这样做的话，就要用到list_display管理选项，它是一个可显示为列的属性的元组： polls&#x2F;admin.py123class QuestionAdmin(admin.ModelAdmin): #... list_display = (&#x27;question_text&#x27;,&#x27;pub_date&#x27;) 为了更好的展示，让我们在自定义的方法表格中添加was_published_recently: polls&#x2F;admin.py123class QuestionAdmin(admin.ModelAdmin): #... list_display = (&#x27;question_text&#x27;, &#x27;pub_date&#x27;, &#x27;was_published_recently&#x27;) 现在问题修改页面变成这样子了： 你可以点击列头来对这些值进行排序–出了was_published_recently列头，因为通过武断的方法输出来进行排序是不支持的。还有注意到was_published_recently列头，默认的，是方法的名字(通过空格来强调)，每一行都包含输出的字符串的表示。 你可以通过给这个方法加一些属性来改善它(在polls&#x2F;models.py文件中)，如下： polls&#x2F;models.py1234567class Question(models.Model): #... def was_publised_recently(self): return self.pub_date &gt;= timezone.now() - datetime.timedelta(days=1) was_published_recently.admin_order_field = &#x27;pub_date&#x27; was_published_recently.boolean = True was_published_recently.short_description = &#x27;Published recently ?&#x27; 参考更多消息，请看list_display 再次编辑你的polls&#x2F;admin.py文件，为Question修改列表页面添加一个改进：用list_filter过滤，添加以下行道QuestioAdmin文件中：1list_filter = [&#x27;pub_date&#x27;] 过滤显示的类型取决于你在过滤的属性的类型。因为pub_date是一个DateTimeField类型，Django自动给出合适的过滤选项：“Any date”,”Today”,”Past 7 days”,”This month”,”This year”. 这些看起来不错，让我们添加一些查找功能：1search_field = [&#x27;question_text&#x27;] 这个会在修改页面的上方添加一个查询框。当输入一些关键字时，Django会查询question_text域。你还可以添加其他的任意域–因为在数据库中用到了LIKE查询，将查询的数量减少了，这样查询的速度更快。 现在是时候给你的修改列表来个分页显示的功能。默认是每一页显示100条。Change list pagination, search boxes, filters, date-hierarchies和column-header-ordering都可以工作。 自定义管理look和feel 明显的，把“Django administration”放在每一个管理页面的头部是不合理的。它只是文本占位而已。 用Django的模板核能修改，但是，Django管理只是供Django自身支持，而且它的接口也是使用Django自身你的模板系统。 自定义你的项目模板 在你的项目目录中创建一个模板(templates)目录。模板能够在Django可使用的任何的文件系统中。(你的服务器运行什么，Django就运行什么）。但是，把你的模板文件夹放在项目目录下是一个很方便的选择。 打开你的设置文件(mysite&#x2F;settings.py文件，记住)，然后添加一个TEMPLATE_DIRS设置。 mysite&#x2F;settings.py Django的源代码在哪？如果你在你的硬盘上找不到你的Django的源代码，运行一下口令： 然后，编辑文件，换掉，包括花括号，换成自己应用的名字。如下： 我们用这种方法向你们传授了怎么覆盖模板。在实际的项目中，你可能更喜欢用django.contrib.admin.AdminSite.site_header的属性来进行定制，因为它更容易。 自定义你的应用模板 聪明的读者可能会问：如果TEMPLATE_DIRS默认是空的，Django是怎么找到默认的管理模板的？答案是：默认情况下，作为后备，Django自动在每个应用程序包中查找templates&#x2F;子目录。(不要忘记django.contrib.admin也是一个应用程序)。 我们的投票(poll)应用并不复杂，而且不需要自定义的管理模板。但是当它变得复杂而且需要对Django的标准管理模板做一些修改以适应新的功能时，修改应用程序模板就会比修改项目中的其他文件要更加小心了。这样，你可以把Poll应用程序添加到任何新的项目中，并且假设它会找到需要的自定义模板。 关于Django怎么找到它的模板文件的更多信息，请参考template loader documentation。 自定管理首页 在一个类似的笔记中，你可能想要自定义Django首页的外观和感觉。 默认情况下，它会根据INSTALLED_APPS文件中所注册的程序进行展示，以字母的排序。你可能想要对布局进行重要的修改。毕竟，首页可能是最重要的管理页面，而且它应该很容易被使用的。 要修改的模板是admin&#x2F;index.html文件。(和上面对admin&#x2F;base_site.html文件做的一样—把它从默认路径复制到你所在的路径。)编辑文件，你可以看到一个额模板变量app_list。这个变量包含了所有安装在Django中的app。你可以不用它，但你可以对它进行重新编码，把链接指向你最想要的特定对象的管理页面。还有，如果你现在看不懂模板语言，不要担心，我们将在下一节中讨论模板语言。 当你熟悉了管理站点，请读下一小节，在投票程序的页面设计上下功夫。","categories":[{"name":"技能-修行-进步-Django","slug":"技能-修行-进步-Django","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Django/"}],"tags":[{"name":"Django-Models","slug":"Django-Models","permalink":"http://example.com/tags/Django-Models/"}]},{"title":"Django-1.7.3-Tutorial-Part-1-模型","slug":"技能-修行-进步-Django/Django-1-7-3-Tutorial-Part-1-模型","date":"2015-01-16T02:46:52.000Z","updated":"2023-07-22T01:33:30.912Z","comments":true,"path":"2015/01/16/技能-修行-进步-Django/Django-1-7-3-Tutorial-Part-1-模型/","link":"","permalink":"http://example.com/2015/01/16/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Django/Django-1-7-3-Tutorial-Part-1-%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"创建你的第一个Django app-Part 1 让我们从简单的例子开始吧。 通过这个教程，我们将快速学习投票(poll)应用的创建。 环境：windows 8 32 bits + Python 2.7.5 + Django 1.7.3 它包含两个部分： 一个供人们查看和进行投票的公开的站点。 一个管理员站点，可以让你进行添加，修改和查询投票。 我们假设你已经装好了Django.你可以通过以下命令查看你安装的版本。1$ python -c &quot;import django; print(django.get_version())&quot; 如果你成功安装了Django，你就会看到版本号，否则，你就会得到一个错误信息：”No module named django”. 我的Django信息如下： 创建项目 如果你是第一次使用Django，那么你应该注意一些初始化的设置。也就是说，你需要一些自生成的代码来构建一个Django项目，包括Django实例的设置文件，譬如数据库配置文件，Django指定选项和应用指定的设置。 从命令行中切换到你想把项目存储的目录，然后输入以下命令:1$ django-admin.py startproject mysite 在当前目录下就会生成一个mysite的目录。如果没有，请查看问题反馈 笔记请注意命名，不能和Python或者Django组件中的关键字重名，特别的，你不能使用django或者test。 通过startproject命令创建的目录如下： 和你建的目录不同？默认项目布局最近有所改变。如果你看到一个’flat’布局(里面没有mysite&#x2F;目录)，你可能使用的Django和本教程的版本不同。请移步。 目录路径解释： 外层mysite&#x2F;：你的项目的根目录。它的名字可以随意更改。 manage.py文件：它是一个和Django进行多样化交互的命令行工具。你可以从以下链接查看详细内容django-admin.py and manage.py 内层mysite&#x2F;：它是项目的真正的python包。名字不可随意更改，因为它是在其他地方可供导入的(例如：mysite.urls) mysite&#x2F;init.py：一个空文件，它的作用是标注自己是一个python包。 mysite&#x2F;settings.py：Django项目的设置或配置。详细可查看Django settings mysite&#x2F;urls.py：对Django项目的URL声明，就像是你的Django网站的目录列表。详细可查看URL dispatcher mysite&#x2F;wsgi.py：它是配置WSGI服务器的入口点。详细可见：How to deploy with WSGI 数据库配置 现在，编辑mysite&#x2F;settings.py文件。它是一个普通的Python模块，用模块级变量表示Django设置。 默认情况下，配置是用SQLite。如果你不熟悉数据库，或者你只想玩玩Django,这是最快捷的选择。SQLite包含在Python中，所以不需要你安装。 如果你想用其他数据库，安装相应数据库绑定,然后修改DATABASES中的默认选项来匹配你的数据库连接设置： ENGINE-数据库引擎，SQLite(默认)：**’django.db.backends.sqlite3’;postgresql：‘django.db.backends.postgresql_psycopg2’；mysql：‘django.db.backends.mysql’**；Oracle： **’django.db.backends.oracle’**，或其他。 NAME-数据库名称。如果你用SQLite,那么他是电脑上的一个文件，这样的话，NAME应该是一个绝对路径，包括文件名。默认值是**os.path.join(BASE_DIR, ‘db.sqlite3’)**，它是存储在项目路径下的文件。 如果你不用SQLite，那么你需要添加USER,PASSWORD,HOST。详细可见：DATABASES。 笔记如果你在使用PostgreSQL或者MySQL，你必须要创建好数据库。通过命令**CREATE DATABASE database_name;**。如果你在使用SQLite,那么它会自动创建，必须手动创建。 当你在编辑mysite&#x2F;settings.py时，请把TIME_ZONE设置为自己的时区。 另外，文件开头的INSTALLED_APPS配置，它Django实例中被激活的Django应用的名字。Apps可以被多个项目使用，你可以把Apps打包和发布给其他项目使用。 默认情况下，INSTALLED_APPS配置包含Django中的apps，如下： django.contrib.admin-管理员站点，你在Part2中会用到。 django.contrib.auth-认证系统 django.contrib.contenttypes-一个内容类型的框架 django.contrib.sessions-session框架 django.contrib.messages-messaging框架 django.contrib.staticfiles-管理静态文件的框架 这些apps默认添加的，你可以根据自己需求修改。 这些apps中可能要用到数据库表，所以，我们应该先要在数据库中创建表，然后再使用。命令如下： 1$ python manage.py migrate migrate命令会查看INSTALLED_APPS配置，然后根据mysite&#x2F;settings.py文件创建一些需要的数据库表，并把数据库迁移到相应的应用中。n你可以查看信息：运行数据库客户端，在命令行中输入\\dt (PostgreSQL), SHOW TABLES; (MySQL), or .schema (SQLite)。 发布到服务器 验证你的项目是否可运行，在外层mysite目录下，运行一下命令：1$ python manage.py runserver 你可以看到以下输出(我的版本如下)：1234January 16, 2015 - 14:18:47Django version 1.7.3, using settings &#x27;mysite.settings&#x27;Starting development server at http://127.0.0.1:8000/Quit the server with CTRL-BREAK. 你已经把项目成功发布到服务器上了，它是一个用纯python实现的轻量级的Web server。它已经被包含到Django当中，方便我们进行快速的开发。 它不可以用于商用，因为能力有限。我们是开发框架而不是服务器。 现在打开浏览器，输入”127.0.0.1:8000&#x2F;“，你就可以访问到你的项目页面了。效果如下： 修改端口默认端口是8000，如果你想修改，可以按如下格式发布项目 1$ python mange.py runserver 8080 如果你想修改服务器的IP，如下格式： 1$ python manage.py runserver 0.0.0.0:8000 详细文档参考runserver 服务器自动加载，不用重新发布项目。 创建模型(models) 现在你项目的基本环境已经搭建好，你可以开始做事了。 在Django中创建的app都有相同的目录结构，但是Django已经用过工具自动生成了，而不必你操心，你只要专注于写代码就好了。 Projects VS apps项目和app之间有什么不同呢？一个app表示网站程序中的一个功能，譬如，一个网路博客系统，一个公开记录或公共投票的数据库应用。而一个项目(project)往往是app的集合，几个app组成一个project，另外，一个app可以被多个项目包含。 如果你的python环境已经配置好，那么你的app可以在任何地方创建。这里我们把polls应用创建在manage.py的旁边，所以，它可以被当成自己的顶级模块导入，而不是mysite的子模块。 创建app,请到manage.py所在目录下，执行命令： 1$ python manage.py startapp polls 创建了一个polls目录，结构如下： 这个目录包含polls应用。 通过Django写数据库网页应用的第一步是定义自己的模块(models)-主要的是，你的数据库布局，加上额外的元数据。 哲学一个模型是一个独立的，明确的数据资源。它包含主要的字段和你存储的数据的行为。Django遵循DRY原则。目的是从一个地方定义和导出数据。还包括迁移，不像Ruby On Rails，例如，模型中的数据可以全部迁移，但它只不过是Django中的一个历史记录，可以随时回滚到当前适应的模型。 在简单的投票(polls)应用中，我们创建2个模型：Question和Choice。Question有一个问题和发表日期。Choice有两个域：选择文本和投票计数器。每一个Choice关联一个Question。 这些概念都能通过简单的Python类实现。编辑polls&#x2F;models.py文件，如下： polls&#x2F;models.py1234567891011121314from django.db import modelsclass Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField(&#x27;date published&#x27;)class Choice(models.Model): question = models.ForeignKey(Question) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) 代码非常简单明了。每个模型都是继承类**django.db.models.Model。每个模型都有一些类变量，其中每个变量都代表数据库中的一个字段**。 每个字段都是一个字段(Field)类的实例–譬如，CharField代表字符域，DateTimeField代表数据库实时间。这样Django就知道每个字段是什么类型的。 每个域实例的名字(譬如question_text或者pub_date)就是字段名称，它是机器能够识别的形式。字段的值会用python代码表示，数据库就会把字段名称当成一个列名。 你还可以为每个字段起一个易于让人读懂的名字。在Django中是支持的，而且也可以记录到文档中。如果你美誉定义这个名字，那么Django就会用机器识别的名字。例如，我们只为Question.pub_date定义一个易于让人都懂的名字。对于模型中的其他字段，机读和人读的名字是一样的。 一些字段类中有写必需的参数，例如CharField，我们必须给它指定一个最大长度**(max_length)**。它不仅仅需要数据库模式，还需要验证的，后面我们就会将到。 一个字段还可以有多个可选的参数，譬如，我们把vote的默认值设为0. 最后，要定义一个关系，用ForeignKey，即是外键。它向Django表明每个Choice关联一个Question。Django支持多种数据库映射关系：多对一，多对多，一对一。 激活模型(Activating models) 上面一小段代码给了Django很多的信息。通过代码，Django可以做到： 为这个app创建一个数据库模式(CREATE TABLE 语句) 创建一个Python数据库可用API，用于使用Question和Choice对象。 但是我们先要告知项目polls已经安装了。 哲学Django的app是可插的(像USB一样，适配多台电脑)：你的app可以插入到多个项目当中，你也可以发布app，这样它(app)就不用绑定到Django中用于安装了。 再一次编辑mysite&#x2F;settings.py文件，然后修改INSTALLED_APPS的内容，让它包含’polls‘，修改后的文件是： mysite&#x2F;settings.py 123456789INSTALLED_APPS = ( &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;, &#x27;polls&#x27;,) 现在Django知道应该包含polls这个app了。让我们运行另外一个命令： 1$ python manage.py makemigrations polls 你应该看到以下的输出： 123456Migrations for &#x27;polls&#x27;: 0001_initial.py: - Create model Choice - Create model Question - Add field question to choice 通过makemigrations口令，你在告诉Django你的模型有了修改(这样，你就新建了一个模型)，你希望修改转存的过程当成迁移。 Migrations记录着你对模型做了什么修改(也即是数据库模式)-它们只是硬盘上的文件。你可以读取你新模型的migration如果你喜欢，它保存在polls&#x2F;migrations&#x2F;0001_initial.py文件当中。不要担心，你不需要每当Django创建一个的时候就读取一次，但它还是可编辑的，当你想对它进行修改的时候。 有一个口令可以帮你运行migration并且自动管理你的数据库模式，它是migrate，我们就要将到它了，但首先，让我们看一下migration会运行什么样的SQL代码。sqlmigrate口令得到migration的名字并且返回它们的SQL。 1$ python manage.py sqlmigrate polls 0001 你应该会看到以下相似的代码：(我们已经把代码格式化了，为了让我们更易读懂它) 12345678910111213141516171819202122BEGIN;CREATE TABLE polls_question ( &quot;id&quot; serial NOT NULL PRIMARY KEY, &quot;question_text&quot; varchar(200) NOT NULL, &quot;pub_date&quot; timestamp with time zone NOT NULL);CREATE TABLE polls_choice ( &quot;id&quot; serial NOT NULL PRIMARY KEY, &quot;question_id&quot; integer NOT NULL, &quot;choice_text&quot; varchar(200) NOT NULL, &quot;votes&quot; integer NOT NULL);CREATE INDEX polls_choice_7aa0f6ee ON &quot;polls_choice&quot; (&quot;question_id&quot;);ALTER TABLE &quot;polls_choice&quot; ADD CONSTRAINT polls_choice_question_id_246c99a640fbbd72_fk_polls_question_id FOREIGN KEY (&quot;question_id&quot;) REFERENCES &quot;polls_question&quot; (&quot;id&quot;) DEFERRABLE INITIALLY DEFERRED;COMMIT; 注意一下内容： 确切的输出会和你用的数据库而有所不同。上面的例子是用PostgreSQL生成的。 表名是自动取app的名字加上模型的名字(小写格式)，如polls_question和polls_choice。(你可以自己更改) 主见(IDs)是自增长的，你也可以自行修改。 按照惯例，Django会在外键字段名字后面加上**_id**,(当然这个你也可以修改)。 外键关系是通过FOREIGN KEY这个约束来清晰定义的。不要担心不同的部分，它仅仅是告知PostgreSQL在结束事务之前不要强行实施外键。 它是根据你用的数据库来适配的，所以数据库指定的域类型，好像，自动适配auto_increment(MySQL),serial(PostgreSQL)，或者integer primary key autoincrement(SQLite)，给字段名加引号是一样的，加单引号或双引号。 sqlmigrate口令并不会真正在你的数据库上运行migtaration-只是把它打印到屏幕上，让你知道Django需要什么SQL。知道Django正在做什么或者你拥有可以修改SQL资格的数据库管理员是非常有用的。 如果你有兴趣，你也可以运行python manage.py check口令，它会检测你的项目是否有问题或者创建数据库是否顺利。 现在，再次运行migrate来创建你数据库上的模型： 1234Operations to perform: Apply all migrations: admin, contenttypes, polls, auth, sessionsRunning migrations: Applying polls.0001_initial... OK migrate口令处理所有那些没被处理的migrations。(Django通过你数据库当中的特殊表django_migrations来跟踪那些被处理了或者那些没有处理) migrations非常强大，而且当你在开发你的项目时，它可以让你随着时间变化修改你的模型，而不需要删除当前的数据库去创建一个新的。我们稍后再对这部分做深入研究，现在，请记住以下三步来对你的模型进行修改： 修改模型(在models.py文件中) 运行python manage.py makemigrations来为这些修改创建migrations 运行python manage.py migrate把这些修改应用(apply)到数据库 为什么make和apply这两步要分开执行呢？原因是你要首先提交migrations到你的版本控制系统，然后在把它们和你的app一起执行。这样会不仅会令你的开发更容易，还便于其他的开发者使用和再次开发。 阅读django-admin.py documentation得到manage.py工具类的更详细的信息。 玩转API 现在，让我们投进可交互的Python shell，玩一下Django提供给我们的免费的API。进入Python Shell，用这个命令：1$ python manage.py shell 我们用python manage.py而不用python的原因是manage.py设置了DJANGO_SETTINGS_MODULE的环境变量，也就是说，Django和python的路径都加入了你的mysite&#x2F;settings.py文件中。 跳过manage.py(Bypassing manage.py)如果你不想使用manage.py，没问题，只需要把DJANGO_SETTINGS_MODULE的环境变量设置到mysite.settings中，新开一个纯净的Python shell，然后设置Django： 12&gt;&gt;&gt; import django&gt;&gt;&gt; django.setup() 如果这样报了一个AttributeError错误，那么你现在使用的是一个不匹配的Django版本。请更换不同的Django版本。你必须在manage.py的目录下运行python，或者确保你的目录加入了Python路径，这样import mysite才起作用。更多详情，请看django-admin.py documentation 当你进入了shell，可以探索[database API](database API:) 1234567891011121314151617181920212223242526272829303132333435363738In [1]: from polls.models import Question, Choice # Import the model classes we just wrote# No questions are in the system yet.In [2]: Question.objects.all()Out[2]: []# Create a new Question.# Support for time zones is enabled in the default settings file, so Django experts a datatime with tzinfo for # pub_date.Use timezone.now()# Instead of datatime.datetime.now() and it will do the right thing. In [3]: from django.utils import timezoneIn [4]: q = Question(question_text=&quot;What&#x27;s new?&quot;, pub_date = timezone.now())# Save the object into the database. You have to call save() explicitly.In [5]: q.save()# Now it has an ID. Note that this might say &quot;1L&quot; instead of &quot;1&quot;, depending on which database you&#x27;re using. That&#x27;s no biggie; # it just means your database backend prefers to returns to return integers as Python long integer objects.In [6]: q.idOut[6]: 1# Access model field values via Python attributes.In [7]: q.question_textOut[7]: &quot;What&#x27;s new?&quot;In [8]: q.pub_dateOut[8]: datetime.datetime(2015, 1, 18, 2, 22, 53, 431000, tzinfo=&lt;UTC&gt;)# Change values by changing the attributes, then calling save().In [9]: q.question_text = &quot;What&#x27;s up?&quot;In [10]: q.save()# objects.all() displays all the questions in the database.In [11]: Question.objects.all()Out[11]: [&lt;Question: Question object&gt;] 等一下，**&lt;Question: Question object&gt;似乎对这个对象来说表现很差。我们可以这样来修正它，修改Question模型(在polls&#x2F;models.py文件中)，为Question和Choice分别添加一个unicode**方法(就像java中重写toString()方法一样)。 polls&#x2F;models.py 1234567891011from django.db import modelsclass Question(models.Model): # ... def __unicode__(self): # __str__ on Python 3 return self.question_textclass Choice(models.Model): # ... def __unicode__(self): # __str__ on Python 3 return self.choice_text 为你的模型添加__unicode__()方法非常重要，不仅仅方便于你和Python进行交互，还方便通过Django自动生成的管理员对对象的展现。 str()方法还是__unicode__()方法在Python 3，就简单的用**str()方法在Python 2中，你应该定义unicode()方法返回的是unicode值。Django模型有一个默认的str()方法，它调用了unicode()方法并且把结果转化成了一个UTF-8字节型字符串。也就是说unicode(p)方法返回的是一个Unicode字符串，而str(p)返回的是一个字节型的字符串，编码格式是UTF-8。Python刚好相反：object有一个unicode()方法，它调用了str()**方法，并把结果解释成一个ASCII的字节型的字符串。这些不同很容易混淆。如果你觉得以上内容很混乱，那请直接用Python 3吧。 看完了一般的Python方法，让我们添加一个自定义的方法，说明一下： polls&#x2F;models.py 12345678910import datetimefrom django.db import modelsfrom django.utils import timezoneclass Question(models.Model): # ... def was_published_recently(self): return self.pub_date &gt;= timezone.now() - datetime.timedelta(days=1) 注意到加入了import datetime和from django.utils import timezone，请参考Python的标准datetime模型和从django.utils.timezone中了解到Django相关的时区工具类。如果你还没熟悉控制Python中的时区，你可以参考这里time zone support docs。 保存修改后，通过python manage.py shell打开一个新的Python shell交互: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&gt;&gt;&gt; from polls.models import Question, Choice# Make sure our __str__() addition worked.&gt;&gt;&gt; Question.objects.all()[&lt;Question: What&#x27;s up?&gt;]# Django provides a rich database lookup API that&#x27;s entirely driven by# keyword arguments.&gt;&gt;&gt; Question.objects.filter(id=1)[&lt;Question: What&#x27;s up?&gt;]&gt;&gt;&gt; Question.objects.filter(question_text__startswith=&#x27;What&#x27;)[&lt;Question: What&#x27;s up?&gt;]# Get the question that was published this year.&gt;&gt;&gt; from django.utils import timezone&gt;&gt;&gt; current_year = timezone.now().year&gt;&gt;&gt; Question.objects.get(pub_date__year=current_year)&lt;Question: What&#x27;s up?&gt;# Request an ID that doesn&#x27;t exist, this will raise an exception.&gt;&gt;&gt; Question.objects.get(id=2)Traceback (most recent call last): ...DoesNotExist: Question matching query does not exist.# Lookup by a primary key is the most common case, so Django provides a# shortcut for primary-key exact lookups.# The following is identical to Question.objects.get(id=1).&gt;&gt;&gt; Question.objects.get(pk=1)&lt;Question: What&#x27;s up?&gt;# Make sure our custom method worked.&gt;&gt;&gt; q = Question.objects.get(pk=1)&gt;&gt;&gt; q.was_published_recently()True# Give the Question a couple of Choices. The create call constructs a new# Choice object, does the INSERT statement, adds the choice to the set# of available choices and returns the new Choice object. Django creates# a set to hold the &quot;other side&quot; of a ForeignKey relation# (e.g. a question&#x27;s choice) which can be accessed via the API.&gt;&gt;&gt; q = Question.objects.get(pk=1)# Display any choices from the related object set -- none so far.&gt;&gt;&gt; q.choice_set.all()[]# Create three choices.&gt;&gt;&gt; q.choice_set.create(choice_text=&#x27;Not much&#x27;, votes=0)&lt;Choice: Not much&gt;&gt;&gt;&gt; q.choice_set.create(choice_text=&#x27;The sky&#x27;, votes=0)&lt;Choice: The sky&gt;&gt;&gt;&gt; c = q.choice_set.create(choice_text=&#x27;Just hacking again&#x27;, votes=0)# Choice objects have API access to their related Question objects.&gt;&gt;&gt; c.question&lt;Question: What&#x27;s up?&gt;# And vice versa: Question objects get access to Choice objects.&gt;&gt;&gt; q.choice_set.all()[&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;&gt;&gt; q.choice_set.count()3# The API automatically follows relationships as far as you need.# Use double underscores to separate relationships.# This works as many levels deep as you want; there&#x27;s no limit.# Find all Choices for any question whose pub_date is in this year# (reusing the &#x27;current_year&#x27; variable we created above).&gt;&gt;&gt; Choice.objects.filter(question__pub_date__year=current_year)[&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]# Let&#x27;s delete one of the choices. Use delete() for that.&gt;&gt;&gt; c = q.choice_set.filter(choice_text__startswith=&#x27;Just hacking&#x27;)&gt;&gt;&gt; c.delete() 关于更多信息，请看 [Accessing related objects](Accessing related objects), Field lookups, Database API reference. 如果你熟悉了API，那么请读下一篇Part2-Django’s automatic admin working.","categories":[{"name":"技能-修行-进步-Django","slug":"技能-修行-进步-Django","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Django/"}],"tags":[{"name":"Django-Models","slug":"Django-Models","permalink":"http://example.com/tags/Django-Models/"}]},{"title":"Support Vector Machines-scikielearn-翻译-毕设系列","slug":"毕业设计系列/Support-Vector-Machines-scikielearn","date":"2015-01-12T05:19:32.000Z","updated":"2023-07-22T02:25:09.899Z","comments":true,"path":"2015/01/12/毕业设计系列/Support-Vector-Machines-scikielearn/","link":"","permalink":"http://example.com/2015/01/12/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97/Support-Vector-Machines-scikielearn/","excerpt":"","text":"写在前面的话 本文是一篇译文，来自scikit-learn上的一篇关于SVM的简介。翻译本文的目的是在于更好的理解SVM，另一方面也可锻炼我的英语阅读能力和翻译水平。 原文链接Support Vector Machines 支持向量机(SVM) 支持向量机是监督学习的一种，它的功能很强大，即可以应用于分类，又可以应用于回归和离群点的检测。 支持向量机的优点： 在高维空间中有效 可以处理由低维空间转换到高维空间中的样本 决策函数中只用到训练集中的一个子集(通常被称为支持向量)，所以所占内存较小 通用性：决策函数中可以指定不同的核函数.支持常用的核函数，但也可以自定义自己的核函数 支持向量机的缺点： 如果特征维数比样本数要大，那么效果较差 支持向量机不直接提供概率估计，它是通过一个较为复杂的5倍交叉验证来完成(看下面的分数和概率 scikit-learn中实现的支持向量机既接受密集的样本(numpy.ndarray and convertible to that by numpy.asarray)又接受稀少(any scipy.sparse)的样本向量作为输入.但是，如果用支持向量机为稀少的样本向量做预测，它必须先拟合好这样的数据。要得到最佳化的表现，密集的用C-ordered numpy.ndarray，稀少的用scipy.spare.csr_matrix，而且dtype&#x3D;float64。 分类 SVC，NuSVC和LinearSVC可以对数据集进行多类分类。 SVC和NuSVC是相似的方法，但是接收的参数和数学公式有少少不同(详见数学公式)。另一方面，LinearSVC则是通过线性核函数来实现支持向量机的另一种方式。既然LinearSVC不接受kernel作为关键字，那么我们就默认它是线性的。它还可能缺少SVC和NuSVC中的某些字段，例如support_。 SVC，NuSVC和LinearSVC中的输入为两个数组，X数组为训练集，它的大小是[n_samples, n_features],Y数组是一个标签类，字符串或者整数，大小为[n_samples]。 12345678&gt;&gt;&gt; from sklearn import svm&gt;&gt;&gt; X = [[0, 0], [1, 1]]&gt;&gt;&gt; y = [0, 1]&gt;&gt;&gt; clf = svm.SVC()&gt;&gt;&gt; clf.fit(X, y) SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0, degree=3,gamma=0.0, kernel=&#x27;rbf&#x27;, max_iter=-1, probability=False, random_state=None,shrinking=True, tol=0.001, verbose=False) 拟合之后，模型就可以用来预测新变量： 12&gt;&gt;&gt; clf.predict([[2., 2.]])array([1]) 支持向量机决策函数依赖训练集的某个子集，被称作支持向量。这些支持向量的某些属性可以在成员support_vectors,support_和n_support中找到。 12345678910&gt;&gt;&gt; # get support vectors&gt;&gt;&gt; clf.support_vectors_array([[ 0., 0.], [ 1., 1.]])&gt;&gt;&gt; # get indices of support vectors&gt;&gt;&gt; clf.support_ array([0, 1]...)&gt;&gt;&gt; # get number of support vectors for each class&gt;&gt;&gt; clf.n_support_ array([1, 1]...) 多类分类器 SVC和NuSVC为多分类分类器实现了“一对一”的方法(Kerr et al., 1991)。如果n_class代表类的个数，那么就要构造n_class * (n_class - 1) &#x2F; 2个分类器，而且每一个数据训练成两个类： 12345678910&gt;&gt;&gt; X = [[0], [1], [2], [3]]&gt;&gt;&gt; Y = [0, 1, 2, 3]&gt;&gt;&gt; clf = svm.SVC()&gt;&gt;&gt; clf.fit(X, Y) SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0, degree=3,gamma=0.0, kernel=&#x27;rbf&#x27;, max_iter=-1, probability=False, random_state=None,shrinking=True, tol=0.001, verbose=False)&gt;&gt;&gt; dec = clf.decision_function([[1]])&gt;&gt;&gt; dec.shape[1] # 4 classes: 4*3/2 = 66 另一个方面，LinearSVC则为多分类分类器实现了“一对其他”的方法，所以只需要训练n_class个模型，如果是分两类，那么只需要训练一个模型。 12345678&gt;&gt;&gt; lin_clf = svm.LinearSVC()&gt;&gt;&gt; lin_clf.fit(X, Y) LinearSVC(C=1.0, class_weight=None, dual=True, fit_intercept=True,intercept_scaling=1, loss=&#x27;l2&#x27;, multi_class=&#x27;ovr&#x27;, penalty=&#x27;l2&#x27;,random_state=None, tol=0.0001, verbose=0)&gt;&gt;&gt; dec = lin_clf.decision_function([[1]])&gt;&gt;&gt; dec.shape[1]4 关于决策函数，详见数学公式 既然LinearSVC也实现了另一个候补的多分类策略，由Crammer和Singer构造的所谓的多分类SVM，记作multi_class&#x3D;’crammer_singer’。这个方法是很稳定的，但是对于“一对其他”的分类器并非如此。实际上，“一对其他”分类器通常是首选的，因为结果大多数比较相似的，但是运行时间就没有什么比较的意义了。 对于“一对其他”的LinearSVC中的coef_和intercept_属性，他们分别表示为[n_class,n_features]和[n_class]。 后记","categories":[{"name":"毕业设计系列","slug":"毕业设计系列","permalink":"http://example.com/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"SVM","slug":"SVM","permalink":"http://example.com/tags/SVM/"}]},{"title":"SVM入门系列博文-转自Jasper's Java Jacal-备份-毕设系列","slug":"毕业设计系列/SVM入门系列博文-转自Jasper-s-Java-Jacal-备份-毕设系列","date":"2015-01-08T03:15:11.000Z","updated":"2015-01-08T11:05:16.000Z","comments":true,"path":"2015/01/08/毕业设计系列/SVM入门系列博文-转自Jasper-s-Java-Jacal-备份-毕设系列/","link":"","permalink":"http://example.com/2015/01/08/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97/SVM%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E5%8D%9A%E6%96%87-%E8%BD%AC%E8%87%AAJasper-s-Java-Jacal-%E5%A4%87%E4%BB%BD-%E6%AF%95%E8%AE%BE%E7%B3%BB%E5%88%97/","excerpt":"","text":"写在前面的话 本文是一个备份，转自：Jasper’s Java Jacal 以下是原文。请细赏！ SVM入门（一）之SVM的八股简介 支持向量机(Support Vector Machine)是Cortes和Vapnik于1995年首先提出的，它在解决小样本、非线性及高维模式识别中表现出许多特有的优势，并能够推广应用到函数拟合等其他机器学习问题中[10]。 支持向量机方法是建立在统计学习理论的VC维理论和结构风险最小原理基础上的，根据有限的样本信息在模型的复杂性（即对特定训练样本的学习精度，Accuracy）和学习能力（即无错误地识别任意样本的能力）之间寻求最佳折衷，以期获得最好的推广能力[14]（或称泛化能力）。 以上是经常被有关SVM 的学术文献引用的介绍，有点八股，我来逐一分解并解释一下。 @传统机器学习与统计机器学习 Vapnik是统计机器学习的大牛，这想必都不用说，他出版的《Statistical Learning Theory》是一本完整阐述统计机器学习思想的名著。在该书中详细的论证了统计机器学习之所以区别于传统机器学习的本质，就在于统计机器学习能够精确的给出学习效果，能够解答需要的样本数等等一系列问题。与统计机器学习的精密思维相比，传统的机器学习基本上属于摸着石头过河，用传统的机器学习方法构造分类系统完全成了一种技巧，一个人做的结果可能很好，另一个人差不多的方法做出来却很差，缺乏指导和原则。 @VC维 所谓VC维是对函数类的一种度量，可以简单的理解为问题的复杂程度，VC维越高，一个问题就越复杂。正是因为SVM关注的是VC维，后面我们可以看到，SVM解决问题的时候，和样本的维数是无关的（甚至样本是上万维的都可以，这使得SVM很适合用来解决文本分类的问题，当然，有这样的能力也因为引入了核函数）。 @结构风险最小 结构风险最小听上去文绉绉，其实说的也无非是下面这回事。 机器学习本质上就是一种对问题真实模型的逼近（我们选择一个我们认为比较好的近似模型，这个近似模型就叫做一个假设），但毫无疑问，真实模型一定是不知道的（如果知道了，我们干吗还要机器学习？直接用真实模型解决问题不就可以了？对吧，哈哈）既然真实模型不知道，那么我们选择的假设与问题真实解之间究竟有多大差距，我们就没法得知。比如说我们认为宇宙诞生于150亿年前的一场大爆炸，这个假设能够描述很多我们观察到的现象，但它与真实的宇宙模型之间还相差多少？谁也说不清，因为我们压根就不知道真实的宇宙模型到底是什么。 这个与问题真实解之间的误差，就叫做风险（更严格的说，误差的累积叫做风险）。我们选择了一个假设之后（更直观点说，我们得到了一个分类器以后），真实误差无从得知，但我们可以用某些可以掌握的量来逼近它。最直观的想法就是使用分类器在样本数据上的分类的结果与真实结果（因为样本是已经标注过的数据，是准确的数据）之间的差值来表示。这个差值叫做经验风险Remp(w)。以前的机器学习方法都把经验风险最小化作为努力的目标，但后来发现很多分类函数能够在样本集上轻易达到100%的正确率，在真实分类时却一塌糊涂（即所谓的推广能力差，或泛化能力差）。此时的情况便是选择了一个足够复杂的分类函数（它的VC维很高），能够精确的记住每一个样本，但对样本之外的数据一律分类错误。回头看看经验风险最小化原则我们就会发现，此原则适用的大前提是经验风险要确实能够逼近真实风险才行（行话叫一致），但实际上能逼近么？答案是不能，因为样本数相对于现实世界要分类的文本数来说简直九牛一毛，经验风险最小化原则只在这占很小比例的样本上做到没有误差，当然不能保证在更大比例的真实文本上也没有误差。 @泛化误差界 统计学习因此而引入了泛化误差界的概念，就是指真实风险应该由两部分内容刻画，一是经验风险，代表了分类器在给定样本上的误差；二是置信风险，代表了我们在多大程度上可以信任分类器在未知文本上分类的结果。很显然，第二部分是没有办法精确计算的，因此只能给出一个估计的区间，也使得整个误差只能计算上界，而无法计算准确的值（所以叫做泛化误差界，而不叫泛化误差）。 置信风险与两个量有关，一是样本数量，显然给定的样本数量越大，我们的学习结果越有可能正确，此时置信风险越小；二是分类函数的VC维，显然VC维越大，推广能力越差，置信风险会变大。 泛化误差界的公式为：R(w)≤Remp(w)+Ф(n&#x2F;h) 公式中R(w)就是真实风险，Remp(w)就是经验风险，Ф(n&#x2F;h)就是置信风险。统计学习的目标从经验风险最小化变为了寻求经验风险与置信风险的和最小，即结构风险最小。 SVM正是这样一种努力最小化结构风险的算法。 @小样本，非线性，高维度识别 SVM其他的特点就比较容易理解了。 小样本，并不是说样本的绝对数量少（实际上，对任何算法来说，更多的样本几乎总是能带来更好的效果），而是说与问题的复杂度比起来，SVM算法要求的样本数是相对比较少的。 非线性，是指SVM擅长应付样本数据线性不可分的情况，主要通过松弛变量（也有人叫惩罚变量）和核函数技术来实现，这一部分是SVM的精髓，以后会详细讨论。多说一句，关于文本分类这个问题究竟是不是线性可分的，尚没有定论，因此不能简单的认为它是线性可分的而作简化处理，在水落石出之前，只好先当它是线性不可分的（反正线性可分也不过是线性不可分的一种特例而已，我们向来不怕方法过于通用）。 高维模式识别是指样本维数很高，例如文本的向量表示，如果没有经过另一系列文章（《文本分类入门》）中提到过的降维处理，出现几万维的情况很正常，其他算法基本就没有能力应付了，SVM却可以，主要是因为SVM 产生的分类器很简洁，用到的样本信息很少（仅仅用到那些称之为“支持向量”的样本，此为后话），使得即使样本维数很高，也不会给存储和计算带来大麻烦（相对照而言，kNN算法在分类时就要用到所有样本，样本数巨大，每个样本维数再一高，这日子就没法过了……）。 @下节预告 下一节开始正式讨论SVM。别嫌我说得太详细哦。 SVM入门（二）线性分类器Part 1@线性分类器 线性分类器(一定意义上,也可以叫做感知机) 是最简单也很有效的分类器形式.在一个线性分类器中,可以看到SVM形成的思路,并接触很多SVM的核心概念。 用一个二维空间里仅有两类样本的分类问题来举个小例子。如图所示： C1和C2是要区分的两个类别，在二维平面中它们的样本如上图所示。中间的直线就是一个分类函数，它可以将两类样本完全分开。一般的，如果一个线性函数能够将样本完全正确的分开，就称这些数据是线性可分的，否则称为非线性可分的。 @线性函数 什么叫线性函数呢？在一维空间里就是一个点，在二维空间里就是一条直线，三维空间里就是一个平面，可以如此想象下去，如果不关注空间的维数，这种线性函数还有一个统一的名称——超平面（Hyper Plane）！ 实际上，一个线性函数是一个实值函数（即函数的值是连续的实数），而我们的分类问题（例如这里的二元分类问题——回答一个样本属于还是不属于一个类别的问题）需要离散的输出值，例如用1表示某个样本属于类别C1，而用0表示不属于（不属于C1也就意味着属于C2），这时候只需要简单的在实值函数的基础上附加一个阈值即可，通过分类函数执行时得到的值大于还是小于这个阈值来确定类别归属。 例如我们有一个线性函数 g(x)&#x3D;wx+b 我们可以取阈值为0，这样当有一个样本xi需要判别的时候，我们就看g(xi)的值。若g(xi)&gt;0，就判别为类别C1，若g(xi)&lt;0，则判别为类别C2（等于的时候我们就拒绝判断，呵呵）。此时也等价于给函数g(x)附加一个符号函数sgn()，即f(x)&#x3D;sgn[g(x)]是我们真正的判别函数。 关于g(x)&#x3D;wx+b这个表达式要注意三点： 一，式中的x不是二维坐标系中的横轴，而是样本的向量表示，例如一个样本点的坐标是(3,8)，则xT&#x3D;(3,8) ，而不是x&#x3D;3（一般说向量都是说列向量，因此以行向量形式来表示时，就加上转置）。 二，这个形式并不局限于二维的情况，在n维空间中仍然可以使用这个表达式，只是式中的w成为了n维向量（在二维的这个例子中，w是二维向量，为了表示起来方便简洁，以下均不区别列向量和它的转置，聪明的读者一看便知）； 三，g(x)不是中间那条直线的表达式，中间那条直线的表达式是g(x)&#x3D;0，即wx+b&#x3D;0，我们也把这个函数叫做分类面。 实际上很容易看出来，中间那条分界线并不是唯一的，我们把它稍微旋转一下，只要不把两类数据分错，仍然可以达到上面说的效果，稍微平移一下，也可以。此时就牵涉到一个问题，对同一个问题存在多个分类函数的时候，哪一个函数更好呢？显然必须要先找一个指标来量化“好”的程度，通常使用的都是叫做“分类间隔”的指标。 @下节预告 下一节我们就仔细说说分类间隔，也补一补相关的数学知识。 SVM入门（三）线性分类器Part 2 上回说到对于文本分类这样的不适定问题（有一个以上解的问题称为不适定问题），需要有一个指标来衡量解决方案（即我们通过训练建立的分类模型）的好坏，而分类间隔是一个比较好的指标。 @文本分类在计算机中的表示 在进行文本分类的时候，我们可以让计算机这样来看待我们提供给它的训练样本，每一个样本由一个向量（就是那些文本特征所组成的向量）和一个标记（标示出这个样本属于哪个类别）组成。如下： Di&#x3D;(xi,yi) xi就是文本向量（维数很高），yi就是分类标记。 在二元的线性分类中，这个表示分类的标记只有两个值，1和-1（用来表示属于还是不属于这个类）。有了这种表示法，我们就可以定义一个样本点到某个超平面的间隔： δi&#x3D;yi(wxi+b) 这个公式乍一看没什么神秘的，也说不出什么道理，只是个定义而已，但我们做做变换，就能看出一些有意思的东西。 @由分类间隔到几何间隔 首先注意到如果某个样本属于该类别的话，那么wxi+b&gt;0（记得么？这是因为我们所选的g(x)&#x3D;wx+b就通过大于0还是小于0来判断分类），而yi也大于0；若不属于该类别的话，那么wxi+b&lt;0，而yi也小于0，这意味着yi(wxi+b)总是大于0的，而且它的值就等于|wxi+b|！（也就是|g(xi)|） 现在把w和b进行一下归一化，即用w&#x2F;||w||和b&#x2F;||w||分别代替原来的w和b，那么间隔就可以写成 这个公式是不是看上去有点眼熟？没错，这不就是解析几何中点xi到直线g(x)&#x3D;0的距离公式嘛！（推广一下，是到超平面g(x)&#x3D;0的距离， g(x)&#x3D;0就是上节中提到的分类超平面） 小Tips：||w||是什么符号？||w||叫做向量w的范数，范数是对向量长度的一种度量。我们常说的向量长度其实指的是它的2-范数，范数最一般的表示形式为p-范数，可以写成如下表达式 向量w&#x3D;(w1, w2, w3,…… wn)它的p-范数为 看看把p换成2的时候，不就是传统的向量长度么？当我们不指明p的时候，就像||w||这样使用时，就意味着我们不关心p的值，用几范数都可以；或者上文已经提到了p的值，为了叙述方便不再重复指明。 当用归一化的w和b代替原值之后的间隔有一个专门的名称，叫做几何间隔，几何间隔所表示的正是点到超平面的欧氏距离，我们下面就简称几何间隔为“距离”。以上是单个点到某个超平面的距离（就是间隔，后面不再区别这两个词）定义，同样可以定义一个点的集合（就是一组样本）到某个超平面的距离为此集合中离超平面最近的点的距离。下面这张图更加直观的展示出了几何间隔的现实含义： H是分类面，而H1和H2是平行于H，且过离H最近的两类样本的直线，H1与H，H2与H之间的距离就是几何间隔。 之所以如此关心几何间隔这个东西，是因为几何间隔与样本的误分次数间存在关系： 其中的δ是样本集合到分类面的间隔，R&#x3D;max ||xi|| i&#x3D;1,…,n，即R是所有样本中（xi是以向量表示的第i个样本）向量长度最长的值（也就是说代表样本的分布有多么广）。先不必追究误分次数的具体定义和推导过程，只要记得这个误分次数一定程度上代表分类器的误差。而从上式可以看出，误分次数的上界由几何间隔决定！（当然，是样本已知的时候） 至此我们就明白为何要选择几何间隔来作为评价一个解优劣的指标了，原来几何间隔越大的解，它的误差上界越小。因此最大化几何间隔成了我们训练阶段的目标，而且，与二把刀作者所写的不同，最大化分类间隔并不是SVM的专利，而是早在线性分类时期就已有的思想。 SVM入门（四）线性分类器的求解——问题的描述Part1@上节回顾-间隔和几何间隔 上节说到我们有了一个线性分类函数，也有了判断解优劣的标准——即有了优化的目标，这个目标就是最大化几何间隔，但是看过一些关于SVM的论文的人一定记得什么优化的目标是要最小化||w||这样的说法，这是怎么回事呢？回头再看看我们对间隔和几何间隔的定义： 间隔：δ&#x3D;y(wx+b)&#x3D;|g(x)| 几何间隔： 可以看出δ&#x3D;||w||δ几何。注意到几何间隔与||w||是成反比的，因此最大化几何间隔与最小化||w||完全是一回事。而我们常用的方法并不是固定||w||的大小而寻求最大几何间隔，而是固定间隔（例如固定为1），寻找最小的||w||。 @寻优问题 而凡是求一个函数的最小值（或最大值）的问题都可以称为寻优问题（也叫作一个规划问题），又由于找最大值的问题总可以通过加一个负号变为找最小值的问题，因此我们下面讨论的时候都针对找最小值的过程来进行。一个寻优问题最重要的部分是目标函数，顾名思义，就是指寻优的目标。例如我们想寻找最小的||w||这件事，就可以用下面的式子表示： 但实际上对于这个目标，我们常常使用另一个完全等价的目标函数来代替，那就是： 不难看出当||w||2达到最小时，||w||也达到最小，反之亦然（前提当然是||w||描述的是向量的长度，因而是非负的）。之所以采用这种形式，是因为后面的求解过程会对目标函数作一系列变换，而式（1）的形式会使变换后的形式更为简洁（正如聪明的读者所料，添加的系数二分之一和平方，皆是为求导数所需）。 @加约束条件 接下来我们自然会问的就是，这个式子是否就描述了我们的问题呢？（回想一下，我们的问题是有一堆点，可以被分成两类，我们要找出最好的分类面） 如果直接来解这个求最小值问题，很容易看出当||w||&#x3D;0的时候就得到了目标函数的最小值。但是你也会发现，无论你给什么样的数据，都是这个解！反映在图中，就是H1与H2两条直线间的距离无限大，这个时候，所有的样本点（无论正样本还是负样本）都跑到了H1和H2中间，而我们原本的意图是，H1右侧的被分为正类，H2 左侧的被分为负类，位于两类中间的样本则拒绝分类（拒绝分类的另一种理解是分给哪一类都有道理，因而分给哪一类也都没有道理）。这下可好，所有样本点都进入了无法分类的灰色地带。 造成这种结果的原因是在描述问题的时候只考虑了目标，而没有加入约束条件，约束条件就是在求解过程中必须满足的条件，体现在我们的问题中就是样本点必须在H1或H2的某一侧（或者至少在H1和H2上），而不能跑到两者中间。我们前文提到过把间隔固定为1，这是指把所有样本点中间隔最小的那一点的间隔定为1（这也是集合的间隔的定义，有点绕嘴），也就意味着集合中的其他点间隔都不会小于1，按照间隔的定义，满足这些条件就相当于让下面的式子总是成立： yi[(w·xi)+b]≥1 (i&#x3D;1,2,…,l) （l是总的样本数） 但我们常常习惯让式子的值和0比较，因而经常用变换过的形式： yi[(w·xi)+b]-1≥0 (i&#x3D;1,2,…,l) （l是总的样本数） 因此我们的两类分类问题也被我们转化成了它的数学形式，一个带约束的最小值的问题： @下节预告 下一节我们从最一般的意义上看看一个求最小值的问题有何特征，以及如何来解。 SVM入门（五）线性分类器的求解——问题的描述Part2@规划(Programming) 从最一般的定义上说，一个求最小值的问题就是一个优化问题（也叫寻优问题，更文绉绉的叫法是规划——Programming），它同样由两部分组成，目标函数和约束条件，可以用下面的式子表示： （式1） 约束条件用函数c来表示，就是constrain的意思啦。你可以看出一共有p+q个约束条件，其中p个是不等式约束，q个等式约束。 关于这个式子可以这样来理解：式中的x是自变量，但不限定它的维数必须为1（视乎你解决的问题空间维数，对我们的文本分类来说，那可是成千上万啊）。要求f(x)在哪一点上取得最小值（反倒不太关心这个最小值到底是多少，关键是哪一点），但不是在整个空间里找，而是在约束条件所划定的一个有限的空间里找，这个有限的空间就是优化理论里所说的可行域。注意可行域中的每一个点都要求满足所有p+q个条件，而不是满足其中一条或几条就可以（切记，要满足每个约束），同时可行域边界上的点有一个额外好的特性，它们可以使不等式约束取得等号！而边界内的点不行。 @凸集 关于可行域还有个概念不得不提，那就是凸集，凸集是指有这么一个点的集合，其中任取两个点连一条直线，这条线上的点仍然在这个集合内部，因此说“凸”是很形象的（一个反例是，二维平面上，一个月牙形的区域就不是凸集，你随便就可以找到两个点违反了刚才的规定）。 @凸二次规划 回头再来看我们线性分类器问题的描述，可以看出更多的东西。 （式2） 在这个问题中，自变量就是w，而目标函数是w的二次函数，所有的约束条件都是w的线性函数（哎，千万不要把xi当成变量，它代表样本，是已知的），这种规划问题有个很有名气的称呼——二次规划（Quadratic Programming，QP），而且可以更进一步的说，由于它的可行域是一个凸集，因此它是一个凸二次规划。 一下子提了这么多术语，实在不是为了让大家以后能向别人炫耀学识的渊博，这其实是我们继续下去的一个重要前提，因为在动手求一个问题的解之前（好吧，我承认，是动计算机求……），我们必须先问自己：这个问题是不是有解？如果有解，是否能找到？ @问题可解吗 对于一般意义上的规划问题，两个问题的答案都是不一定，但凸二次规划让人喜欢的地方就在于，它有解（教科书里面为了严谨，常常加限定成分，说它有全局最优解，由于我们想找的本来就是全局最优的解，所以不加也罢），而且可以找到！（当然，依据你使用的算法不同，找到这个解的速度，行话叫收敛速度，会有所不同） 对比（式2）和（式1）还可以发现，我们的线性分类器问题只有不等式约束，因此形式上看似乎比一般意义上的规划问题要简单，但解起来却并非如此。 因为我们实际上并不知道该怎么解一个带约束的优化问题。如果你仔细回忆一下高等数学的知识，会记得我们可以轻松的解一个不带任何约束的优化问题（实际上就是当年背得烂熟的函数求极值嘛，求导再找0点呗，谁不会啊？笑），我们甚至还会解一个只带等式约束的优化问题，也是背得烂熟的，求条件极值，记得么，通过添加拉格朗日乘子，构造拉格朗日函数，来把这个问题转化为无约束的优化问题云云（如果你一时没想通，我提醒一下，构造出的拉格朗日函数就是转化之后的问题形式，它显然没有带任何条件）。 @读者问 读者问：如果只带等式约束的问题可以转化为无约束的问题而得以求解，那么可不可以把带不等式约束的问题向只带等式约束的问题转化一下而得以求解呢？ 聪明，可以，实际上我们也正是这么做的。下一节就来说说如何做这个转化，一旦转化完成，求解对任何学过高等数学的人来说，都是小菜一碟啦。 SVM入门（六）线性分类器的求解——问题的转化，直观角度@回到问题 让我再一次比较完整的重复一下我们要解决的问题：我们有属于两个类别的样本点（并不限定这些点在二维空间中）若干，如图， 圆形的样本点定为正样本（连带着，我们可以把正样本所属的类叫做正类），方形的点定为负例。我们想求得这样一个线性函数（在n维空间中的线性函数）： g(x)&#x3D;wx+b 使得所有属于正类的点x+代入以后有g(x+)≥1，而所有属于负类的点x-代入后有g(x-)≤-1（之所以总跟1比较，无论正一还是负一，都是因为我们固定了间隔为1，注意间隔和几何间隔的区别）。代入g(x)后的值如果在1和-1之间，我们就拒绝判断。 @问题实际上就是求解w和b 求这样的g(x)的过程就是求w（一个n维向量）和b（一个实数）两个参数的过程（但实际上只需要求w，求得以后找某些样本点代入就可以求得b）。因此在求g(x)的时候，w才是变量。 你肯定能看出来，一旦求出了w（也就求出了b），那么中间的直线H就知道了（因为它就是wx+b&#x3D;0嘛，哈哈），那么H1和H2也就知道了（因为三者是平行的，而且相隔的距离还是||w||决定的）。那么w是谁决定的？显然是你给的样本决定的，一旦你在空间中给出了那些个样本点，三条直线的位置实际上就唯一确定了（因为我们求的是最优的那三条，当然是唯一的），我们解优化问题的过程也只不过是把这个确定了的东西算出来而已。 @w的数学表示 样本确定了w，用数学的语言描述，就是w可以表示为样本的某种组合： w&#x3D;α1x1+α2x2+…+αnxn 式子中的αi是一个一个的数（在严格的证明过程中，这些α被称为拉格朗日乘子），而xi是样本点，因而是向量，n就是总样本点的个数。为了方便描述，以下开始严格区别数字与向量的乘积和向量间的乘积，我会用α1x1表示数字和向量的乘积，而用&lt;x1,x2&gt;表示向量x1,x2的内积（也叫点积，注意与向量叉积的区别）。因此g(x)的表达式严格的形式应该是： @式子转换 但是上面的式子还不够好，你回头看看图中正样本和负样本的位置，想像一下，我不动所有点的位置，而只是把其中一个正样本点定为负样本点（也就是把一个点的形状从圆形变为方形），结果怎么样？三条直线都必须移动（因为对这三条直线的要求是必须把方形和圆形的点正确分开）！这说明w不仅跟样本点的位置有关，还跟样本的类别有关（也就是和样本的“标签”有关）。因此用下面这个式子表示才算完整： w&#x3D;α1y1x1+α2y2x2+…+αnynxn （式1） 其中的yi就是第i个样本的标签，它等于1或者-1。其实以上式子的那一堆拉格朗日乘子中，只有很少的一部分不等于0（不等于0才对w起决定作用），这部分不等于0的拉格朗日乘子后面所乘的样本点，其实都落在H1和H2上，也正是这部分样本（而不需要全部样本）唯一的确定了分类函数，当然，更严格的说，这些样本的一部分就可以确定，因为例如确定一条直线，只需要两个点就可以，即便有三五个都落在上面，我们也不是全都需要。这部分我们真正需要的样本点，就叫做支持（撑）向量！（名字还挺形象吧，他们“撑”起了分界线） 式子也可以用求和符号简写一下： 因此原来的g(x)表达式可以写为： 注意式子中x才是变量，也就是你要分类哪篇文档，就把该文档的向量表示代入到 x的位置，而所有的xi统统都是已知的样本。还注意到式子中只有xi和x是向量，因此一部分可以从内积符号中拿出来，得到g(x)的式子为： 发现了什么？w不见啦！从求w变成了求α。 但肯定有人会说，这并没有把原问题简化呀。嘿嘿，其实简化了，只不过在你看不见的地方，以这样的形式描述问题以后，我们的优化问题少了很大一部分不等式约束（记得这是我们解不了极值问题的万恶之源）。但是接下来先跳过线性分类器求解的部分，来看看 SVM在线性分类器上所做的重大改进——核函数。 SVM入门（七）为何需要核函数 生存？还是毁灭？——哈姆雷特 可分？还是不可分？——支持向量机 @线性不可分到线性可分，可能吗？ 之前一直在讨论的线性分类器,器如其名（汗，这是什么说法啊），只能对线性可分的样本做处理。如果提供的样本线性不可分，结果很简单，线性分类器的求解程序会无限循环，永远也解不出来。这必然使得它的适用范围大大缩小，而它的很多优点我们实在不原意放弃，怎么办呢？是否有某种方法，让线性不可分的数据变得线性可分呢？ 有！其思想说来也简单，来用一个二维平面中的分类问题作例子，你一看就会明白。事先声明，下面这个例子是网络早就有的，我一时找不到原作者的正确信息，在此借用，并加进了我自己的解说而已。 例子是下面这张图： 我们把横轴上端点a和b之间红色部分里的所有点定为正类，两边的黑色部分里的点定为负类。试问能找到一个线性函数把两类正确分开么？不能，因为二维空间里的线性函数就是指直线，显然找不到符合条件的直线。 但我们可以找到一条曲线，例如下面这一条： 显然通过点在这条曲线的上方还是下方就可以判断点所属的类别（你在横轴上随便找一点，算算这一点的函数值，会发现负类的点函数值一定比0大，而正类的一定比0小）。这条曲线就是我们熟知的二次曲线，它的函数表达式可以写为： 问题只是它不是一个线性函数，但是，下面要注意看了，新建一个向量y和a： 这样g(x)就可以转化为 ，你可以把y和a分别回带一下，看看等不等于原来的g(x)。用内积的形式写你可能看不太清楚，实际上f(y)的形式就是： g(x)&#x3D;f(y)&#x3D;ay 在任意维度的空间中，这种形式的函数都是一个线性函数（只不过其中的a和y都是多维向量罢了），因为自变量y的次数不大于1。 @妙！高维度空间可分了！ 看出妙在哪了么？原来在二维空间中一个线性不可分的问题，映射到四维空间后，变成了线性可分的！因此这也形成了我们最初想解决线性不可分问题的基本思路——向高维空间转化，使其变得线性可分。 而转化最关键的部分就在于找到x到y的映射方法。遗憾的是，如何找到这个映射，没有系统性的方法（也就是说，纯靠猜和凑）。具体到我们的文本分类问题，文本被表示为上千维的向量，即使维数已经如此之高，也常常是线性不可分的，还要向更高的空间转化。其中的难度可想而知。 小Tips:为什么说f(y)&#x3D;ay是四维空间里的函数?大家可能一时没看明白。回想一下我们二维空间里的函数定义 g(x)&#x3D;ax+b 变量x是一维的，为什么说它是二维空间里的函数呢？因为还有一个变量我们没写出来，它的完整形式其实是 y&#x3D;g(x)&#x3D;ax+b 即 y&#x3D;ax+b 看看，有几个变量？两个。那是几维空间的函数？（作者五岁的弟弟答：五维的。作者：……） 再看看 f(y)&#x3D;ay 里面的y是三维的变量，那f(y)是几维空间里的函数？（作者五岁的弟弟答：还是五维的。作者：……） @文本分类例子又来了 用一个具体文本分类的例子来看看这种向高维空间映射从而分类的方法如何运作，想象一下，我们文本分类问题的原始空间是1000维的（即每个要被分类的文档被表示为一个1000维的向量），在这个维度上问题是线性不可分的。现在我们有一个2000维空间里的线性函数 注意向量的右上角有个 ’哦。它能够将原问题变得可分。式中的 w’和x’都是2000维的向量，只不过w’是定值，而x’是变量（好吧,严格说来这个函数是2001维的,哈哈），现在我们的输入呢，是一个1000维的向量x，分类的过程是先把x变换为2000维的向量x’，然后求这个变换后的向量x’与向量w’的内积，再把这个内积的值和b相加，就得到了结果，看结果大于阈值还是小于阈值就得到了分类结果。 你发现了什么？我们其实只关心那个高维空间里内积的值，那个值算出来了，分类结果就算出来了。而从理论上说， x’是经由x变换来的，因此广义上可以把它叫做x的函数（有一个x，就确定了一个x’，对吧，确定不出第二个），而w’是常量，它是一个低维空间里的常量w经过变换得到的，所以给了一个w 和x的值，就有一个确定的f(x’)值与其对应。这让我们幻想，是否能有这样一种函数K(w,x),他接受低维空间的输入值，却能算出高维空间的内积值&lt;w’,x’&gt;？ 如果有这样的函数，那么当给了一个低维空间的输入x以后， 这两个函数的计算结果就完全一样，我们也就用不着费力找那个映射关系，直接拿低维的输入往g(x)里面代就可以了（再次提醒，这回的g(x)就不是线性函数啦，因为你不能保证K(w,x)这个表达式里的x次数不高于1哦）。 @核函数大神出来了 万幸的是，这样的K(w,x)确实存在（发现凡是我们人类能解决的问题，大都是巧得不能再巧，特殊得不能再特殊的问题，总是恰好有些能投机取巧的地方才能解决，由此感到人类的渺小），它被称作核函数（核，kernel），而且还不止一个，事实上，只要是满足了Mercer条件的函数，都可以作为核函数。核函数的基本作用就是接受两个低维空间里的向量，能够计算出经过某个变换后在高维空间里的向量内积值。几个比较常用的核函数，线性核函数，高斯核函数，径向基核函数,教课书里都列过，我就不敲了（懒！）。 @让核函数来拯救线性不可分吧(其实是简化了高维度中向量的内积计算$_$) 回想我们上节说的求一个线性分类器，它的形式应该是： 现在这个就是高维空间里的线性函数（为了区别低维和高维空间里的函数和向量，我改了函数的名字，并且给w和x都加上了 ’），我们就可以用一个低维空间里的函数（再一次的，这个低维空间里的函数就不再是线性的啦）来代替， 又发现什么了？f(x’) 和g(x)里的α，y，b全都是一样一样的！这就是说，尽管给的问题是线性不可分的，但是我们就硬当它是线性问题来求解，只不过求解过程中，凡是要求内积的时候就用你选定的核函数来算。这样求出来的α再和你选定的核函数一组合，就得到分类器啦！ @问题来了 明白了以上这些，会自然的问接下来两个问题： 1． 既然有很多的核函数，针对具体问题该怎么选择？ 2． 如果使用核函数向高维空间映射后，问题仍然是线性不可分的，那怎么办？ 第一个问题现在就可以回答你：对核函数的选择，现在还缺乏指导原则！各种实验的观察结果（不光是文本分类）的确表明，某些问题用某些核函数效果很好，用另一些就很差，但是一般来讲，径向基核函数是不会出太大偏差的一种，首选。（我做文本分类系统的时候，使用径向基核函数，没有参数调优的情况下，绝大部分类别的准确和召回都在85%以上，可见。虽然libSVM的作者林智仁认为文本分类用线性核函数效果更佳，待考证） @下节预告对第二个问题的解决则引出了我们下一节的主题：松弛变量。 SVM入门（八）松弛变量@“近似线性可分”与“硬间隔” 现在我们已经把一个本来线性不可分的文本分类问题，通过映射到高维空间而变成了线性可分的。就像下图这样： 圆形和方形的点各有成千上万个（毕竟，这就是我们训练集中文档的数量嘛，当然很大了）。现在想象我们有另一个训练集，只比原先这个训练集多了一篇文章，映射到高维空间以后（当然，也使用了相同的核函数），也就多了一个样本点，但是这个样本的位置是这样的： 就是图中黄色那个点，它是方形的，因而它是负类的一个样本，这单独的一个样本，使得原本线性可分的问题变成了线性不可分的。这样类似的问题（仅有少数点线性不可分）叫做“近似线性可分”的问题。 以我们人类的常识来判断，说有一万个点都符合某种规律（因而线性可分），有一个点不符合，那这一个点是否就代表了分类规则中我们没有考虑到的方面呢（因而规则应该为它而做出修改）？ 其实我们会觉得，更有可能的是，这个样本点压根就是错误，是噪声，是提供训练集的同学人工分类时一打瞌睡错放进去的。所以我们会简单的忽略这个样本点，仍然使用原来的分类器，其效果丝毫不受影响。 但这种对噪声的容错性是人的思维带来的，我们的程序可没有。由于我们原本的优化问题的表达式中，确实要考虑所有的样本点（不能忽略某一个，因为程序它怎么知道该忽略哪一个呢？），在此基础上寻找正负类之间的最大几何间隔，而几何间隔本身代表的是距离，是非负的，像上面这种有噪声的情况会使得整个问题无解。这种解法其实也叫做“硬间隔”分类法，因为他硬性的要求所有样本点都满足和分类平面间的距离必须大于某个值。 因此由上面的例子中也可以看出，硬间隔的分类法其结果容易受少数点的控制，这是很危险的（尽管有句话说真理总是掌握在少数人手中，但那不过是那一小撮人聊以自慰的词句罢了，咱还是得民主）。 @要容错啊，变软间隔吧–松弛变量来帮你 但解决方法也很明显，就是仿照人的思路，允许一些点到分类平面的距离不满足原先的要求。由于不同的训练集各点的间距尺度不太一样，因此用间隔（而不是几何间隔）来衡量有利于我们表达形式的简洁。我们原先对样本点的要求是： 意思是说离分类面最近的样本点函数间隔也要比1大。如果要引入容错性，就给1这个硬性的阈值加一个松弛变量，即允许 因为松弛变量是非负的，因此最终的结果是要求间隔可以比1小。但是当某些点出现这种间隔比1小的情况时（这些点也叫离群点），意味着我们放弃了对这些点的精确分类，而这对我们的分类器来说是种损失。但是放弃这些点也带来了好处，那就是使分类面不必向这些点的方向移动，因而可以得到更大的几何间隔（在低维空间看来，分类边界也更平滑）。显然我们必须权衡这种损失和好处。好处很明显，我们得到的分类间隔越大，好处就越多。回顾我们原始的硬间隔分类对应的优化问题： ||w||2就是我们的目标函数（当然系数可有可无），希望它越小越好，因而损失就必然是一个能使之变大的量（能使它变小就不叫损失了，我们本来就希望目标函数值越小越好）。那如何来衡量损失，有两种常用的方式，有人喜欢用 而有人喜欢用 其中l都是样本的数目。两种方法没有大的区别。如果选择了第一种，得到的方法的就叫做二阶软间隔分类器，第二种就叫做一阶软间隔分类器。把损失加入到目标函数里的时候，就需要一个惩罚因子（cost，也就是libSVM的诸多参数中的C），原来的优化问题就变成了下面这样： 这个式子有这么几点要注意： 一是并非所有的样本点都有一个松弛变量与其对应。实际上只有“离群点”才有，或者也可以这么看，所有没离群的点松弛变量都等于0（对负类来说，离群点就是在前面图中，跑到H2右侧的那些负样本点，对正类来说，就是跑到H1左侧的那些正样本点）。 二是松弛变量的值实际上标示出了对应的点到底离群有多远，值越大，点就越远。 三是惩罚因子C决定了你有多重视离群点带来的损失，显然当所有离群点的松弛变量的和一定时，你定的C越大，对目标函数的损失也越大，此时就暗示着你非常不愿意放弃这些离群点，最极端的情况是你把C定为无限大，这样只要稍有一个点离群，目标函数的值马上变成无限大，马上让问题变成无解，这就退化成了硬间隔问题。 四是惩罚因子C不是一个变量，整个优化问题在解的时候，C是一个你必须事先指定的值，指定这个值以后，解一下，得到一个分类器，然后用测试数据看看结果怎么样，如果不够好，换一个C的值，再解一次优化问题，得到另一个分类器，再看看效果，如此就是一个参数寻优的过程，但这和优化问题本身决不是一回事，优化问题在解的过程中，C一直是定值，要记住。 五是尽管加了松弛变量这么一说，但这个优化问题仍然是一个优化问题（汗，这不废话么），解它的过程比起原始的硬间隔问题来说，没有任何更加特殊的地方。 从大的方面说优化问题解的过程，就是先试着确定一下w，也就是确定了前面图中的三条直线，这时看看间隔有多大，又有多少点离群，把目标函数的值算一算，再换一组三条直线（你可以看到，分类的直线位置如果移动了，有些原来离群的点会变得不再离群，而有的本来不离群的点会变成离群点），再把目标函数的值算一算，如此往复（迭代），直到最终找到目标函数最小时的w。 ＠读者又提问了–松弛变量和核函数都是解决线性不可分问题 啰嗦了这么多，读者一定可以马上自己总结出来，松弛变量也就是个解决线性不可分问题的方法罢了，但是回想一下，核函数的引入不也是为了解决线性不可分的问题么？为什么要为了一个问题使用两种方法呢？ 其实两者还有微妙的不同。一般的过程应该是这样，还以文本分类为例。在原始的低维空间中，样本相当的不可分，无论你怎么找分类平面，总会有大量的离群点，此时用核函数向高维空间映射一下，虽然结果仍然是不可分的，但比原始空间里的要更加接近线性可分的状态（就是达到了近似线性可分的状态），此时再用松弛变量处理那些少数“冥顽不化”的离群点，就简单有效得多啦。 本节中的（式1）也确实是支持向量机最最常用的形式。至此一个比较完整的支持向量机框架就有了，简单说来，支持向量机就是使用了核函数的软间隔线性分类法。 @下节预告 下一节会说说松弛变量剩下的一点点东西，顺便搞个读者调查，看看大家还想侃侃SVM的哪些方面。 SVM入门（九）松弛变量（续）@惩罚因子C的权值 接下来要说的东西其实不是松弛变量本身，但由于是为了使用松弛变量才引入的，因此放在这里也算合适，那就是惩罚因子C。回头看一眼引入了松弛变量以后的优化问题： 注意其中C的位置，也可以回想一下C所起的作用（表征你有多么重视离群点，C越大越重视，越不想丢掉它们）。这个式子是以前做SVM的人写的，大家也就这么用，但没有任何规定说必须对所有的松弛变量都使用同一个惩罚因子，我们完全可以给每一个离群点都使用不同的C，这时就意味着你对每个样本的重视程度都不一样，有些样本丢了也就丢了，错了也就错了，这些就给一个比较小的C；而有些样本很重要，决不能分类错误（比如中央下达的文件啥的，笑），就给一个很大的C。 @数据集偏斜问题 当然实际使用的时候并没有这么极端，但一种很常用的变形可以用来解决分类问题中样本的“偏斜”问题。 先来说说样本的偏斜问题，也叫数据集偏斜（unbalanced），它指的是参与分类的两个类别（也可以指多个类别）样本数量差异很大。比如说正类有10，000个样本，而负类只给了100个，这会引起的问题显而易见，可以看看下面的图： 方形的点是负类。H，H1，H2是根据给的样本算出来的分类面，由于负类的样本很少很少，所以有一些本来是负类的样本点没有提供，比如图中两个灰色的方形点，如果这两个点有提供的话，那算出来的分类面应该是H’，H2’和H1，他们显然和之前的结果有出入，实际上负类给的样本点越多，就越容易出现在灰色点附近的点，我们算出的结果也就越接近于真实的分类面。但现在由于偏斜的现象存在，使得数量多的正类可以把分类面向负类的方向“推”，因而影响了结果的准确性。 @惩罚因子C，数量越少越重视 对付数据集偏斜问题的方法之一就是在惩罚因子上作文章，想必大家也猜到了，那就是给样本数量少的负类更大的惩罚因子，表示我们重视这部分样本（本来数量就少，再抛弃一些，那人家负类还活不活了），因此我们的目标函数中因松弛变量而损失的部分就变成了： 其中i&#x3D;1…p都是正样本，j&#x3D;p+1…p+q都是负样本。libSVM这个算法包在解决偏斜问题的时候用的就是这种方法。 @怎么比较正类多，还是负类多？ 那C+和C-怎么确定呢？它们的大小是试出来的（参数调优），但是他们的比例可以有些方法来确定。咱们先假定说C+是5这么大，那确定C-的一个很直观的方法就是使用两类样本数的比来算，对应到刚才举的例子，C-就可以定为500这么大（因为10，000：100&#x3D;100：1嘛）。 但是这样并不够好，回看刚才的图，你会发现正类之所以可以“欺负”负类，其实并不是因为负类样本少，真实的原因是负类的样本分布的不够广（没扩充到负类本应该有的区域）。说一个具体点的例子，现在想给政治类和体育类的文章做分类，政治类文章很多，而体育类只提供了几篇关于篮球的文章，这时分类会明显偏向于政治类，如果要给体育类文章增加样本，但增加的样本仍然全都是关于篮球的（也就是说，没有足球，排球，赛车，游泳等等），那结果会怎样呢？虽然体育类文章在数量上可以达到与政治类一样多，但过于集中了，结果仍会偏向于政治类！所以给C+和C-确定比例更好的方法应该是衡量他们分布的程度。比如可以算算他们在空间中占据了多大的体积，例如给负类找一个超球——就是高维空间里的球啦——它可以包含所有负类的样本，再给正类找一个，比比两个球的半径，就可以大致确定分布的情况。显然半径大的分布就比较广，就给小一点的惩罚因子。 但是这样还不够好，因为有的类别样本确实很集中，这不是提供的样本数量多少的问题，这是类别本身的特征（就是某些话题涉及的面很窄，例如计算机类的文章就明显不如文化类的文章那么“天马行空”），这个时候即便超球的半径差异很大，也不应该赋予两个类别不同的惩罚因子。 看到这里读者一定疯了，因为说来说去，这岂不成了一个解决不了的问题？然而事实如此，完全的方法是没有的，根据需要，选择实现简单又合用的就好（例如libSVM就直接使用样本数量的比）。 SVM入门（十）将SVM用于多类分类@SVM只是个两类分类器 从SVM的那几张图可以看出来，SVM是一种典型的两类分类器，即它只回答属于正类还是负类的问题。而现实中要解决的问题，往往是多类的问题（少部分例外，例如垃圾邮件过滤，就只需要确定“是”还是“不是”垃圾邮件），比如文本分类，比如数字识别。如何由两类分类器得到多类分类器，就是一个值得研究的问题。 @穷举法？行不通！ 还以文本分类为例，现成的方法有很多，其中一种一劳永逸的方法，就是真的一次性考虑所有样本，并求解一个多目标函数的优化问题，一次性得到多个分类面，就像下图这样： 多个超平面把空间划分为多个区域，每个区域对应一个类别，给一篇文章，看它落在哪个区域就知道了它的分类。 看起来很美对不对？只可惜这种算法还基本停留在纸面上，因为一次性求解的方法计算量实在太大，大到无法实用的地步。 @一对其余 稍稍退一步，我们就会想到所谓“一类对其余”的方法，就是每次仍然解一个两类分类的问题。比如我们有5个类别，第一次就把类别1的样本定为正样本，其余2，3，4，5的样本合起来定为负样本，这样得到一个两类分类器，它能够指出一篇文章是还是不是第1类的；第二次我们把类别2 的样本定为正样本，把1，3，4，5的样本合起来定为负样本，得到一个分类器，如此下去，我们可以得到5个这样的两类分类器（总是和类别的数目一致）。到了有文章需要分类的时候，我们就拿着这篇文章挨个分类器的问：是属于你的么？是属于你的么？哪个分类器点头说是了，文章的类别就确定了。 这种方法的好处是每个优化问题的规模比较小，而且分类的时候速度很快（只需要调用5个分类器就知道了结果）。但有时也会出现两种很尴尬的情况，例如拿一篇文章问了一圈，每一个分类器都说它是属于它那一类的，或者每一个分类器都说它不是它那一类的，前者叫分类重叠现象，后者叫不可分类现象。分类重叠倒还好办，随便选一个结果都不至于太离谱，或者看看这篇文章到各个超平面的距离，哪个远就判给哪个。不可分类现象就着实难办了，只能把它分给第6个类别了……更要命的是，本来各个类别的样本数目是差不多的，但“其余”的那一类样本数总是要数倍于正类（因为它是除正类以外其他类别的样本之和嘛），这就人为的造成了上一节所说的“数据集偏斜”问题。 @一对一 因此我们还得再退一步，还是解两类分类问题，还是每次选一个类的样本作正类样本，而负类样本则变成只选一个类（称为“一对一单挑”的方法，哦，不对，没有单挑，就是“一对一”的方法，呵呵），这就避免了偏斜。因此过程就是算出这样一些分类器，第一个只回答“是第1类还是第2类”，第二个只回答“是第1类还是第3类”，第三个只回答“是第1类还是第4类”，如此下去，你也可以马上得出，这样的分类器应该有5 X 4&#x2F;2&#x3D;10个（通式是，如果有k个类别，则总的两类分类器数目为k(k-1)&#x2F;2）。虽然分类器的数目多了，但是在训练阶段（也就是算出这些分类器的分类平面时）所用的总时间却比“一类对其余”方法少很多，在真正用来分类的时候，把一篇文章扔给所有分类器，第一个分类器会投票说它是“1”或者“2”，第二个会说它是“1”或者“3”，让每一个都投上自己的一票，最后统计票数，如果类别“1”得票最多，就判这篇文章属于第1类。这种方法显然也会有分类重叠的现象，但不会有不可分类现象，因为总不可能所有类别的票数都是0。看起来够好么？其实不然，想想分类一篇文章，我们调用了多少个分类器？10个，这还是类别数为5的时候，类别数如果是1000，要调用的分类器数目会上升至约500,000个（类别数的平方量级）。这如何是好？ @有向无环图-DAG SVM 看来我们必须再退一步，在分类的时候下功夫，我们还是像一对一方法那样来训练，只是在对一篇文章进行分类之前，我们先按照下面图的样子来组织分类器（如你所见，这是一个有向无环图，因此这种方法也叫做DAG SVM） 这样在分类时,我们就可以先问分类器“1对5”（意思是它能够回答“是第1类还是第5类”），如果它回答5，我们就往左走，再问“2对5”这个分类器，如果它还说是“5”，我们就继续往左走，这样一直问下去，就可以得到分类结果。好处在哪？我们其实只调用了4个分类器（如果类别数是k，则只调用k-1个），分类速度飞快，且没有分类重叠和不可分类现象！缺点在哪？假如最一开始的分类器回答错误（明明是类别1的文章，它说成了5），那么后面的分类器是无论如何也无法纠正它的错误的（因为后面的分类器压根没有出现“1”这个类别标签），其实对下面每一层的分类器都存在这种错误向下累积的现象。 不过不要被DAG方法的错误累积吓倒，错误累积在一对其余和一对一方法中也都存在，DAG方法好于它们的地方就在于，累积的上限，不管是大是小，总是有定论的，有理论证明。而一对其余和一对一方法中，尽管每一个两类分类器的泛化误差限是知道的，但是合起来做多类分类的时候，误差上界是多少，没人知道，这意味着准确率低到0也是有可能的，这多让人郁闷。 而且现在DAG方法根节点的选取（也就是如何选第一个参与分类的分类器），也有一些方法可以改善整体效果，我们总希望根节点少犯错误为好，因此参与第一次分类的两个类别，最好是差别特别特别大，大到以至于不太可能把他们分错；或者我们就总取在两类分类中正确率最高的那个分类器作根节点，或者我们让两类分类器在分类的时候，不光输出类别的标签，还输出一个类似“置信度”的东东，当它对自己的结果不太自信的时候，我们就不光按照它的输出走，把它旁边的那条路也走一走，等等。 @大Tips：SVM的计算复杂度 使用SVM进行分类的时候，实际上是训练和分类两个完全不同的过程，因而讨论复杂度就不能一概而论，我们这里所说的主要是训练阶段的复杂度，即解那个二次规划问题的复杂度。对这个问题的解，基本上要划分为两大块，解析解和数值解。 解析解就是理论上的解，它的形式是表达式，因此它是精确的，一个问题只要有解（无解的问题还跟着掺和什么呀，哈哈），那它的解析解是一定存在的。当然存在是一回事，能够解出来，或者可以在可以承受的时间范围内解出来，就是另一回事了。对SVM来说，求得解析解的时间复杂度最坏可以达到O(Nsv3)，其中Nsv是支持向量的个数，而虽然没有固定的比例，但支持向量的个数多少也和训练集的大小有关。 数值解就是可以使用的解，是一个一个的数，往往都是近似解。求数值解的过程非常像穷举法，从一个数开始，试一试它当解效果怎样，不满足一定条件（叫做停机条件，就是满足这个以后就认为解足够精确了，不需要继续算下去了）就试下一个，当然下一个数不是乱选的，也有一定章法可循。有的算法，每次只尝试一个数，有的就尝试多个，而且找下一个数字（或下一组数）的方法也各不相同，停机条件也各不相同，最终得到的解精度也各不相同，可见对求数值解的复杂度的讨论不能脱开具体的算法。 一个具体的算法，Bunch-Kaufman训练算法，典型的时间复杂度在O(Nsv3+LNsv2+dLNsv)和O(dL2)之间，其中Nsv是支持向量的个数，L是训练集样本的个数，d是每个样本的维数（原始的维数，没有经过向高维空间映射之前的维数）。复杂度会有变化，是因为它不光跟输入问题的规模有关（不光和样本的数量，维数有关），也和问题最终的解有关（即支持向量有关），如果支持向量比较少，过程会快很多，如果支持向量很多，接近于样本的数量，就会产生O(dL2)这个十分糟糕的结果（给10，000个样本，每个样本1000维，基本就不用算了，算不出来，呵呵，而这种输入规模对文本分类来说太正常了）。 这样再回头看就会明白为什么一对一方法尽管要训练的两类分类器数量多，但总时间实际上比一对其余方法要少了，因为一对其余方法每次训练都考虑了所有样本（只是每次把不同的部分划分为正类或者负类而已），自然慢上很多。 后记 这篇文章真的写的不错，不要漏了。","categories":[{"name":"毕业设计系列","slug":"毕业设计系列","permalink":"http://example.com/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"SVM入门","slug":"SVM入门","permalink":"http://example.com/tags/SVM%E5%85%A5%E9%97%A8/"}]},{"title":"字符串-编程面试10大常考算法系列(1)","slug":"alogrithms/字符串-编程面试10大常考算法系列-1","date":"2015-01-05T07:22:21.000Z","updated":"2023-07-22T02:28:39.458Z","comments":true,"path":"2015/01/05/alogrithms/字符串-编程面试10大常考算法系列-1/","link":"","permalink":"http://example.com/2015/01/05/alogrithms/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%9510%E5%A4%A7%E5%B8%B8%E8%80%83%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97-1/","excerpt":"","text":"题语 本文针对Java中字符串的常用操作进行整理，在原转载文章的基础上进行内容的补充。 出自：编程面试的10大算法概念-常考 字符串和数组Original 如果IDE没有代码自动补全功能，那么你应该记住下面这些方法：12345678// 字符串charAt(int x) // 获得某个索引处的字符length() // 字符串长度toCharArray() // 获得字符串对应的char数组// 数组length // 数组大小Arrays.sort() // 数组排序Arrays.toString(char[] a) // 数组转成字符串 charAt(int x) 它是属于字符串的方法，功能是根据字符串的下标(从0开始)取出当前的字符。 源代码：123456public char charAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return value[index];&#125; 它的思路是：首先根据判断输入的下标是否合法，然后直接取value[index]，其中value是String类中的一个字符数组，它就是为了把字符串转为字符数组而设的。 length() 它是属于字符串的方法，功能是返回字符串的长度。 源代码：123public int length() &#123; return value.length;&#125; 不必多说，参考上文。 toCharArray() 它是属于字符串的方法，功能是把字符串转换成字符串数组。 源代码：12345678910111213/** * Converts this string to a new character array. * * @return a newly allocated character array whose length is the length * of this string and whose contents are initialized to contain * the character sequence represented by this string. */ public char[] toCharArray() &#123; // Cannot use Arrays.copyOf because of class initialization order issues char result[] = new char[value.length]; System.arraycopy(value, 0, result, 0, value.length); return result; &#125; 它的思路是：先创建一个和原字符串长度一样的字符数组result[]，然后通过系统的arraycopy()方法把原字符串的每一个字符对应的复制到字符数组中。其中value是String类中的一个字符数组，它就是为了把字符串转为字符数组而设的，但为什么我们不直接返回value字符数组呢？因为value是private的，不可被调用。 自己实现：123456789// toCharArraySelfpublic static char[] toCharArraySelf(String origin) &#123; char[] result = new char[origin.length()]; for(int i = 0; i &lt; origin.length(); i++) &#123; // System.out.println(&quot;origin.index()&quot; +origin.charAt(i)); result[i] = (char)origin.charAt(i); &#125; return result;&#125; length 它是属于数组的一个属性，记录着数组的长度。 Arrays.sort() Arrays是Java的一个工具包，专门针对数组的操作。sort()方法是数组的排序，传入的参数是一个数组，然后把数组进行排序后返回。 源代码：123public static void sort(char[] a) &#123; DualPivotQuicksort.sort(a);&#125; 可以看到Java7中Arrays调用的是双基准快速排序算法(DualPivotQuicksort)。有兴趣的自行研究：QuickDualPivot.java Arrays.toString(char[] a) 它是属于Arrays工具包的一个方法，功能刚好是把数组转化为字符串。 源代码：12345678910111213141516public static String toString(char[] a) &#123; if (a == null) return &quot;null&quot;; int iMax = a.length - 1; if (iMax == -1) return &quot;[]&quot;; StringBuilder b = new StringBuilder(); b.append(&#x27;[&#x27;); for (int i = 0; ; i++) &#123; b.append(a[i]); if (i == iMax) return b.append(&#x27;]&#x27;).toString(); b.append(&quot;, &quot;); &#125; &#125; 后话","categories":[{"name":"技能-修行-进步","slug":"技能-修行-进步","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5/"}],"tags":[{"name":"字符串操作","slug":"字符串操作","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"}]},{"title":"【基础】常用的机器学习&数据挖掘知识点","slug":"ML/【基础】常用的机器学习-数据挖掘知识点","date":"2015-01-04T11:04:41.000Z","updated":"2023-07-16T01:26:57.943Z","comments":true,"path":"2015/01/04/ML/【基础】常用的机器学习-数据挖掘知识点/","link":"","permalink":"http://example.com/2015/01/04/ML/%E3%80%90%E5%9F%BA%E7%A1%80%E3%80%91%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"说明 转自：36大数据 本文总结了机器学习入门的基础知识的标题。相当于给我们入门者一个学习的架构。 Basis(基础) MSE(Mean Square Error (均方误差) LMS(LeastMean Square (最小均方) LSM(Least Square Methods (最小二乘法) MLE(MaximumLikelihood Estimation (最大似然估计) QP(Quadratic Programming (二次规划) CP(Conditional Probability (条件概率) JP(Joint Probability (联合概率) MP(Marginal Probability (边缘概率) Bayesian Formula (贝叶斯公式) L1 &#x2F;L2Regularization (L1&#x2F;L2正则，以及更多的，现在比较火的L2.5正则等) GD (GradientDescent 梯度下降) SGD (Stochastic Gradient Descent 随机梯度下降) Eigenvalue (特征值) Eigenvector (特征向量) QR-decomposition (QR分解) Quantile (分位数) Covariance (协方差矩阵) Common Distribution(常见分布)Discrete Distribution(离散型分布) BernoulliDistribution&#x2F;Binomial(贝努利分布&#x2F;二项分布) Negative BinomialDistribution(负二项分布) MultinomialDistribution(多项式分布) Geometric Distribution(几何分布) HypergeometricDistribution(超几何分布) Poisson Distribution (泊松分布) Continuous Distribution (连续型分布) UniformDistribution(均匀分布) Normal Distribution &#x2F;Guassian Distribution(正态分布&#x2F;高斯分布) ExponentialDistribution(指数分布) Lognormal Distribution(对数正态分布) GammaDistribution(Gamma分布) Beta Distribution(Beta分布) Dirichlet Distribution(狄利克雷分布) Rayleigh Distribution(瑞利分布) Cauchy Distribution(柯西分布) Weibull Distribution (韦伯分布) Three Sampling Distribution(三大抽样分布) Chi-squareDistribution(卡方分布) t-distribution(t-分布) F-distribution(F-分布) Data Pre-processing(数据预处理) Missing Value Imputation(缺失值填充) Discretization(离散化) Mapping(映射) Normalization(归一化&#x2F;标准化) Sampling(采样) Simple Random Sampling(简单随机采样) OfflineSampling(离线等可能K采样) Online Sampling(在线等可能K采样) Ratio-based Sampling(等比例随机采样) Acceptance-RejectionSampling(接受-拒绝采样) Importance Sampling(重要性采样) MCMC(MarkovChain Monte Carlo 马尔科夫蒙特卡罗采样算法：Metropolis-Hasting&amp; Gibbs) Clustering(聚类) K-Means K-Mediods 二分K-Means FK-Means Canopy Spectral-KMeans(谱聚类) GMM-EM(混合高斯模型-期望最大化算法解决) K-Pototypes CLARANS(基于划分) BIRCH(基于层次) CURE(基于层次) DBSCAN(基于密度) CLIQUE(基于密度和基于网格) Classification&amp;Regression(分类&amp;回归) LR(Linear Regression 线性回归) LR(LogisticRegression逻辑回归) SR(Softmax Regression 多分类逻辑回归) GLM(GeneralizedLinear Model 广义线性模型) RR(Ridge Regression 岭回归&#x2F;L2正则最小二乘回归) LASSO(Least Absolute Shrinkage andSelectionator Operator L1正则最小二乘回归) RF(随机森林) DT(DecisionTree决策树) GBDT(Gradient BoostingDecision Tree 梯度下降决策树) CART(ClassificationAnd Regression Tree 分类回归树) KNN(K-Nearest Neighbor K近邻) SVM(Support VectorMachine) KF(KernelFunction 核函数) PolynomialKernel Function 多项式核函数 Guassian KernelFunction 高斯核函数 Radial BasisFunction RBF径向基函数 String KernelFunction (字符串核函数) NB(Naive Bayes 朴素贝叶斯) BN(Bayesian Network&#x2F;Bayesian Belief Network&#x2F; Belief Network 贝叶斯网络&#x2F;贝叶斯信度网络&#x2F;信念网络) LDA(Linear Discriminant Analysis&#x2F;FisherLinear Discriminant 线性判别分析&#x2F;Fisher线性判别) EL(Ensemble Learning集成学习Boosting，Bagging，Stacking) AdaBoost(Adaptive Boosting 自适应增强) MEM(MaximumEntropy Model最大熵模型) Effectiveness Evaluation(分类效果评估) Confusion Matrix(混淆矩阵) Precision(精确度) Recall(召回率) Accuracy(准确率) F-score(F得分) ROC Curve(ROC曲线) AUC(AUC面积) LiftCurve(Lift曲线) KS Curve(KS曲线) PGM(Probabilistic Graphical Models概率图模型) BN(Bayesian Network&#x2F;Bayesian Belief Network&#x2F; BeliefNetwork 贝叶斯网络&#x2F;贝叶斯信度网络&#x2F;信念网络) MC(Markov Chain 马尔科夫链) HMM(HiddenMarkov Model 马尔科夫模型) MEMM(Maximum Entropy Markov Model 最大熵马尔科夫模型) CRF(ConditionalRandom Field 条件随机场) MRF(MarkovRandom Field 马尔科夫随机场) NN(Neural Network神经网络) ANN(Artificial Neural Network 人工神经网络) BP(Error BackPropagation 误差反向传播) Deep Learning(深度学习) Auto-encoder(自动编码器) SAE(Stacked Auto-encoders堆叠自动编码器：Sparse Auto-encoders稀疏自动编码器、Denoising Auto-encoders去噪自动编码器、Contractive Auto-encoders 收缩自动编码器) RBM(RestrictedBoltzmann Machine 受限玻尔兹曼机) DBN(Deep Belief Network 深度信念网络) CNN(ConvolutionalNeural Network 卷积神经网络) Word2Vec(词向量学习模型) DimensionalityReduction(降维) LDA LinearDiscriminant Analysis&#x2F;Fisher Linear Discriminant 线性判别分析&#x2F;Fisher线性判别 PCA(Principal Component Analysis 主成分分析) ICA(IndependentComponent Analysis 独立成分分析) SVD(Singular Value Decomposition 奇异值分解) FA(FactorAnalysis 因子分析法) Text Mining(文本挖掘) VSM(Vector Space Model向量空间模型) Word2Vec(词向量学习模型) TF(Term Frequency词频) TF-IDF(Term Frequency-Inverse DocumentFrequency 词频-逆向文档频率) MI(MutualInformation 互信息) ECE(Expected Cross Entropy 期望交叉熵) QEMI(二次信息熵) IG(InformationGain 信息增益) IGR(Information Gain Ratio 信息增益率) Gini(基尼系数)，x2 Statistic(x2统计量) TEW(TextEvidence Weight文本证据权) OR(Odds Ratio 优势率) N-Gram Model，LSA(Latent Semantic Analysis 潜在语义分析) PLSA(ProbabilisticLatent Semantic Analysis 基于概率的潜在语义分析) LDA(Latent DirichletAllocation 潜在狄利克雷模型) Association Mining(关联挖掘) Apriori FP-growth(Frequency Pattern Tree Growth 频繁模式树生长算法) AprioriAll Spade Recommendation Engine(推荐引擎) DBR(Demographic-based Recommendation 基于人口统计学的推荐) CBR(Context-basedRecommendation 基于内容的推荐) CF(Collaborative Filtering协同过滤) UCF(User-basedCollaborative Filtering Recommendation 基于用户的协同过滤推荐) ICF(Item-basedCollaborative Filtering Recommendation 基于项目的协同过滤推荐) Similarity Measure&amp;Distance Measure(相似性与距离度量)： Euclidean Distance(欧式距离) ManhattanDistance(曼哈顿距离) Chebyshev Distance(切比雪夫距离) MinkowskiDistance(闵可夫斯基距离) Standardized Euclidean Distance(标准化欧氏距离) MahalanobisDistance(马氏距离) Cos(Cosine 余弦) HammingDistance&#x2F;Edit Distance(汉明距离&#x2F;编辑距离) JaccardDistance(杰卡德距离) Correlation Coefficient Distance(相关系数距离) InformationEntropy(信息熵) KL(Kullback-Leibler Divergence KL散度&#x2F;Relative Entropy 相对熵) Optimization(最优化) Heuristic Algorithm(启发式算法) SA(SimulatedAnnealing，模拟退火算法) GA(genetic algorithm遗传算法) Non-constrainedOptimization(无约束优化) Cyclic VariableMethods(变量轮换法) Pattern Search Methods(模式搜索法) VariableSimplex Methods(可变单纯形法) Gradient Descent Methods(梯度下降法) Newton Methods(牛顿法) Quasi-NewtonMethods(拟牛顿法) Conjugate Gradient Methods(共轭梯度法) ConstrainedOptimization(有约束优化) Approximation Programming Methods(近似规划法) FeasibleDirection Methods(可行方向法) Penalty Function Methods(罚函数法) Multiplier Methods(乘子法) Feature Selection(特征选择算法) Mutual Information(互信息) DocumentFrequence(文档频率) Information Gain(信息增益) Chi-squared Test(卡方检验) Gini(基尼系数) Outlier Detection(异常点检测算法) Statistic-based(基于统计) Distance-based(基于距离) Density-based(基于密度) Clustering-based(基于聚类) Learning to Rank(基于学习的排序) Pointwise：McRank； Pairwise：RankingSVM，RankNet，Frank，RankBoost； Listwise：AdaRank，SoftRank，LamdaMART； Tool(工具) MPI，Hadoop生态圈，Spark，BSP，Weka，Mahout，Scikit-learn，PyBrain… End","categories":[{"name":"技能-修行-进步","slug":"技能-修行-进步","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"手写数字识别-Kernel Support Vector Machine-论文翻译-毕设系列","slug":"毕业设计系列/手写数字识别-Kernel-Support-Vector-Machine-博客翻译-毕设系列","date":"2015-01-03T06:29:02.000Z","updated":"2023-07-16T01:38:41.282Z","comments":true,"path":"2015/01/03/毕业设计系列/手写数字识别-Kernel-Support-Vector-Machine-博客翻译-毕设系列/","link":"","permalink":"http://example.com/2015/01/03/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97/%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB-Kernel-Support-Vector-Machine-%E5%8D%9A%E5%AE%A2%E7%BF%BB%E8%AF%91-%E6%AF%95%E8%AE%BE%E7%B3%BB%E5%88%97/","excerpt":"","text":"写在前面的话 本篇博文是翻译自Code Project上的César de Souza教授的关于用Kernel Support Vector Machine手写数字识别的博客。认真学习借鉴一下。 出处：Handwriting Recognition Revisited: Kernel Support Vector Machines 博文正文 在上一篇文章中，我们讨论了怎么利用基于核函数的辨别分析(Kernel Discriminant Analysis)的方法来解决手写数字识别的问题。在这里，我们将要讨论如何利用基于核函数的支持向量机(Kernel Support Vector Machine)的一些技巧来解决手写数字的识别问题。 Download source code - 584 KB Download sample application - 522 KB Download the Accord.NET Machine Learning Framework. 由于在最新的代码库中，它通常包含了最新的功能增强和修正，所以请下载 最新的Accord.NET Framework. 简介 在上一篇文章中，我想向大家展示怎么用核判别分析法来解决手写数字识别的问题。但是，我发现自己并没有更多的关注手写数字识别的问题，因为我把焦点都放在了KDA方法上了，而不是识别问题本身。在本篇文章中，我会给大家展示一个更好的方法来解决数字识别的问题。 核判别分析方法有自己的问题集。尽管它在处理高维度的数据是没有任何问题，但当样本的数量达到O(n³)，它就显得有些无能为力了。另外一个更严重的问题是在模型评估过程中核判别分析方法需要载入全部数据集，这样令它很难推广(例如嵌入式系统)。 在上一篇文章的最后，我提到了SVM其实是一种解决数字识别的更好的方法。SVM的一个优点是它们的解决问题的方法比较单一，不像KDA,它们在数据评估的过程中不需要载入全部数据集，而只是需要非常小部分的数据。这部分数据就是我们所通常称的”支持向量”。 支持向量机 支持向量机是属于监督学习方法中的一种，它既可以用作分类，也可以用做回归。简单的说，给定一个训练数据样本，其中的每条记录都有一个标记变量，它标记着本条记录是属于哪一个分类的(现在讨论的是二类分类器)，然后数据集通过SVM分类器进行训练得到一个决策模型，这个模型可以预测新进来的一条记录是属于两个分类中的哪一种。如果样本中的每条记录是落在空间上的某个点，那么一个SVM的线性分类器可以看做是空间中的一个分界，把空间分成两类，这样我们希望把样本分成两类的清晰的间隔，它越宽越好。新的样本点看它落在间隔的那一边上就可以预测它属于那一类的了。 一个线性SVM是由给定的支持向量z集合和权重w集合组成。由N个支持向量z1,z2…zN和w1,w2…wN构成的支持向量机输出的计算公式是： 一个决策函数通常把这个作为输入变量，然后转化为一个二类分类器。通常地，我们用sign(.)函数，就是符号函数，输入变量大于0的作为一类，输入变量小于0的作为另外一类。 基于核函数的支持向量机 如上所述，原始的SVM的最优化平面是一个线性分类器。然而，从它在1963年提出的30年后，一些研究者(包括原提出者自己)建议把核技巧应用到那些最大边界超平面来创建一个非线性分类器。结果引起了研究“核方法”的一片浪潮，而核方法开始成为一个最有力的而且最受欢迎的分类方法。 不容置疑的是，核技巧是一种非常有力的工具，它提供了一种仅仅依赖于求两个向量的点积的算法来打通了线性和非线性的之间的桥梁。事实上，我们首先把输入数据映射到一个高维空间，然后一个线性的算法就可以在这个空间上操作在原始空间中的非线性的输入数据。 这个“技巧”的厉害之处在于它根本就不用计算映射后的点积；我们所需要做的是找到一个适合的核函数来代替所有的点积(这样便可以简化了计算)。核函数标记特征空间中的一个内积，它通常记为：(其中Ψ()代表映射函数)。 利用核函数，算法能被带入到高维空间而不需要明确的把输入点映射到这个空间上。这是非常取巧的，特别是当高维的特征空间是无穷多维的，它是不可以计算的时候。正是由于原始的SVM的公式中包含点积运算，它是可以直接应用核技巧的。即使结果分类器在高维特征空间中是个超平面，但在原始空间中它还是非线性的。核技巧的应用同样为不同的视野去进行比较的分类器提供了非常有力的理论支持，例如，生物。 可以很明显的看出，通过核函数(of the form K(z,x) &#x3D; &lt;z,x&gt; &#x3D; zTx)，我们又得到了原始线性SVM的相似公式。想了解更详细的关于核技巧的资料和核函数应用的例子，可以参考previous article about Kernel Discriminant Analysis，或者Kernel Functions for Machine Learning Applications。 多分类的支持向量机 很不幸的，不像KDA，支持向量机并没有很自然的推广到多分类的问题。原始的SVM是一个二类分类器，它一次只可以在两个分类中进行预测。然而，现实问题需要更多的是可以用SVM解决多分类问题，下面我们就来举一个例子。 假设我们有三个分类A,B,C。现在，假设我们只有二类分类器，那么我们怎么把二类分类器去解决一个多分类器的问题呢？其中一个可行的方法就是把我们的多分类问问题拆成多个二类分类器的集合。下面左边的矩阵是泳衣解决三个分类的分类器的二类分类器的所有组合： 然而，注意到上面左边的矩阵中有一些多余的情况。譬如，计算AxA是没有意义的。还有，计算AxB之后再计算BxA是很低效率的，我们计算了AxB后，可以通过取反就得到了BxA。丢弃了多余的选项后，我们只剩下右边的(半透明的，除了AxA,BxB,CxC)矩阵。观察可知，一个n类的分类问题可以拆分成n(n-1)&#x2F;2个二类分类器的组合组成的小的子集合。 现在我们得到了3个二类分类的问题，所以，我们需要创建3个SVM来解决每一个子问题。 要确定一个分类，我们就看3个SVM当中谁的投票最多。譬如，A在第一个SVM中胜出，而C在其他的两个SVM中都胜出。 如果我们把胜出次数最多的作为赢家，那么我们应该把它归为C类。这种方法通常称作多分类器中的”一对一”策略。 另外一种方法是利用“一对多”的策略，把输入放到所有的SVM中，然后选择最高的输出的那个SVM。很不幸的，我们不能保证有最高的输出就是最好的SVM。这个不作本文讨论的范畴。 源代码 基于核方法的支持向量机的代码也是属于Accord.NET的一部分，这个框架我做了数年。它是在AForge.NET的顶层建立的,AForge.NET是计算机视觉，机器学习中非常受欢迎的框架，它集合了我过去的研究中的多个主题。目前，它有了PCA, KPCA, LDA, KDA, LR, PLS, SVMs, HMMs, LM-ANN和其他的缩写。这个项目在Github上举办，地址是：https://github.com/accord-net/framework/。最小的版本中包含了最小的bug修正，完善和功能加强，新特征等，我强烈推荐大家直接从Github上下载最新的版本库。 支持向量机 支持向量机类结构如下：(C#和VB实现) KernelSupportVectorMachine类继承SupportVectorMachine类，加了kernel方法。MulticlassSupportVectorMachine类集合了一堆实现了“一对一”策略的KernelSupportVectorMachines类来实现多分类器。框架的API在此：extensive list of machine learning kernel functions to chose from. 训练算法 训练算法既可以实现分类也可以实现回归。它们是Platt的序列最优化(SMO)算法的直接实现。MulticlassSupportVectorLearning类提供了一个回调函数，名字是Configure，它可以被任何的算法选择并进行配置。这个方法并没有强加需要利用哪一种算法，而且还允许用户利用自定义的算法来进行训练。 因为MulticlassSupportVectorLearning算法一次可以训练一堆独立的机器，所以它容易实现并行运算。事实上，这些实现方法在单台机器中可以充分利用剩下的核。123456789101112131415161718192021222324252627/// &lt;summary&gt;/// Runs the one-against-one learning algorithm./// &lt;/summary&gt;public double Run(bool computeError)&#123; // For each class i AForge.Parallel.For(0, msvm.Classes, delegate(int i) &#123; // For each class j for (int j = 0; j &lt; i; j++) &#123; // Retrieve the associated machine var machine = msvm[i,j]; // Retrieve the associated classes int[] idx = outputs.Find(x =&gt; x == i || x == j); double[][] subInputs = inputs.Submatrix(idx); int[] subOutputs = outputs.Submatrix(idx); // Transform in a two-class problem subOutputs.ApplyInPlace(x =&gt; x = (x == i) ? -1 : 1); // Train the machine on the two-class problem. configure(machine, subInputs, subOutputs).Run(false); &#125; &#125;);&#125; 上面的代码利用了AForge.NET Parallel的构造器和Accord.NET matrix extensions。我决定不用最新加的 .NET 4.0 Parallel Extensions,所以这个框架还是兼容.NET 3.5 applications的应用的。 数字识别UCI的光学数字数据集 如果你读了上一篇文章Kernel Discriminant Analysis for Handwritten Digit Recognition，那么请跳过本小节。本小节只是对UCI机器学习的光学数字数据库的介绍。 UCI机器学习库是一个被机器学习社区用于做机器学习算法实践分析的数据库，域理论，数据生成器的集合。其中一个就是光学识别的手写数字数据集，又叫Optdigits Dataset. 原始的光学数字数据是一个个32x32的矩阵。它们提供经过预处理的数字形式，数字被分成非重叠的4x4块，每一块上像素都合计了。这就生成了8x8输入矩阵，每一个元素都是0到16的整数。 基于多分类的SVM的数字分类器 核方法引起了很大的兴趣，因为它可以应用到那些需要进行预处理的(例如，数据降维)数据的问题上和被模型化的数据结构的扩展知识上。即使我们对数据知之甚少，核方法的直接应用往往得到令人感兴趣的结果。利用核方法实现最佳化是一个非常难的任务，因为我们用无穷多的核函数可供选择，而每个核函数也有无穷多的参数可供调整。 下面的代码向我们展示了基于核函数的支持向量机是怎么实现的。输入的是一个1024的全向量。这个对神经网络来说是不切实际的，例如，通常的核方法处理高维数的问题是没问题的，因为它不会遭受维数灾难。123456789101112131415161718192021222324252627282930313233343536// Extract inputs and outputsint samples = 500;double[][] input = new double[samples][];int[] output = new int[samples];for (int i = 0; i &lt; samples; i++)&#123; ...&#125;// Create the chosen Kernel with given parametersIKernel kernel = new Polynomial((int)numDegree.Value, (double)numConstant.Value);// Create the Multi-class Support Vector Machine using the selected Kernelksvm = new MulticlassSupportVectorMachine(1024, kernel, 10);// Create the learning algorithm using the machine and the training datavar ml = new MulticlassSupportVectorLearning(ksvm, input, output);// Extract training parameters from the interfacedouble complexity = (double)numComplexity.Value;double epsilon = (double)numEpsilon.Value;double tolerance = (double)numTolerance.Value;// Configure the learning algorithmml.Configure = delegate(KernelSupportVectorMachine svm, double[][] cinput, int[] coutput)&#123; var smo = new SequentialMinimalOptimization(svm, cinput, coutput); smo.Complexity = complexity; smo.Epsilon = epsilon; smo.Tolerance = tolerance; return smo;&#125;;// Train the machines. It should take a while.double error = ml.Run(); 应用例子学习 样例应用附带源代码，它实现了基于核函数的多分类支持向量机的手写数字识别。下载了应用后，打开并点击菜单，然后选择”Open”。它就会载入数据。 要开始训练数据，点击“Start training”。利用默认设置，应该不会太长时间。因为代码是用了并行运算，核数越多，训练越快。 训练完成后，点击“Classify”开始分类测试数据集。利用默认值，它应该可以得到95%的正确率，大概是500个数据中有475个分类正确。识别率的大小会随着每次训练的不同而有小小的波动。 相同的集合和相同的训练和测试样本已经在上一篇中的基于核方法的判别分析方法中使用。而SVM却得到更高的运行效率和更少的内存，更多的样本数可能得到更高的正确率。 训练后，创建的SVM可以在“Machine”这个tab中看到。每次的SVM的支持向量和临界值可以在第一个数据格视图中通过选择一个数据入口而看到。向量越暗，在决策过程中它的权值就越大。 结果 即使识别率刚刚超过3%，但是识别的正确率已经比KDA大大的提升了。点击“Classification”tab，我们可以手动地为用户手写的数字测试多分类支持向量机。 我们看到SVM方法产生了更强壮的结果，即使手写很差的数字也能识别正确： 最后，有一个视频演示： 总结 在本文中，我们详细叙述和探索了基于核方法的SVM来解决手写数字识别的问题，并且可以得到更好的结果。 SVM适合小样本的数据训练。 继续阅读 Handwriting Recognition using Kernel Discriminant Analysis Kernel Functions for Machine Learning Applications Kernel Support Vector Machines (SVM) Principal Component Analysis (PCA) Kernel Principal Component Analysis (KPCA) Linear Discriminant Analysis (LDA) Non-Linear Discriminant Analysis with Kernels (KDA) Logistic Regression Analysis 参考 Wikipedia contributors,“Sequential Minimal Optimization”, Wikipedia, The Free Encyclopedia,http://en.wikipedia.org/wiki/Sequential_Minimal_Optimization (accessed April 24, 2010). Wikipedia contributors, “Support Vector Machine”, Wikipedia, The Free Encyclopedia,http://en.wikipedia.org/wiki/Support_vector_machine,(accessed April 24, 2010). John C. Platt,Sequential Minimal Optimization: A Fast Algorithm for Training Support Vector Machines , Microsoft Research, 1998. J. P. Lewis,A Short SVM (Support Vector Machine) Tutorial.,CGIT Lab &#x2F; IMSC, University of Southern California. A. J. Smola and B. Scholkopf,A Tutorial on Support Vector Regression.,NeuroCOLT2 Technical Report Series, 1998. S. K. Shevade et al.Improvements to SMO Algorithm for SVM Regression,1999. G. W. Flake, S. LawrenceEfficient SVM Regression Training with SMO A. Asuncion &amp; D.J. Newman,UCI Machine Learning Repository.Irvine, CA: University of California, School of Information and Computer Science (2007). Andrew Kirillov,The AForge.NET Framework.The AForge.NET Computer Vision, Artificial Intelligence and Robotics Website, 2010. C. R. Souza, Kernel Functions for Machine Learning Applications. 17 Mar. 2010. Web. 后记 翻译这篇文章后，除了对翻译的难度有了更深一层的认知之后，本次只要是对SVM进行多分类问题的解决有了更深的认识。SVM本来是一个二类分类器，那么要解决多分类问题，应该要什么思路呢？就是用二类分类器进行组合，然后通过“一对一”策略来解决多分类分类器。","categories":[{"name":"毕业设计系列","slug":"毕业设计系列","permalink":"http://example.com/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"手写数字识别","slug":"手写数字识别","permalink":"http://example.com/tags/%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"},{"name":"Kernel Support Vector Machine","slug":"Kernel-Support-Vector-Machine","permalink":"http://example.com/tags/Kernel-Support-Vector-Machine/"}]},{"title":"最小二乘法论文翻译-毕设系列","slug":"毕业设计系列/最小二乘法论文翻译-毕设系列","date":"2015-01-01T11:57:02.000Z","updated":"2015-01-02T05:01:18.000Z","comments":true,"path":"2015/01/01/毕业设计系列/最小二乘法论文翻译-毕设系列/","link":"","permalink":"http://example.com/2015/01/01/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91-%E6%AF%95%E8%AE%BE%E7%B3%BB%E5%88%97/","excerpt":"","text":"写在前面的话 本篇论文是布朗大学数学系Steven J. Miller∗教授的论文翻译。 出处：The Method of Least Squares-Steven J. Miller∗ 最小二乘法 Steven J. Miller* 布朗大学，数学系 普罗维登斯（美国罗得岛州的首府），RI 02912 摘要 原文 译文 最小二乘法是求解数据的最佳线性拟合的过程；它可以用简单微积分和线性代数来证明。根本的问题就是根据给定数据集(xn,yn),其中n属于{1,…,N}，然后对这些数据集求解y&#x3D;ax+b最佳拟合直线。这个方法容易推广为求解最佳拟合直线的形式为：上式中右边的f(x)不需要对x成线性关系，但等式右边的必须是函数的线性组合。 目录 问题的描述 概率与统计知识的回顾 最小二乘法 1.问题的描述 现实生活中，我们经常需要找到多个变量之间的线性关系。比如，弹簧的拉力和弹簧的长度成线性关系：y&#x3D;kx(y是拉力，x是弹簧的长度，k是常数)。为了验证以上线性关系，研究者们在实验室测量不同拉力下的不同长度。然后他们按(xn,yn)，其中n属于{1,…,N}的形式收集数据，这里的yn是以牛顿为单位，xn是以米为单位。 很不幸的，它很难验证出我们上面那么精确的线性关系。原因有以下两个。第一个是实验误差，第二个是可能弹簧的拉力和长度不是成线性关系的。观察图1，弹簧定长为5的拉力和长度的测量数据集模拟。 最小二乘法是一个过程，它需要简单的微积分和线性代数，去决定什么是数据的“最佳拟合”线。当然，我们需要衡量“最佳拟合”的标准，那我们就要用上一些概率和统计学的知识了。 对证明的一个比较谨慎分析表明最小二乘法有很强的泛化能力。虽然求解不出精确的最佳拟合直线，但我们可以求解出给定的特定函数的有限线性组合。所以问题是，给定函数f1,f2…fk，求出以下线性组合中的系数a1,a2…ak的值。就是对数据的最好的估计。 2.概率与统计知识的回顾 下面我们对最小二乘法需要用到的概率和统计相关的基本元素做一个快速的介绍；详细请看[BD, CaBe, Du, Fe, Kel, LF, MoMc]。 给定一个数据序列x1,x2…xN,我们定义平均数(或期望值)为(x1+x2+…+xN)&#x2F;N。我们在x的上面加上一横作为标记：平均数就是数据的均值。 观察下面两个数据序列：{10, 20, 30, 40, 50}和{30, 30, 30, 30, 30}。两个序列有相同的均值；但是，对于各个数和均值的差值，第一个序列有更大的变动。这就导出了方差的概念，方差是验证数据距离均值的波动程度大小的有用的工具。{x1, . . . , xN}的方差记为，式子如下：标准差是方差的开平方： 注意到如果x的单位是米，那么方差的单位是平方米，而标准差和平均数的单位还是米。所以，用标准差来测量数据距离均值的波动更合适。 当然，我们还有另外的方法可用，例如： 但是这是一个带符号的数量，最大的正偏差和最大的负偏差会相互抵消。实际上，由平均数的定义就可以知道上面的式子结果为0！这是一个非常糟糕的数据偏差的测量，因为0对数据来说一点意义都没有。 我们可以通过绝对值来纠正这个问题，就如下面的式子： 虽然绝对值的好处是消除征服误差相互抵消的问题（而且它也有相同的单位），但绝对值函数并非一个好的函数分析。它是不可微的。这也是我们选用标准差的首要原因–它可以让我们利用微积分工具。 现在我们可以衡量“最佳拟合”的标准了。如果我们相信y&#x3D;ax+b,那么y-(ax+b)应该等于0.所以，给定观测量我们观察： 均值和应该是越小越好，然后求出方差就可以知道我们的数据拟合得好不好了。 那么这个数据集的方差是： 大误差应该给于大的权值，而小误差应该给于小的权值(因为误差进行了平方)。所以我们的最小二乘法更喜欢中等的误差而不是大误差。如果我们利用绝对值函数求误差(式子2.6)，那么所有的误差的权值都是一样的；而且，绝对值函数是不可微的，也就是用不了微积分工具的。 3.最小二乘法 给定数据,我们可以根据y&#x3D;ax+b计算误差： 这就是数据集方差的N倍。那么我们研究方差的N倍和方差本身是没有差别的，我们注意到上面的错误是两个变量的函数。 我们的目标是求出令误差E(a,b)达到最小的a和b的值。在多变量微积分中我们知道对E(a,b)要分布求a和b的偏导数，并且偏导数等于0： 我们不需要考虑边界点：因为|a|和|b|值越大，拟合就变得越差。所以，我们不需要考虑边界点。 对E(a,b)求偏微分得： 假设(除以2)得到： 我们可以重写这些等式： 我们已经得到a和b的值了，它们能令误差最小，满足以下矩阵等式： 我们会证明矩阵是不可逆的，暗示着： 记矩阵为M，那么M的行列式是： 当： 我们得到： 上面最后的等式遵循简单的代数。所以，只要所有的Xn都不相等，detM的值就是非0而且是可逆的。 结论是，只要所有的x都不相等，那么最好的拟合的a和b的值可以通过求解一个线性方程组而得到；解在式子3.16给出了。 标记3.1 描绘在图1中的点是令xn&#x3D;5+0.2n，然后令yn&#x3D;5xn，再加上一个均值为0，标准差为4(n ∈ {1, . . . , 100})的正态分布的随机误差。利用这些值，我们找到一条最佳拟合直线为：所以，a&#x3D;4.99,b&#x3D;0.48.相比我们期望的关系：y&#x3D;5*x,我们期望一个更好的拟合值，a&#x3D;5,b&#x3D;0. 当a的值越来越接近真实值，b的值就会越来越小了。我们特地选取数据的这个特性来反映出在使用最小二乘法的问题。我们知道斜率的最佳值是4.99，而截距的最佳值是0.48，但是这并不是最好的估计。理论需要误差评估的技术支持。所以，我们想知道根据给定的数据，a落在(4.96,5.02)之间和b落在(-0.33,1.18)之间有99%的机会；这比我们仅仅知道最佳值更有用。 另外，如果我们用绝对值的方法：那么算出的a的最佳值是5.03，b的最佳值是小于10的负10次方。这两种方法(绝对值方法和最小二乘法)求解出的不同的a和b是因为它们对错误的权值取值不同。 后记 这次虽然不是第一次翻译，但还是遇到许多人埋怨的翻译问题，就是由原文翻译到中文是一道很大的坑，真的很多地方不知道如何翻译，你要联系上下文，分析清楚语境，才能准确地翻译出它想表达的意思，而这不是一件很容易的事件，对于那些需要某些领域的专业知识的就是更难了。 所以，那么老是埋怨翻译人翻译的很差的人，还是不要那么激动的好，毕竟翻译也有翻译的痛。不过，无论怎样，这次翻译无论对我的理论知识的理解还是阅读英文文刊的能力都是有所增进的。 参考文献列表","categories":[{"name":"毕业设计系列","slug":"毕业设计系列","permalink":"http://example.com/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"最小二乘法 论文翻译","slug":"最小二乘法-论文翻译","permalink":"http://example.com/tags/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95-%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"}]},{"title":"多线程笔记","slug":"alogrithms/Multithreading-note","date":"2014-12-26T03:13:38.000Z","updated":"2023-07-22T02:27:55.944Z","comments":true,"path":"2014/12/26/alogrithms/Multithreading-note/","link":"","permalink":"http://example.com/2014/12/26/alogrithms/Multithreading-note/","excerpt":"","text":"写在前面的话 Java中的多线程是一项非常重要的学习内容。多线程的引入强化了程序的执行能力，提高了程序的执行效率。那么多线程到底是神马呢？本文将更随毕向东老师的思路揭开多线程的谜底。 本文笔记是除了在《毕向东Java基础》视频的基础上所做的笔记之外，还做深层的扩展。 多线程概念认识进程 在认识多线程之前，我们需要先了解“进程”这个概念。那么什么是进程呢？进程是操作系统的基础，它是程序的一次执行。即是程序完成的一次由开始到结束的执行过程。进程包括运行中的程序和程序所使用到的内存和系统资源，而一个进程又是由多个线程所组成的。 参考：进程 认识线程 那么什么又是线程呢？线程其实是进程当中的一个执行路径，它是进程中的一个独立的控制单元。每个进程都可以包含多个执行路径，每个进程必须包含一个线程，叫做进程的主线程。 参考：线程 认识多线程 多线程就是指一个进程中包含多个执行路径，即是在一个程序中可以同时运行多个不同的线程来执行不同的任务。最简单的例子就是JVM，JVM是一个多线程的进程，它启动之后不止一个线程，还包括了垃圾回收的线程。 为什么需要线程 可以提高程序的运行效率 可以优化程序的执行能力 多线程的实现(Java) 查阅api文档，可以知道Java多线程的实现有2种方法。第一种是继承java.lang.Thread类；第二种是实现java.lang.Runnable接口。 继承java.lang.Thread类的多线程实现 步骤： 定义一个类，继承java.lang.Thread类 复写Thread类中的run()方法，目的：将自定义的代码存储在run方法中，让线程运行。 调用线程的start()方法，该类有2个作用：启动线程和调用run()方法。 代码实现 12345678910111213141516171819202122// 定义一个类，继承java.lang.Thread类class Demo extends Thread &#123; // 复写Thread类中的run()方法 public void run () &#123; for (int i = 0; i &lt; 60; i++) &#123; System.out.println(&quot;demo run!------&quot;+i); &#125; &#125; &#125; public class ThreadDemo &#123; public static void main(String[] args) &#123; Demo d = new Demo(); // 调用线程的start()方法 d.start(); for (int i = 0; i &lt; 60; i++) &#123; System.out.println(&quot;Hello World run!---------&quot;+i); &#125; &#125;&#125; 运行结果12345678910111213141516171819202122232425demo run!------0demo run!------1demo run!------2Hello World run!---------0demo run!------3Hello World run!---------1demo run!------4Hello World run!---------2demo run!------5demo run!------6demo run!------7demo run!------8........Hello World run!---------31demo run!------29Hello World run!---------32demo run!------30Hello World run!---------33demo run!------31Hello World run!---------34......Hello World run!---------58Hello World run!---------59 结果分析：发现每次运行的结果都不一样 (单核CPU)某个时刻只能执行一个线程 不同的线程都在抢夺CPU的执行权，谁抢到谁执行 CPU做着快速的切换，所以看起来像是多个线程同时在运行 CPU的随机性，它想执行哪个线程，哪个线程才可以被执行 为什么要复写Thread类当中的run()方法呢？为什么是调用start()方法而不是run()方法呢？实现java.lang.Runnable接口的多线程实现线程的运行状态后记参考链接 线程及多线程的作用-CSDN-blog java 如何实现多线程-CSDN-blog 黑马程序员-JAVA基础-多线程（上）-cnblogs 线程7种状态的相互转换","categories":[{"name":"技能-修行-进步","slug":"技能-修行-进步","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"单例设计模式","slug":"alogrithms/Singleton-note","date":"2014-12-25T08:30:38.000Z","updated":"2023-07-16T01:35:15.008Z","comments":true,"path":"2014/12/25/alogrithms/Singleton-note/","link":"","permalink":"http://example.com/2014/12/25/alogrithms/Singleton-note/","excerpt":"","text":"写在前面的话 本次笔记是在看了《毕向东Java基础》视频之后写的，对于毕老师讲课的优点，我想听过他的课的同学都应该知道的，所以我也不想多说了，但我还是忍不住再说一下，就是幽默风趣，讲课条理清晰，了解学生学习的难点，并能引领大家的思路。 另外，由于这是基础视频，所以讲的内容还是比较简单的。因此，我在课外进行了补充学习，希望能把这个单例模式问题学得更深更透！ 什么是单例设计模式什么是设计模式？ 首先第一个问题就是：什么是单例设计模式？要弄懂这个问题，我们首先要理解什么是设计模式。设计模式原本并不是软件开发领域首创的，它是建筑领域的一套理论知识。所谓设计模式，就是解决同一类问题的一种方法，它面向的是高层的抽象理念，和Java中的类和实例之间的关系有相似之处。 单例设计模式解决的问题 单例设计模式面向的问题是什么呢？保证内存中某个类的实例的唯一性。即是说，无论什么时候，在内存中只能存在一个实例。 哪里应用了单例设计模式 这样的设计需要有哪些呢？举些例子来说吧，操作系统当中的垃圾桶，它在系统运行过程中都只有一个实例存在，无论你在C盘删除文件，还是在D盘删除文件，文件垃圾都是保存到同一个垃圾桶实例当中。这个最简单的验证就是：若果你把文件属性中的隐藏文件选择显示，那么你会在系统的任何地方都有一个垃圾桶文件夹，而这并不是说有多个垃圾桶实例，而是一个垃圾桶实例的多个引用。 另外的例子还包括软件的配置文件，其实也是应用了单例设计模式。试想下，若果软件的配置的配置有多个，那么软件在下次运行时应该选择哪么配置文件呢？比如eclipse，你在使用时发现没有显示行数，那么狠明显你是修改配置，行号就可以显示出来，而当你下次启动eclipse时，行号还是显示的。所有配置文件只有一个，你任何的修改都是对一个配置文件进行，这样才能保证下次启动软件时持续生效。 单例设计模式的实现(Java)单例设计模式的思路 为了避免其他程序过多的建立该类对象。先禁止其他程序建立该类对象 为了让其他程序可以访问到该类对象，只好在本类中，自定义一个对象。 为了方便其他程序对自定义对象的访问，可以对外提供一些访问方式。 单例设计模式的代码实现步骤 将构造函数私有化 在类中创造一个本类对象 提供一个方法可以获取到该对象 实现代码12345678910public class SingletonDemo &#123; // 将构造函数私有化 private SingletonDemo() &#123;&#125; // 在类中创造一个本类对象 private static SingletonDemo s = new SingletonDemo(); // 提供一个方法可以获取到该对象 public static SingletonDemo getInstance() &#123; return s; &#125;&#125; 单例设计模式就那么简单吗？ 咋看，觉得代码那么简单，其实并不是那么简单，其中的坑还是不少的。让我们逐层逐层揭开它的神秘面纱吧。 单例设计模式一般有2种形式：懒汉式和饿汉式 懒汉式单例设计模式1234567891011121314// 懒汉式class Singleton &#123; // 私有化构造函数 private Singleton() &#123;&#125; // 创建空引用 private static Singleton instance = null; // 创建实例，并返回对象 public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 上面的代码看上去似乎没什么问题？但其实暗藏了一个安全问题，因为在getInstance()的方法中包含2个语句，并不是原子操作，存在线程安全的问题，导致可能产生多个实例对象。 线程安全的懒汉式单例设计模式(只改getInstance方法)123456public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance;&#125; 以上的代码，在方法前面加了synchronized关键字，表示了线程安全。但是把整个方法都同步了之后，程序的运行速度变得更慢了。为了解决慢的问题，又引出了双重检验锁。 双重检验锁(double checked locking pattern)的懒汉式单例设计模式(只改getInstance方法)1234567891011public static Singleton getSingleton() &#123; if (instance == null) &#123; // Single checked synchronized (Singleton.class) &#123; if (instance == null) &#123; // Double checked instance = new Singleton(); &#125; &#125; &#125; return instance;&#125; 这段代码貌似很完美了，但很遗憾地，它还是有问题的。主要是instance &#x3D; new Singleton()这句，这并非是一个原子操作，事实上在JVM中执行这个语句时做了以下3个事情。 给instance分配内存 调用Singleton的构造函数来初始化成员变量 将instance对象指向分配的内存空间(执行完这步instance才是非空) 但在JVM的即时编译器中存在指令重排序的优化。也就是上面的第2步和第3步的顺序是不能保证的，最终的执行顺序可能是1-2-3，也可能是1-3-2.如果是后者，则在3执行完毕、2未执行前，被线程二抢占了，这时的instance已经是非null(但却没有初始化)，所以线程二会直接返回instance，然后使用，然后顺理成章地报错了。（摘抄自大牛原文） 那我们应该怎么办呢？我们把instance变量声明为volatile就可以了。1234567891011121314151617public class Singleton &#123; private volatile static Singleton instance; private Singleton() &#123;&#125; private static Singleton getSingleton() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; (大牛解释） 有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。 但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。 相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。 饿汉式单例设计模式1234567891011// 饿汉式class Singleton &#123; // 类加载时就初始化 private static final Singleton instance = new Singleton(); private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 这种方法非常简单，因为单例的实例被声明成static和final变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。 但是这种方法还是有问题的，它的缺点是它不是一种懒加载模式(lazy initialization)，单例会在加载类后一开始就被初始化，即使客户端没有调用getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如Singleton实例的创建时依赖参数或者配置文件的，在getInstance()之前必须调用某个方法设置参数给它，那么这种单例写法就无法使用了。 静态内部类的单例设计模式123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton () &#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 这种写法仍然使用JVM本身机制保证了线程安全问题；由于SingletonHolder 是私有的，除了getInstance()之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖JDK版本。 枚举Enum 用枚举来实现单例真的太简单了！123public enum EasySingleton &#123; INSTANCE;&#125; 我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。但是还是很少看到有人这样写，可能是因为不太熟悉吧。 后记 一般来说，在开发中常用的是饿汉式的单例模式。 参考：如何正确地写出单例模式","categories":[{"name":"技能-修行-进步","slug":"技能-修行-进步","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5/"}],"tags":[{"name":"单例设计模式","slug":"单例设计模式","permalink":"http://example.com/tags/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"chap1-variable-assignment","slug":"技能-修行-进步-R语言/chap1-variable-assignment","date":"2014-11-18T13:35:05.000Z","updated":"2023-07-22T02:12:34.422Z","comments":true,"path":"2014/11/18/技能-修行-进步-R语言/chap1-variable-assignment/","link":"","permalink":"http://example.com/2014/11/18/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-R%E8%AF%AD%E8%A8%80/chap1-variable-assignment/","excerpt":"","text":"Last TutorialVariable assignment(1) A basic concept in (statistical) programming is called a varibale. A variable allows you to store a value (e.g.4) or an object (e.g. a function description) in R. You can then later use this variable’s name to easily access the value or the object that is stored within this variable. You can assign a value 4 to a variable my_variable with the command: my_variable &#x3D; 4. Exercises112345&gt; # Assign the value 42 to x&gt; x = 42&gt; # Print out the value of the variable x&gt; x[1] 42 Variable assignment(2) Suppose you have a fruit basket with five apples. As a data ananlyst in training, you want to store the number of apples in a variable with the name my_apples. Exercises212345&gt; # Assign the value 5 to the variable called my_apples&gt; my_apples &lt;- 5&gt; # Print out the value of the variable my_apples&gt; my_apples[1] 5 Variable assignment(3) Every tasty fruit basket needs oranges, so you decide to add six oranges. As a data ananlyst, your reflex is to immediately create the variable my_orange and assign the value 6 to it. Next, you want to calculate how many pieces of fruit you have in total. Since you have given meaningful names to these values, you can now code this in a clear way:my_apples + my_oranges. Exercise312345678&gt; # Assign a value to the variables called my_apples and my_oranges&gt; my_apples = 5&gt; my_oranges = 6&gt; # Add these two variables together and print the result&gt; print(my_apples + my_oranges)[1] 11&gt; # Create the variable my_fruit&gt; my_fruit = my_apples + my_oranges Apples and oranges Common knowledge tells you not to add apples and oranges. But hey, that is what you just did, no:-)? The my_apples and my_oranges variables both contained a number in the previous exercise. The + operator works with numeric variables in R. If you really tried to add “apples” and “oranges”, and assigned a text value to the variable my_oranges (see the editor), you would be trying to assign the addition of a numeric a character variable to the variable my_fruit. This is not possible. Exercise4123456789101112131415&gt; # Assign a value to the variable called my_apples&gt; my_apples = 5&gt; # Print out the value of my_apples&gt; my_apples[1] 5&gt; &gt; # Add a character&gt; my_oranges = 6&gt; my_oranges[1] 6&gt; &gt; # New variable that contains total amount of fruit&gt; my_fruit = my_apples + my_oranges&gt; my_fruit[1] 11 Next Tutorial","categories":[{"name":"技能-修行-进步-R语言","slug":"技能-修行-进步-R语言","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-R%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"R Tutorial","slug":"R-Tutorial","permalink":"http://example.com/tags/R-Tutorial/"}]},{"title":"chap1-Intro to basics","slug":"技能-修行-进步-R语言/chap1-Intro-to-basics","date":"2014-11-18T12:09:15.000Z","updated":"2023-07-22T02:11:56.667Z","comments":true,"path":"2014/11/18/技能-修行-进步-R语言/chap1-Intro-to-basics/","link":"","permalink":"http://example.com/2014/11/18/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-R%E8%AF%AD%E8%A8%80/chap1-Intro-to-basics/","excerpt":"","text":"How it works In the editor on the right you should type R code to solve the exercises. R makes use of the # sign to add comments, so that you and others can understand what the R code is about. Just like Twitter! Comments are not run as R-code,so they will not influence your result. The ouput of your R code is shown in the console int the lower right corner, while graphs are shown in the upper right corner. Instructions In its most basic form, R can thus be used as a calculator or as a means to generate plots, but there is much more;-)! You can see that R has generated some cool visualizations in the upper right corner. Use the arrows above the graphs to browse through these. Exercises12# show some demo graphs generated with Rdemo(&quot;graphics&quot;) 1234567891011121314151617&gt; require(datasets)&gt; require(grDevices); require(graphics)&gt; ## Here is some code which illustrates some of the differences between&gt; ## R and S graphics capabilities. Note that colors are generally specified&gt; ## by a character string name (taken from the X11 rgb.txt file) and that line&gt; ## textures are given similarly. The parameter &quot;bg&quot; sets the background&gt; ## parameter for the plot and there is also an &quot;fg&quot; parameter which sets&gt; ## the foreground color.&gt; &gt; &gt; x &lt;- stats::rnorm(50)&gt; opar &lt;- par(bg = &quot;white&quot;)&gt; plot(x, ann = FALSE, type = &quot;n&quot;) 123456789101112131415161718192021&gt; abline(h = 0, col = gray(.90))&gt; lines(x, col = &quot;green4&quot;, lty = &quot;dotted&quot;)&gt; points(x, bg = &quot;limegreen&quot;, pch = 21)&gt; title(main = &quot;Simple Use of Color In a Plot&quot;,+ xlab = &quot;Just a Whisper of a Label&quot;,+ col.main = &quot;blue&quot;, col.lab = gray(.8),+ cex.main = 1.2, cex.lab = 1.0, font.main = 4, font.lab = 3)&gt; ## A little color wheel. This code just plots equally spaced hues in&gt; ## a pie chart. If you have a cheap SVGA monitor (like me) you will&gt; ## probably find that numerically equispaced does not mean visually&gt; ## equispaced. On my display at home, these colors tend to cluster at&gt; ## the RGB primaries. On the other hand on the SGI Indy at work the&gt; ## effect is near perfect.&gt; &gt; par(bg = &quot;gray&quot;)&gt; pie(rep(1,24), col = rainbow(24), radius = 0.9) ![](/img/r-tutorial-datacamp/01-basics/01-plot.PNG) 123456789101112131415&gt; title(main = &quot;A Sample Color Wheel&quot;, cex.main = 1.4, font.main = 3)&gt; title(xlab = &quot;(Use this as a test of monitor linearity)&quot;,+ cex.lab = 0.8, font.lab = 3)&gt; ## We have already confessed to having these. This is just showing off X11&gt; ## color names (and the example (from the postscript manual) is pretty &quot;cute&quot;.&gt; &gt; pie.sales &lt;- c(0.12, 0.3, 0.26, 0.16, 0.04, 0.12)&gt; names(pie.sales) &lt;- c(&quot;Blueberry&quot;, &quot;Cherry&quot;,+ &quot;Apple&quot;, &quot;Boston Cream&quot;, &quot;Other&quot;, &quot;Vanilla Cream&quot;)&gt; pie(pie.sales,+ col = c(&quot;purple&quot;,&quot;violetred1&quot;,&quot;green3&quot;,&quot;cornsilk&quot;,&quot;cyan&quot;,&quot;white&quot;)) ![](/img/r-tutorial-datacamp/01-basics/02-plot.PNG) 123456789101112131415161718&gt; title(main = &quot;January Pie Sales&quot;, cex.main = 1.8, font.main = 1)&gt; title(xlab = &quot;(Don&#x27;t try this at home kids)&quot;, cex.lab = 0.8, font.lab = 3)&gt; ## Boxplots: I couldn&#x27;t resist the capability for filling the &quot;box&quot;.&gt; ## The use of color seems like a useful addition, it focuses attention&gt; ## on the central bulk of the data.&gt; &gt; par(bg=&quot;cornsilk&quot;)&gt; n &lt;- 10&gt; g &lt;- gl(n, 100, n*100)&gt; x &lt;- rnorm(n*100) + sqrt(as.numeric(g))&gt; boxplot(split(x,g), col=&quot;lavender&quot;, notch=TRUE) ![](/img/r-tutorial-datacamp/01-basics/03-plot.PNG) 123456789101112131415161718&gt; title(main=&quot;Notched Boxplots&quot;, xlab=&quot;Group&quot;, font.main=4, font.lab=1)&gt; ## An example showing how to fill between curves.&gt; &gt; par(bg=&quot;white&quot;)&gt; n &lt;- 100&gt; x &lt;- c(0,cumsum(rnorm(n)))&gt; y &lt;- c(0,cumsum(rnorm(n)))&gt; xx &lt;- c(0:n, n:0)&gt; yy &lt;- c(x, rev(y))&gt; plot(xx, yy, type=&quot;n&quot;, xlab=&quot;Time&quot;, ylab=&quot;Distance&quot;) ![](/img/r-tutorial-datacamp/01-basics/04-plot.PNG) 123456789101112131415&gt; polygon(xx, yy, col=&quot;gray&quot;)&gt; title(&quot;Distance Between Brownian Motions&quot;)&gt; ## Colored plot margins, axis labels and titles. You do need to be&gt; ## careful with these kinds of effects. It&#x27;s easy to go completely&gt; ## over the top and you can end up with your lunch all over the keyboard.&gt; ## On the other hand, my market research clients love it.&gt; &gt; x &lt;- c(0.00, 0.40, 0.86, 0.85, 0.69, 0.48, 0.54, 1.09, 1.11, 1.73, 2.05, 2.02)&gt; par(bg=&quot;lightgray&quot;)&gt; plot(x, type=&quot;n&quot;, axes=FALSE, ann=FALSE) ![](/img/r-tutorial-datacamp/01-basics/05-plot.PNG) 123456789101112131415161718192021222324252627&gt; usr &lt;- par(&quot;usr&quot;)&gt; rect(usr[1], usr[3], usr[2], usr[4], col=&quot;cornsilk&quot;, border=&quot;black&quot;)&gt; lines(x, col=&quot;blue&quot;)&gt; points(x, pch=21, bg=&quot;lightcyan&quot;, cex=1.25)&gt; axis(2, col.axis=&quot;blue&quot;, las=1)&gt; axis(1, at=1:12, lab=month.abb, col.axis=&quot;blue&quot;)&gt; box()&gt; title(main= &quot;The Level of Interest in R&quot;, font.main=4, col.main=&quot;red&quot;)&gt; title(xlab= &quot;1996&quot;, col.lab=&quot;red&quot;)&gt; ## A filled histogram, showing how to change the font used for the&gt; ## main title without changing the other annotation.&gt; &gt; par(bg=&quot;cornsilk&quot;)&gt; x &lt;- rnorm(1000)&gt; hist(x, xlim=range(-4, 4, x), col=&quot;lavender&quot;, main=&quot;&quot;) ![](/img/r-tutorial-datacamp/01-basics/06-plot.PNG) 123456&gt; title(main=&quot;1000 Normal Random Variates&quot;, font.main=3)&gt; ## A scatterplot matrix&gt; ## The good old Iris data (yet again)&gt; &gt; pairs(iris[1:4], main=&quot;Edgar Anderson&#x27;s Iris Data&quot;, font.main=4, pch=19) ![](/img/r-tutorial-datacamp/01-basics/07-plot.PNG) 12pairs(iris[1:4], main=&quot;Edgar Anderson&#x27;s Iris Data&quot;, pch=21,+ bg = c(&quot;red&quot;, &quot;green3&quot;, &quot;blue&quot;)[unclass(iris$Species)]) ![](/img/r-tutorial-datacamp/01-basics/08-plot.PNG) 123456789101112131415161718192021222324252627282930&gt; ## Contour plotting&gt; ## This produces a topographic map of one of Auckland&#x27;s many volcanic &quot;peaks&quot;.&gt; &gt; x &lt;- 10*1:nrow(volcano)&gt; y &lt;- 10*1:ncol(volcano)&gt; lev &lt;- pretty(range(volcano), 10)&gt; par(bg = &quot;lightcyan&quot;)&gt; pin &lt;- par(&quot;pin&quot;)&gt; xdelta &lt;- diff(range(x))&gt; ydelta &lt;- diff(range(y))&gt; xscale &lt;- pin[1]/xdelta&gt; yscale &lt;- pin[2]/ydelta&gt; scale &lt;- min(xscale, yscale)&gt; xadd &lt;- 0.5*(pin[1]/scale - xdelta)&gt; yadd &lt;- 0.5*(pin[2]/scale - ydelta)&gt; plot(numeric(0), numeric(0),+ xlim = range(x)+c(-1,1)*xadd, ylim = range(y)+c(-1,1)*yadd,+ type = &quot;n&quot;, ann = FALSE) ![](/img/r-tutorial-datacamp/01-basics/09-plot.PNG) 1234567891011121314151617181920&gt; usr &lt;- par(&quot;usr&quot;)&gt; rect(usr[1], usr[3], usr[2], usr[4], col=&quot;green3&quot;)&gt; contour(x, y, volcano, levels = lev, col=&quot;yellow&quot;, lty=&quot;solid&quot;, add=TRUE)&gt; box()&gt; title(&quot;A Topographic Map of Maunga Whau&quot;, font= 4)&gt; title(xlab = &quot;Meters North&quot;, ylab = &quot;Meters West&quot;, font= 3)&gt; mtext(&quot;10 Meter Contour Spacing&quot;, side=3, line=0.35, outer=FALSE,+ at = mean(par(&quot;usr&quot;)[1:2]), cex=0.7, font=3)&gt; ## Conditioning plots&gt; &gt; par(bg=&quot;cornsilk&quot;)&gt; coplot(lat ~ long | depth, data = quakes, pch = 21, bg = &quot;green3&quot;) ![](/img/r-tutorial-datacamp/01-basics/10-plot.PNG) 1&gt; par(opar) ![](/img/r-tutorial-datacamp/01-basics/11-plot.PNG) 123# Calculate 3+43 + 4[1] 7 Next Tutorial","categories":[{"name":"技能-修行-进步-R语言","slug":"技能-修行-进步-R语言","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-R%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"R Tutorial","slug":"R-Tutorial","permalink":"http://example.com/tags/R-Tutorial/"}]},{"title":"概率论基本概念1","slug":"alogrithms/概率论基本概念1","date":"2014-11-06T14:28:33.000Z","updated":"2023-07-16T01:39:24.882Z","comments":true,"path":"2014/11/06/alogrithms/概率论基本概念1/","link":"","permalink":"http://example.com/2014/11/06/alogrithms/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B51/","excerpt":"","text":"定量数据的统计特征 在对一组统计数据的分布变化进行深入研究之前，我们首先研究一组数据的特征。为了比较精确地描述一组统计资料的特征，需要使用一些统计指标来描述它。下面我们讨论一下数据统计特征的四个方面。 集中趋势 集中趋势，也称做中心位置。即表示一组数据的中心位置的数据是在什么地方，也就是数据集中分布的位置。 一组数据的集中趋势通常用平均数、中位数和众数等来表示。这些统计量均称为平均指标。平均指标的特点是将一组数据中各个数据之间的差异抽象化，用一个指标来代表各个数据的一般水平，它反映了一组数据中各个数据的代表水平、中心位置或集中趋势。 均数 均数是算术均数的简称。常用表示样本均数，表示总体均数。均数用于反映一组同质观测值的平均水平，适用于正态或近似正态分布的数值变量资料。其计算方法有： 直接法 用于样本含量较少时，其公式为： 式中，希腊字母∑（读作sigma）表示求和；X1,X2…,Xn为观察值；n为样本含量，即观测值的个数。 加权法 用于频数表资料或样本中相同观察值较多时，其公式为： 式中，X1,X2,…,Xn与f1,f2,…,fk分别为相同观察值与其对应的频数（或频数表资料中个组段的组中值和相应组段的频数）。 几何均数 适用于对数正态分布，即数据经过对数变换后呈正态分布的资料；等比级数资料，即观测值之间呈倍数或近似倍数变化的资料。如抗体滴度、平均效价等。其计算方法有： 直接法 适用于样本含量n较小时 或 加权法 频数表资料或样本中相同观察值较多时 注意：计算几何均数时观察值中不能有0，因为0不能取对数；一组观察值中不能同时又正值和负值。 中位数 一组由小到大按顺序排列的观察值中位次居中的数值。 中位数可用于描述： 非正态分布资料（对数正态分布除外）； 频数分布的一端或两端无确切数据的资料； 总体分布不清楚的资料 在全部观察中，小于和大于中位数的观察值个数相等。其计算方法也包括： 直接法 适用于样本含量n较小的资料 把数从小到大排成一列 频数表法 适用于样本含量n较大的资料 离散趋势 在统计学上描述观察值偏离中心位置的趋势，反映了所有观察值偏离中心的分布情况。 描述一组计量资料离散趋势的常用指标有极差、四分位数间距、方差、标准差、标准误差和变异系数等，其中方差和标准差最常用。 极差 极差(range,简记为R)亦称全距。 定义：值一组同质观察值中最大值和最小值之差。极差反映了个体差异的范围：极差大，说明变异度大；反之，极差小，说明变异度小。 公式：R &#x3D; Xmax - Xmin 不足： 仅考虑了最大值和最小值之差，不能反映组内其他观察值的变异度； 样本含量越大，抽到较大或较小的观察值的可能性越大，故极差可能越大。因此，样本含量相差悬殊时不宜用极差比较。 平均差 定义：平均差是指一组数据中的各数据对平均数的离差绝对值的平均数。 一组数据中的各数据对平均数的离差有正有负，其和等于0，因此平均差必须用离差的绝对值来计算。 平均差越大，表示数据之间的变异程度越大，反之，则变异程度越小。 公式： 百分位数 定义：百分位数(percentile)用Px表示，0&lt;x&lt;100，是描述一组数据某百分位的位置指标。Px将全部观察值分为两部分，理论上有x%的观察值比它小，有(100-x%)的观察值比它大。 最常用的百分位数是P50,即中位数。 应用 1.常与中位数结合应用，可以描述一组资料在某百分位置上的水平，也可以描述资料的分布特征。 M - P5 &#x3D; P95 - M, 分布近似对称 M - P5 &lt; P95 - M, 分布呈正偏态 M - P5 &gt; P95 - M, 分布呈负偏态 2.也可用多个百分位数的结合来描述一组观察值的分布特征，如P25和P75合用时，反映中间50%观察值的分布情况； 3.百分位数可用于确定非正态分布资料的医学参考值范围。 计算公式： Lx,i,fx分别为Px所在组段的下限、组距和频数；∑fL为小于L的各组段的累计频数。 注意：应用百分位数，样本含量要足够大，否则不宜取靠近两端的百分位数。 四分位数间距 定义：四分位数间距(quartile interval, Q)为上四分位数与下四分位数之差(或P75与P25之差)。 计算公式： 应用：用于描述偏态分布以及分布的一端或两端无确切数值资料或分布类型未知资料的离散程度。 四分位数间距包括了一组观察值的一半，故可把四分位数间距看成是中间50%观察值的极差。 意义：Q越大，变异度越大；反之，Q越小，变异度越小。 特点：由于四分位数间距不受两端个别极大值或极小值的影响，因而它较极差稳定，但仍未考虑全部观察值的变异度。 方差 极差和四分位数间距都只考虑了个别观察值的大小差异，没有全面反映每个观察值的变异程度。 就总体而言，即应考虑总体中每个观察值X与总体均数μ的差值(X - μ)，即离均差。 因离均差之和∑(X - μ) &#x3D; 0,不能反映变异度的大小，故用例均差平方和∑(X - μ)^2 (sum of squares of deviations from mean)反映之。离均差平方和的大小除与变异度有关外，还与变量值的个数N有关。为了消除这一影响，取离均差平方和的均数，称方差(variance)或均方(mean of squares)。 计算公式： 总体方差： 样本方差： n-1为自由度(degree of freedom),一般用ν(niu)表示。 因方差的度量单位是原度量单位的平方，故计算结果难以解释。 标准差 为了使统计量的单位同观察值单位相一致，通常将方差开平方，即得到标准差，标准差也称为均方差。 计算公式： 总体标准差： 样本标准差： 意义：标准差大，表示观察值的变异度大；反之，标准差小，表示观察值的变异度小。 应用： 适用于描述对称分布资料尤其是正态分布资料的离散程度； 结合均数，描述正态分布资料的频数分布规律，用于估计医学参考值范围； 结合均数，计算变异系数； 结合样本含量，计算标准误差，估计抽样误差，用于统计推断。 变异系数 变异系数(coefficient of variation, CV)，是标准差与均数的比值，用百分数表示，没有单位。 计算公式： 应用：常用于比较度量单位不同或均数相差悬殊的两组(或多组)资料的变异度。 偏度 定义：偏度是指次数分布非对称的偏态方向程度。为了精确测定次数分布的偏斜状况，统计上采用偏斜度指标。 峰度","categories":[{"name":"技能-修行-进步","slug":"技能-修行-进步","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5/"}],"tags":[{"name":"概率论基本概念","slug":"概率论基本概念","permalink":"http://example.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"}]},{"title":"数据挖掘-Aprior-Algorithm","slug":"alogrithms/数据挖掘-Aprior-Algorithm","date":"2014-11-04T00:57:44.000Z","updated":"2023-07-22T02:26:12.052Z","comments":true,"path":"2014/11/04/alogrithms/数据挖掘-Aprior-Algorithm/","link":"","permalink":"http://example.com/2014/11/04/alogrithms/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-Aprior-Algorithm/","excerpt":"","text":"写在前面的话 Aprior Algorithm(先验算法)，它是我在数据挖掘这门课学的第一个算法，由于当时觉得数据挖掘是一门很深奥的学科，所以在学习之前就对它心怀敬畏之心，学起来压力也是很大。不过后来弄懂了之后觉得理解思路也不是很难。 Aprior Algorithm算法背景 Aprior Algorithm是布尔关联规则里的一项基本算法，它是由Rakesh Agrawal和Ramakrishnan Srikant两位博士在1994年提出的。所谓关联，反映的是一个事件和其他事件之间的依赖或相关程度，它包括事件之间的频繁模式、相关性或因果结构，在数据挖掘中它通常也被称为“购物篮分析”(Market Basket analysis)。 关于“购物篮分析”还有一个很有名的故事：美国的妈妈经常叫丈夫到超市帮孩子买尿布，而作为一个男人，由于心理作用，他们觉得自己只是买了尿布就往家提总感觉有点别扭，所以在超市他们顺便提上啤酒这种看上去比较狼性的商品。这一有趣的现象慢慢被超市经理发现了，后来超市就在尿布的旁边摆上了啤酒，这样就省得丈夫们走来走去，可以随手一提就是自己想要的2样东西，结果超市的尿布和啤酒都大卖了。 算法原理Aprior的基本思想 频繁项集的任何子集也一定是频繁的。 基本概念和定义 资料库(Transaction Database):存储着二维结构的记录集。定义为：D 所有项集(Items):所有项目的集合。定义为：I 记录(Transaction):资料库里的子集。定义为：T (T ∈ D) 项集(Itemset)：同时出现的项的集合。定义为：k-itemset(k项集) 支持度(Suppor)：定义为supp(X) &#x3D; occur(x) &#x2F; count(D) &#x3D; P(X) 置信度(Confidence):定义为conf(A-&gt;B) &#x3D; supp(A∪B)&#x2F;supp(A) &#x3D; P(B|A) 算法步骤： Aprior Algorithm算法分2步进行： 扫描数据库，累计每个项的计数，找出所有频繁数据项集，即找出所有支持度超过指定阈值的数据项集。 利用频繁数据项集，生成候选的关联规则，并验证其可信度。如果可信度超过指定阈值，则该候选关联规则为要找的关联规则。 算法应用 例子：以下为AllElectronics的事务数据库D。该数据库有9个事务，即|D|&#x3D;9。![](/img/DM_algo_junior/apriori/01_allElectronics.PNG) (1).在算法的第一次迭代时，每个项都是候选1项集的集合C1的成员。算法简单地扫描所有的事务，对每个项的出现次数进行计数。 (2).假设最小支持度计数为2，即min_sup &#x3D; 2，可以确定频繁1项集的集合L1.它由满足最小支持度的候选1项集组成。在我们的例子中，C1中的所有候选都满足最小支持度。 (3).为了发现频繁2项集的集合L2，算法使用连接L1∞L1产生候选2项集的集合C2.然后进行剪枝，在本例中，没有候选从C2中删除，因为这些候选的每个子集也是频繁的。 (4).扫描D中事务，累计C2中的每个候选项集的支持计数。 (5).然后，确定频繁2项集的集合L2，它由C2中满足最小支持度的候选2项集组成。 (6).如此循环，直到找出所有的频繁项集。 ![找频繁项集](/img/DM_algo_junior/apriori/02_steps.PNG) ![剪枝过程](/img/DM_algo_junior/apriori/03_steps.PNG) 算法的伪代码：![伪代码1](/img/DM_algo_junior/apriori/04_psude_code.PNG) ![伪代码2](/img/DM_algo_junior/apriori/05_psude_code.PNG) 算法的不足与改进算法的不足 可能产生大量的候选集，没有排除不应该参与组合的元素 需要重复扫描数据库，因此如果挖掘数据仓库数据量很大，应用此算法每次迭代产生候选项集用来统计其支持度就需要花费很多时间，而这种代价是随着数据的记录数的增加呈现几何级数的增加。 算法的改进 基于散列的技术 事务压缩 划分 抽样 动态项集计数 FP-growth tree 后记 后记我想首先叹一声：我的妈( ⊙ o ⊙ )啊！原来写一篇这样的算法总结是那么的累！！！我真的是累趴了！！！请叫我大四狗！ 本次博文真所谓是我经历千辛万苦的心血，边写边哭，那资料东找西找，各种躁动，思路不断短路，终于还是OK的完成了。其实我想说，我太渣了。 还有一点，我发现我越来越喜欢抄教材的内容了。 参考链接wikipedia","categories":[{"name":"技能-修行-进步","slug":"技能-修行-进步","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5/"}],"tags":[{"name":"Aprior Algorithm","slug":"Aprior-Algorithm","permalink":"http://example.com/tags/Aprior-Algorithm/"}]},{"title":"DMwR-note-01-预测海藻数量(三)","slug":"技能-修行-进步-R语言/DMwR-note-01-预测海藻数量(三)","date":"2014-10-27T23:39:16.000Z","updated":"2023-07-22T01:34:13.203Z","comments":true,"path":"2014/10/28/技能-修行-进步-R语言/DMwR-note-01-预测海藻数量(三)/","link":"","permalink":"http://example.com/2014/10/28/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-R%E8%AF%AD%E8%A8%80/DMwR-note-01-%E9%A2%84%E6%B5%8B%E6%B5%B7%E8%97%BB%E6%95%B0%E9%87%8F(%E4%B8%89)/","excerpt":"","text":"写在开头的话 讨论了缺失值的处理，相当于对数据进行了简单的预处理，今天我们来继续探讨数据集模型的建立。 数据的模型 数据的模型简单的说就是一个函数，输入就是我们之前的数据algae，而输出就是我们预期的一些值。 本案例的主要研究目的是预测140个水样中7种海藻的出现频率。假设海藻频率是数值型数据，因此可以考虑进行回归分析。简单地说，预测任务是建立一个模型来找到一个数值变量和一组解释变量的关系。这个模型既可以根据未来解释变量的值来预测目标变量，也可以帮助更好地理解问题中各个变量之间的相互联系。 多元化线性回归 多元线性回归模型是最常用的统计数据分析方法，该模型给出了一个有关目标变量与一组解释变量关系的线性函数。 数据缺失值的处理： 12345library(DMwR)data(algae)temp &lt;- algaetemp &lt;- temp[-manyNAs(temp),]clean.algae &lt;- knnImputation(temp, k = 10) 上面的代码首先移除了第62条和第199条水样记录，因为在这两条记录的11个预测变量中有6个是有缺失值的。然后利用数据集个案的相似性来填补缺失值。以上代码运行之后，得到的数据框将不含缺失值。 接下来，将建立一个用于预测海藻频率的线性回归模型： 1summary(lm.a1) 函数lm()建立一个线性回归模型，其中的第一个参数给出了模型的函数形式。在这个例子中，函数的形式是用数据中其他所有变量来预测变量a1，第一个参数中的点”.”代表数据框中除了a1之外的变量。如果需要用预测变量mxPH和NH4来预测变量a1，就要定义模型为“a1~mxPH + NH4”。还有很多其他定义模型的方式，这都称为R公式，后边用到时进行介绍。参数data是用来设定建模所用的数据集。 函数lm()的结果是一个含有线性模型信息的对象。可以通过下列代码获取更多线性模型的信息： 12345678910111213141516171819202122232425262728293031323334lm.a1 &lt;- lm(a1~., data = clean.algae[,1:12])Call:lm(formula = a1 ~ ., data = clean.algae[, 1:12])Residuals: Min 1Q Median 3Q Max -37.679 -11.893 -2.567 7.410 62.190 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 42.942055 24.010879 1.788 0.07537 . seasonspring 3.726978 4.137741 0.901 0.36892 seasonsummer 0.747597 4.020711 0.186 0.85270 seasonwinter 3.692955 3.865391 0.955 0.34065 sizemedium 3.263728 3.802051 0.858 0.39179 sizesmall 9.682140 4.179971 2.316 0.02166 * speedlow 3.922084 4.706315 0.833 0.40573 speedmedium 0.246764 3.241874 0.076 0.93941 mxPH -3.589118 2.703528 -1.328 0.18598 mnO2 1.052636 0.705018 1.493 0.13715 Cl -0.040172 0.033661 -1.193 0.23426 NO3 -1.511235 0.551339 -2.741 0.00674 **NH4 0.001634 0.001003 1.628 0.10516 oPO4 -0.005435 0.039884 -0.136 0.89177 PO4 -0.052241 0.030755 -1.699 0.09109 . Chla -0.088022 0.079998 -1.100 0.27265 ---Signif. codes: 0 ?**?0.001 ?*?0.01 ??0.05 ??0.1 ??1Residual standard error: 17.65 on 182 degrees of freedomMultiple R-squared: 0.3731, Adjusted R-squared: 0.3215 F-statistic: 7.223 on 15 and 182 DF, p-value: 2.444e-12 在解释函数summary()应用到线性模型对象所得到的信息之前，先介绍R如何处理3个名义变量。当像上面一样进行模型构建时，R会生成一组的辅助变量，即对每一个有k个水平的因子变量，R会生成k-1个辅助变量。这些辅助变量的值为0或者1.当辅助变量的值为1，表明该因子出现，同时表明其他所有辅助变量的值为0。如果所有的k-1个变量的值都是0，则表明因子变量的取值为第k个剩余的值。在以上的汇总结果中，可以看到R为因子变量season生成了3个辅助变量(seasonspring, seasonsummer和seasonwinter)。如果某个水样的season变量的取值为”autumn”，则所有3个赋值变量的值将全部为零。 对得到的线性模型对象应用函数summary()，将给出所建立模型的一些诊断信息。首先是有关线性模型中数据拟合的残差(residual)。残差应该是均值为0并且为正态分布。（显然残差最好尽可能的小！） 对于每个多元线性回归方程的系数(变量)，R显示它的估计值和标准误差(这些系数变化程度的估计)。为了检验这些系数的重要性，可以进行这些系数为0的假设检验，即。通常使用t检验来验证这些假设。R计算t值，该值定义为估计系数值与其标准误差的比，即。R将显示与系数相关联的一列(Pr(&gt; |t|))表示系数为0这一假设被拒绝的概率。因此，该值为0.0001表明有99.99%的置信度认为这个系数并非为0。对于每个测试，R都给出一个标志来表示相应的测试置信度水平。总之，仅对于这些前面有标志的系数，我们至少有90%的置信度来拒绝系数为0的一个假设。 另一个由R输出的模型诊断信息是R^2(或者多元R^2或调整R^2)。R^2表明模型与数据的吻合度，即数据所能解释的数据变差的比例。R^2越接近1(几乎100%地解释模型数据的变差)就说模型模拟得很好；R^2越小，说明模型拟合得越差。调整系数则更严格，它考虑回归模型中参数的数量。 最后，我们还可以检验任何解释变量和目标变量没有哦依赖这一原假设，即。可以通过把R给出的F统计值与一个临界值进行比较来进行检验。R提供一个拒绝原假设的置信度水平。因此p值为0.0001表示99.99%的置信度确定原假设是错误的。通常，如果一个模型不能通过这个检验(即得到的p值被认为太大，例如大于0.1)，则单个系数的t检验没有意义。 有些诊断信息也可以通过绘制线性模型来进行检验。实际上，可以用一个类似plot(lm.al)的命令得到一系列的线性模型图，它们有助于了解模型的性能。其中的一个图形绘制拟合的目标变量值和模型残差的散点图。误差相对较大时，R通常在该散点图中添加相应的行数，这样就可以方便地检查这些误差较大的记录。R给出的另一个图形是误差的正态Q-Q图，通过它可以检查误差是否符合应有的正态分布。 该模型解释的方差比例还不是很理想(大约32%)。还可以拒绝目标变量不依赖于预测变量的假设(F检验的p值很小)。检查某些系数的显著性，可能会质疑有些变量是否应该进入模型中。有多种方法可以用来精简回归模型。本节将介绍向后消元法。 首先用函数anova()来精简线性模型。当将anova()应用到简单线性模型时，这个函数提供一个模型拟合的方差序贯分析。也就是说，随着公式中项数的增加，模型的残差平方和减少。对前面的模型进行方差分析，结果如下： 1234567891011121314151617181920anova(lm.a1)Analysis of Variance TableResponse: a1 Df Sum Sq Mean Sq F value Pr(&gt;F) season 3 85 28.2 0.0905 0.9651944 size 2 11401 5700.7 18.3088 5.69e-08 ***speed 2 3934 1967.2 6.3179 0.0022244 ** mxPH 1 1329 1328.8 4.2677 0.0402613 * mnO2 1 2287 2286.8 7.3444 0.0073705 ** Cl 1 4304 4304.3 13.8239 0.0002671 ***NO3 1 3418 3418.5 10.9789 0.0011118 ** NH4 1 404 403.6 1.2963 0.2563847 oPO4 1 4788 4788.0 15.3774 0.0001246 ***PO4 1 1406 1405.6 4.5142 0.0349635 * Chla 1 377 377.0 1.2107 0.2726544 Residuals 182 56668 311.4 ---Signif. codes: 0 ?**?0.001 ?*?0.01 ??0.05 ??0.1 ??1 上面结果表明变量season对减少模型拟合误差的贡献度最小下面将它从模型中剔除： 1lm2.a1 = update(lm.a1, .~.-season) 函数update()用于对已有的线性模型进行微小的调整。在上面的代码中，应用函数update()从模型lm.a1中移除变量season以得到一个新的模型。新的模型的汇总信息如下： 12345678910111213141516171819202122232425262728293031summary(lm2.a1)Call:lm(formula = a1 ~ size + speed + mxPH + mnO2 + Cl + NO3 + NH4 + oPO4 + PO4 + Chla, data = clean.algae[, 1:12])Residuals: Min 1Q Median 3Q Max -36.460 -11.953 -3.044 7.444 63.730 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 44.9532874 23.2378377 1.934 0.05458 . sizemedium 3.3092102 3.7825221 0.875 0.38278 sizesmall 10.2730961 4.1223163 2.492 0.01358 * speedlow 3.0546270 4.6108069 0.662 0.50848 speedmedium -0.2976867 3.1818585 -0.094 0.92556 mxPH -3.2684281 2.6576592 -1.230 0.22033 mnO2 0.8011759 0.6589644 1.216 0.22561 Cl -0.0381881 0.0333791 -1.144 0.25407 NO3 -1.5334300 0.5476550 -2.800 0.00565 **NH4 0.0015777 0.0009951 1.586 0.11456 oPO4 -0.0062392 0.0395086 -0.158 0.87469 PO4 -0.0509543 0.0305189 -1.670 0.09669 . Chla -0.0841371 0.0794459 -1.059 0.29096 ---Signif. codes: 0 ?**?0.001 ?*?0.01 ??0.05 ??0.1 ??1Residual standard error: 17.57 on 185 degrees of freedomMultiple R-squared: 0.3682, Adjusted R-squared: 0.3272 F-statistic: 8.984 on 12 and 185 DF, p-value: 1.762e-13 新模型的拟合指标R^2提高到了32.8%，仍然不是太理想。下面使用anova()函数对两个模型进行正式的比较，但这次使用两个模型作为参数： 1234567891011anova(lm.a1, lm2.a1)Analysis of Variance TableModel 1: a1 ~ season + size + speed + mxPH + mnO2 + Cl + NO3 + NH4 + oPO4 + PO4 + ChlaModel 2: a1 ~ size + speed + mxPH + mnO2 + Cl + NO3 + NH4 + oPO4 + PO4 + Chla Res.Df RSS Df Sum of Sq F Pr(&gt;F)1 182 56668 2 185 57116 -3 -447.62 0.4792 0.6971 上面的函数通过F检验对两个模型进行方差分析，据此评估两个模型是否有显著不同。这种情况下，尽管误差平方和减少了(-448),但是比较结果说明两者的差距并不显著(显著性值0.6971说明两个模型不同的可能性有30%)。注意，新模型比较简单。为了检查能否移除更多的系数，我们再次讨论对lm2.a1模型使用anova()函数。不断重复这个过程知道没有可剔除的候选系数。为了简化向后消元过程，R有一个函数来执行上面所有过程。 下面的代码对初始模型(lm.a1)用向后消元方法得到一个新的线性模型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101final.lm = step(lm.a1)Start: AIC=1152.03a1 ~ season + size + speed + mxPH + mnO2 + Cl + NO3 + NH4 + oPO4 + PO4 + Chla Df Sum of Sq RSS AIC- season 3 447.62 57116 1147.6- speed 2 269.60 56938 1149.0- oPO4 1 5.78 56674 1150.0- Chla 1 376.96 57045 1151.3- Cl 1 443.46 57112 1151.6- mxPH 1 548.76 57217 1151.9&lt;none&gt; 56668 1152.0- mnO2 1 694.11 57363 1152.4- NH4 1 825.67 57494 1152.9- PO4 1 898.42 57567 1153.1- size 2 1857.16 58526 1154.4- NO3 1 2339.36 59008 1158.0Step: AIC=1147.59a1 ~ size + speed + mxPH + mnO2 + Cl + NO3 + NH4 + oPO4 + PO4 + Chla Df Sum of Sq RSS AIC- speed 2 210.64 57327 1144.3- oPO4 1 7.70 57124 1145.6- Chla 1 346.27 57462 1146.8- Cl 1 404.10 57520 1147.0- mnO2 1 456.37 57572 1147.2- mxPH 1 466.95 57583 1147.2&lt;none&gt; 57116 1147.6- NH4 1 776.11 57892 1148.3- PO4 1 860.62 57977 1148.5- size 2 2175.59 59292 1151.0- NO3 1 2420.47 59537 1153.8Step: AIC=1144.31a1 ~ size + mxPH + mnO2 + Cl + NO3 + NH4 + oPO4 + PO4 + Chla Df Sum of Sq RSS AIC- oPO4 1 16.29 57343 1142.4- Chla 1 223.29 57550 1143.1- mnO2 1 413.77 57740 1143.7- Cl 1 472.70 57799 1143.9- mxPH 1 483.56 57810 1144.0&lt;none&gt; 57327 1144.3- NH4 1 720.19 58047 1144.8- PO4 1 809.30 58136 1145.1- size 2 2060.95 59388 1147.3- NO3 1 2379.75 59706 1150.4Step: AIC=1142.37a1 ~ size + mxPH + mnO2 + Cl + NO3 + NH4 + PO4 + Chla Df Sum of Sq RSS AIC- Chla 1 207.7 57551 1141.1- mnO2 1 402.6 57746 1141.8- Cl 1 470.7 57814 1142.0- mxPH 1 519.7 57863 1142.2&lt;none&gt; 57343 1142.4- NH4 1 704.4 58047 1142.8- size 2 2050.3 59393 1145.3- NO3 1 2370.4 59713 1148.4- PO4 1 5818.4 63161 1159.5Step: AIC=1141.09a1 ~ size + mxPH + mnO2 + Cl + NO3 + NH4 + PO4 Df Sum of Sq RSS AIC- mnO2 1 435.3 57986 1140.6- Cl 1 438.1 57989 1140.6&lt;none&gt; 57551 1141.1- NH4 1 746.9 58298 1141.6- mxPH 1 833.1 58384 1141.9- size 2 2217.5 59768 1144.6- NO3 1 2667.1 60218 1148.1- PO4 1 6309.7 63860 1159.7Step: AIC=1140.58a1 ~ size + mxPH + Cl + NO3 + NH4 + PO4 Df Sum of Sq RSS AIC- NH4 1 531.0 58517 1140.4- Cl 1 584.9 58571 1140.6&lt;none&gt; 57986 1140.6- mxPH 1 819.1 58805 1141.4- size 2 2478.2 60464 1144.9- NO3 1 2251.4 60237 1146.1- PO4 1 9097.9 67084 1167.4Step: AIC=1140.38a1 ~ size + mxPH + Cl + NO3 + PO4 Df Sum of Sq RSS AIC&lt;none&gt; 58517 1140.4- mxPH 1 784.1 59301 1141.0- Cl 1 835.6 59353 1141.2- NO3 1 1987.9 60505 1145.0- size 2 2664.3 61181 1145.2- PO4 1 8575.8 67093 1165.5 函数step()使用Akaike信息标准进行模型搜索。默认情况下，搜索使用向后消元方法，但通过设置参数direction，可以采用其他的方法(参考该函数的帮助文档以获取更多信息)。 可以通过下面的代码来获得最后模型的信息： 12345678910111213141516171819202122232425summary(final.lm)Call:lm(formula = a1 ~ size + mxPH + Cl + NO3 + PO4, data = clean.algae[, 1:12])Residuals: Min 1Q Median 3Q Max -28.874 -12.732 -3.741 8.424 62.926 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 57.28555 20.96132 2.733 0.00687 ** sizemedium 2.80050 3.40190 0.823 0.41141 sizesmall 10.40636 3.82243 2.722 0.00708 ** mxPH -3.97076 2.48204 -1.600 0.11130 Cl -0.05227 0.03165 -1.651 0.10028 NO3 -0.89529 0.35148 -2.547 0.01165 * PO4 -0.05911 0.01117 -5.291 3.32e-07 ***---Signif. codes: 0 ?**?0.001 ?*?0.01 ??0.05 ??0.1 ??1Residual standard error: 17.5 on 191 degrees of freedomMultiple R-squared: 0.3527, Adjusted R-squared: 0.3324 F-statistic: 17.35 on 6 and 191 DF, p-value: 5.554e-16 这个模型所解释的方差比例(R^2)仍然不是很可观，这样的R^2表明对海藻案例应用假定的线性模型是不合适的。 回归树 本节给出R中的另一种回归模型。即本节描述了如何通过建立回归树来预测海藻a1出现的频率。由于这类模型能够处理缺失值，所以这里只需要如前面所述移除62号和199号水样。 建立回归树模型如下： 1234library(rpart)data(algae)algae = algae[-manyNAs(algae),]rt.a1 = rpart(a1~., data = algae[,1:12]) 对象rt.a1的内容如下： 12345678910111213141516171819202122232425rt.a1n= 198 node), split, n, deviance, yval * denotes terminal node 1) root 198 90401.290 16.996460 2) PO4&gt;=43.818 147 31279.120 8.979592 4) Cl&gt;=7.8065 140 21622.830 7.492857 8) oPO4&gt;=51.118 84 3441.149 3.846429 * 9) oPO4&lt; 51.118 56 15389.430 12.962500 18) mnO2&gt;=10.05 24 1248.673 6.716667 * 19) mnO2&lt; 10.05 32 12502.320 17.646880 38) NO3&gt;=3.1875 9 257.080 7.866667 * 39) NO3&lt; 3.1875 23 11047.500 21.473910 78) mnO2&lt; 8 13 2919.549 13.807690 * 79) mnO2&gt;=8 10 6370.704 31.440000 * 5) Cl&lt; 7.8065 7 3157.769 38.714290 * 3) PO4&lt; 43.818 51 22442.760 40.103920 6) mxPH&lt; 7.87 28 11452.770 33.450000 12) mxPH&gt;=7.045 18 5146.169 26.394440 * 13) mxPH&lt; 7.045 10 3797.645 46.150000 * 7) mxPH&gt;=7.87 23 8241.110 48.204350 14) PO4&gt;=15.177 12 3047.517 38.183330 * 15) PO4&lt; 15.177 11 2673.945 59.136360 * 回归树是对某些解释变量分层次的逻辑测试。基于树的模型自动筛选某些相关的变量，这样就会对树进行剪枝，减去某些变量。树从R标为1的根结点开始读，R在这个结点中提供相关的信息。即，可以再该结点中看到一共有198个水样（用于构建树的训练集数据样本量），在这198个水样中，海藻a1出现的平均频率为16.99，相对平均值的偏差为90401.29。树的每个结点有两个分支，这与预测变量的检验结果有关。例如，在根结点中有一个相应于测试“PO4&gt;&#x3D;43.818”为真（含有147个水样）的个案分支（R输出中标为2），同时也有另一个分支包含剩余的51个不满足这个测试的水样（R标记为3）。从结点2有两个分支分布连接到结点4和结点5，具体到哪个结点由对变量CI的检验来确定。不断进行以上的检验，直到达到某一个叶结点，这些叶结点在R中由星号标记出来。那么我们只要从根结点开始根据对该水样的检验结果，追踪某个分支，直到叶结点，我们就可以预测某个水样的频率。叶结点目标变量的平均值就是树的预测值。 我们也可以得到回归树的图形表示。可以用函数plot()和函数text()对树对象绘图即可。这两个函数有多个参数来控制树的可视化。为了方便地得到漂亮的树的可视化图形，本书的R添加包中提供了函数prettyTree()。对上面得到的树对象应用该函数，得到图形如图所示： 1prettyTree(rt.a1) 函数summary()也可以用于树对象。此函数将给出许多有关于树的测试信息、其他可能考虑的测试以及中间分割等。这里的中间分割是R回归树处理缺失值的一种方法。 通常分两步来建立回归树。最初，生成一棵较大的树，然后通过统计估计删除底部的一些结点来对树进行修剪。这个过程的目的是繁殖过度拟合。事实上，一个过度大的树一般会很好地对训练数据集数据进行拟合，但是它会拟合给定数据集中的一写虚假的关系，因此当把该模型用于新数据的预测时，预测性能很差。在许多建模技术中存在过度拟合问题，尤其是当需要逼近的函数的假设条件不是很严格的时候。对于要求不严格的模型，虽然它们的要求不高，有广泛的应用范围，但却存在过度拟合问题，所以它需要一个事后统计估计步骤来避免过度拟合问题。 上面使用rpart()函数构建树，在构建树的过程中，当给定条件满足时构建过程就停止。当下列条件满足时，树就构建结束： 偏差的减少小于某一个给定的界限值时； 当结点中的样本数量小于某个给定界限值时； 当树的深度大于一个给定的界限值。 上面3个界限值分别由rpart()函数的三个参数（cp, minsplit, maxdepth）来确定。它们的默认值分别为0.01、20和30。如果要避免树的过度拟合问题，就要经常检查这些默认值的有效性。这可以通过对得到的树采取事后修剪过程来进行。 rpart()添加包实现了一种称为“复杂度损失修剪”的修剪方法（Breiman et al., 1984）。这个方法使用R在每个树结点计算的参数值cp。这种修剪方法试图估计cp值以确保达到预测的准确性和树的大小之间的最佳折中。给出一个由函数rpart()建立的回归树，R可以生成这棵树的一些子树，并估计这些树的性能。这些信息可以通过函数printcp()得到： 12345678910111213141516171819202122printcp(rt.a1)Regression tree:rpart(formula = a1 ~ ., data = algae[, 1:12])Variables actually used in tree construction:[1] Cl mnO2 mxPH NO3 oPO4 PO4 Root node error: 90401/198 = 456.57n= 198 CP nsplit rel error xerror xstd1 0.405740 0 1.00000 1.00909 0.130282 0.071885 1 0.59426 0.72655 0.119383 0.030887 2 0.52237 0.67966 0.114874 0.030408 3 0.49149 0.70176 0.117815 0.027872 4 0.46108 0.69623 0.116286 0.027754 5 0.43321 0.69623 0.116287 0.018124 6 0.40545 0.67679 0.110528 0.016344 7 0.38733 0.70123 0.114159 0.010000 9 0.35464 0.71140 0.11389 由rpart()函数建立的回归树是上面列表中的最后一个树（树9）。这个树的cp值为0.01（参数cp的默认值），该树包括九个测试和一个相对误差值（与根结点相比）0.354。然而，R应用10折交叉验证的内部过程，评估该树的平均相对误差为0.70241 ± 0.11523。根据这些更稳健的性能估计信息，可以避免过度拟合问题。可以看到，8号树的预测相对误差（0.67733）最小。另一个选择标准时根据1-SE规则来选择最好的回归树，这包括检查交叉验证的估计误差（“xerror”列），以及标准误差（“xstd”列）。在这个案例中，1-SE规则树是最小的树，误差小于0.67733 + 0.10892 &#x3D; 0.78625，而由1检验的2号树的估计误差为0.73358。如果我们选择这个树而不是R建议的树，我们就可以通过使用不同的cp值来建立这棵树。 1234567891011rt2.a1 &lt;- prune(rt.a1, cp = 0.08)rt2.a1n= 198 node), split, n, deviance, yval * denotes terminal node1) root 198 90401.29 16.996460 2) PO4&gt;=43.818 147 31279.12 8.979592 * 3) PO4&lt; 43.818 51 22442.76 40.103920 * 本书添加包中的rpartXse()函数可以自动运行这个过程，它的参数se的默认值为1. 123456789101112(rt.a1 &lt;- rpartXse(a1~., data=algae[,1:12]))n= 198 node), split, n, deviance, yval * denotes terminal node1) root 198 90401.290 16.996460 2) PO4&gt;=43.818 147 31279.120 8.979592 4) Cl&gt;=7.1665 142 21763.160 7.530282 * 5) Cl&lt; 7.1665 5 746.792 50.140000 * 3) PO4&lt; 43.818 51 22442.760 40.103920 * 可以应用R的函数snip.rpart()来交互地对树进行修剪。这个函数可以通过两种方式生成一个修剪过的回归树。第一种方法是指出需要修剪那个地方的结点号（可以通过输出树对象来得到树的结点号）： 1234567891011121314151617first.tree &lt;- rpart(a1~., data =algae[,1:12])snip.rpart(first.tree, c(4,7))n= 198 node), split, n, deviance, yval * denotes terminal node 1) root 198 90401.290 16.996460 2) PO4&gt;=43.818 147 31279.120 8.979592 4) Cl&gt;=7.8065 140 21622.830 7.492857 * 5) Cl&lt; 7.8065 7 3157.769 38.714290 * 3) PO4&lt; 43.818 51 22442.760 40.103920 6) mxPH&lt; 7.87 28 11452.770 33.450000 12) mxPH&gt;=7.045 18 5146.169 26.394440 * 13) mxPH&lt; 7.045 10 3797.645 46.150000 * 7) mxPH&gt;=7.87 23 8241.110 48.204350 * 这个函数与rpart()函数一样返回一个数对象，所以可以用形如my.tree &lt;- snip.rpart(first.tree, c(4,7))这样的代码来保存这个修剪过的树。 另外，也可以再图形窗口下使用snip.rpart()函数。首先，画出回归树，然后调用没有第二个参数的函数。如果点击回归树的某些结点，R会在控制台输出这些结点的信息。如果继续点击这个结点，R就在这个结点对树进行修剪。可以在图形窗口继续修剪回归树，直到右击结束这一交互式的修剪过程。调用该函数的结果仍然是一个数对象： 123456789101112131415161718192021222324252627282930313233prettyTree(first.tree)snip.rpart(first.tree)node number: 2 n= 147 response= 8.979592 Error (dev) = 31279.12 node number: 6 n= 28 response= 33.45 Error (dev) = 11452.77 n= 198 node), split, n, deviance, yval * denotes terminal node 1) root 198 90401.290 16.996460 2) PO4&gt;=43.818 147 31279.120 8.979592 4) Cl&gt;=7.8065 140 21622.830 7.492857 8) oPO4&gt;=51.118 84 3441.149 3.846429 * 9) oPO4&lt; 51.118 56 15389.430 12.962500 18) mnO2&gt;=10.05 24 1248.673 6.716667 * 19) mnO2&lt; 10.05 32 12502.320 17.646880 38) NO3&gt;=3.1875 9 257.080 7.866667 * 39) NO3&lt; 3.1875 23 11047.500 21.473910 78) mnO2&lt; 8 13 2919.549 13.807690 * 79) mnO2&gt;=8 10 6370.704 31.440000 * 5) Cl&lt; 7.8065 7 3157.769 38.714290 * 3) PO4&lt; 43.818 51 22442.760 40.103920 6) mxPH&lt; 7.87 28 11452.770 33.450000 12) mxPH&gt;=7.045 18 5146.169 26.394440 * 13) mxPH&lt; 7.045 10 3797.645 46.150000 * 7) mxPH&gt;=7.87 23 8241.110 48.204350 14) PO4&gt;=15.177 12 3047.517 38.183330 * 15) PO4&lt; 15.177 11 2673.945 59.136360 * 在上例中，点击并修剪了节点2和结点6. 后记 这一节我们建立了模型，用了2种方法，分别是多元回归和回归树。那么下一节就要对我们建立的模型进行评价了。","categories":[{"name":"技能-修行-进步-R语言","slug":"技能-修行-进步-R语言","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-R%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"数据挖掘与R语言-案例学习","slug":"数据挖掘与R语言-案例学习","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8ER%E8%AF%AD%E8%A8%80-%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/"}]},{"title":"DMwR-note-01-预测海藻数量(四)","slug":"技能-修行-进步-R语言/DMwR-note-01-预测海藻数量(四)","date":"2014-10-27T23:39:16.000Z","updated":"2023-07-22T01:34:24.294Z","comments":true,"path":"2014/10/28/技能-修行-进步-R语言/DMwR-note-01-预测海藻数量(四)/","link":"","permalink":"http://example.com/2014/10/28/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-R%E8%AF%AD%E8%A8%80/DMwR-note-01-%E9%A2%84%E6%B5%8B%E6%B5%B7%E8%97%BB%E6%95%B0%E9%87%8F(%E5%9B%9B)/","excerpt":"","text":"写在开头的话 Ok，上一节我们利用多元回归和回归树两种方法建立了数据模型，那么数据模型可不可靠呢？这一节的任务就是对模型进行评估。 模型的评价和选择 上一节给出了本案例的两个预测模型的例子。最明显的问题是，应该使用哪一个模型来获得7种海藻的140个测试样品的预测。为了回答这个问题，需要在可供选择的模型空间中指定一些模型的偏好标准，也就是说，需要详细说明应该如何评价模型的性能。 有多种评价(和比较)模型的标准。其中最流行的标准是计算模型的预测性能。当然还有其他衡量的标准，例如模型的可解释性，还有对大型数据挖掘特别重要的标准，即模型的计算效率。 预测函数predict() 回归模型的预测性能是通过将目标变量的预测值与实际值进行比较得到的，并从这些比较中计算某些平均误差的度量。一种度量方法是平均绝对误差(MAE)。下面描述如何获得线性回归和回归树的平均绝对误差。第一步，获取需要评价模型预测性能的测试集个案的预测值。在R中，要获得任何模型的预测，就要使用函数predict()进行预测。函数predict()是一个泛型函数，它的一个参数为需要应用的模型，另一个参数为数据的测试集，输出结果为相应的模型预测值：12lm.predictions.a1 &lt;- predict(final.lm, clean.algae)rt.predictions.a1 &lt;- predict(rt.a1, algae) 上面连个命令得到预测海藻a1的两个模型的预测值。注意，因为原始训练集数据含有缺失值，所以在线性回归模型中使用的是数据框clean.algae。 平均绝对误差(MAE) 得到模型的预测值后，就可以计算出其平均绝对误差：123456# 计算平均绝对误差(mae.a1.lm &lt;- mean(abs(lm.predictions.a1 - algae[,&quot;a1&quot;])))[1] 13.10681(mae.a1.rt &lt;- mean(abs(rt.predictions.a1 - algae[,&quot;a1&quot;])))[1] 10.36242 均方误差(MSE) 另一种流行的误差度量是均方误差(MSE)。可以由下列代码计算均方误差：123456# 计算均方误差(MSE)(mse.a1.lm &lt;- mean((lm.predictions.a1 - algae[,&quot;a1&quot;])^2))[1] 295.5407(mse.a1.rt &lt;- mean((rt.predictions.a1 - algae[,&quot;a1&quot;])^2))[1] 227.0339 标准化的平均绝对误差(NMSE) 以上后一种误差度量方法的不足之处是：误差值和目标值变量的目标不统一，因此从用户的角度看，这种误差不好解释。即使应用平均绝对误差(MAE)来度量误差，问题是如何判断模型的得分是好还是差。能够解决这一问题的误差度量是标准化后的平均绝对误差(NMSE)。这一统计量是计算模型预测性能和基准模型的预测性能之间的比率。通常采用目标变量的平均值来作为基准模型，代码如下：123456# 计算标准化后的平均绝对误差(NMSE)(nmse.a1.lm &lt;- mean((lm.predictions.a1 - algae[,&#x27;a1&#x27;])^2 / mean((mean(algae[,&#x27;a1&#x27;])-algae[,&#x27;a1&#x27;])^2)))[1] 0.6473034(nmse.a1.rt &lt;- mean(rt.predictions.a1-algae[,&#x27;a1&#x27;])^2 / mean((mean(algae[,&#x27;a1&#x27;])-algae[,&#x27;a1&#x27;])^2))[1] 3.121937e-34 NMSE是一个比值，其取值范围通常为0-1。如果模型表现优于这个非常简单基准模型预测，那么NMSE应明显小于1。NMSE的值越小，模型的性能就越好。NMSE的值大于1，意味着模型预测还不如简单地把所有个案的平均值作为预测值。 在本书提供的R添加包中，函数regr.eval()用来计算线性回归模型的性能度量指标。下面给出应用该函数一个例子。可以查找该函数的帮助文档来获取这个函数的不同用法。123regr.eval(algae[,&#x27;a1&#x27;], rt.predictions.a1, train.y = algae[,&#x27;a1&#x27;]) mae mse rmse mape nmse nmae 10.3624227 227.0338940 15.0676439 Inf 0.4972574 0.6202654 可视化比较模型 可视化地查看模型的预测值将更加有趣。一种方法是绘制误差的散点图。代码如下：1234567# 可视化查看模型的预测值old.par &lt;- par(mfrow = c(1,2))plot(lm.predictions.a1, algae[,&#x27;a1&#x27;], main=&quot;Linear Model&quot;, xlab=&quot;Predictions&quot;, ylab=&quot;True Values&quot;)abline(0,1,lty=2)plot(rt.predictions.a1, algae[,&#x27;a1&#x27;], main=&quot;Regression Tree&quot;, xlab=&quot;Predictions&quot;, ylab=&quot;True Values&quot;)abline(0,1,lty=2)par(old.par) plot: 由上图可以看出，这两个模型在许多个案上的性能比较差。在理想的情况下，模型对所有的个案做出正确的预测时，图中的所有圈应该在虚线上，这条虚线是通过函数abline(0,1,lty&#x3D;2)来绘制的。这条虚线穿过坐标系的原点，代表x坐标和y坐标相等的点集。图中圆圈的x坐标和y坐标分别代表目标变量的预测值和真实值，如果他们相等，那么这些圆圈就会落在这条理想的直线上。但从上图可以看到，情况并非如此！可以用函数identify()来检查哪些预测特别差的样本点，该函数可以让用户通过互动方式点击图形中的点，代码如下：1234# identify()plot(lm.predictions.a1, algae[,&#x27;a1&#x27;],main=&quot;Linear Model&quot;, xlab=&quot;Predictions&quot;, ylab=&quot;True Values&quot;)abline(0,1,lty=2)algae[identify(lm.predictions.a1, algae[,&#x27;a1&#x27;]),] 运行上面的代码，并在图形上点击，然后右击结束交互过程后，应该看到相应于所点击的圆圈的海藻数据框的行数据–因为这里用函数identify()得到的向量来索引海藻数据框。 观察上图的左图，他对应的是线性回归模型。注意，有一些个案的海藻频率的预测值为负值。在本案例中，海藻在出现频率为负值时没有意义(至少是0个)。因此，可以用以上知识和海藻频率的最小可能取值来优化上面的线性回归模型。1234567sensible.lm.predictions.a1 &lt;- ifelse(lm.predictions.a1 &lt;0,0,lm.predictions.a1)regr.eval(algae[,&#x27;a1&#x27;], lm.predictions.a1,stats = c(&quot;mae&quot;,&quot;mse&quot;)) mae mse 13.10681 295.54069 regr.eval(algae[,&#x27;a1&#x27;], sensible.lm.predictions.a1, stats = c(&quot;mae&quot;,&quot;mse&quot;)) mae mse 12.48276 286.28541 上面代码应用函数ifelse()来改进模型的预测结果。该函数有三个参数，第一个参数是逻辑条件，第二个参数是当逻辑条件为真时函数的取值，第三个参数是当逻辑条件为假时的取值。注意，通过这一小的细节就提高了模型的性能。 k折交叉验证 根据以上计算出的模型的性能指标，我们倾向于选择回归树模型来预测140个测试样品的频率值，因为该模型有较低的NMSE值。然而，这种推理有一种那个缺陷。我们的分析目标是获得能够对140个测试样品的频率进行预测的最佳模型。由于不知道这些测试样本的目标变量值，所以我们需要估计哪一个模型将在这些测试样本上有较好的性能。这里的关键问题是在不知道数据集真实的目标变量取值时，要获得模型在该数据集上可靠的性能估计。使用已有的训练数据获得模型的性能指标(如前面获得模型的过程)是不可靠的，因为这些计算是有偏的。 实际上，有的模型可以很容易地获得训练数据的零误差预测。然而，模型的这一优秀性能很难推广到目标变量值未知的心样本上。正如之前所述，这种现象通常称为过拟合训练数据。因为，为了选择一个合适的模型，我们需要获得模型在未知数据上预测性能的更加可靠的估计。k折交叉验证是获得模型性能可靠估计的一种常用方法，它适用于像本案例这样的小数据集。这种方法可以简要介绍如下。 首先获取k个同样大小的随机训练数据子集。 对于这k个子集的每一个子集，用除去它之外的其余k-1个子集建立模型，然后用第k个子集来评估这个模型，最后存储模型的性能指标 对其余的每个子集重复以上过程，最后有K个性能指标的测量值，这些性能指标是通过在没有用于建模的数据上计算得到，这也是关键之处。 k折交叉验证估计是这k个性能指标的平均。常见的k&#x3D;10.有时我们会重复进行多次k折交叉验证以获得更加可靠的估计。 总之，党对一项预测任务时，需要作出以下决策： 为预测任务选择模型(同一算法的不同参数设定也可以认为是不同的模型)。 选择比较模型性能的评估指标 选择获取评估指标的可靠估计的实验方法。 在本书提供的R包中，提供了函数experimentalComparison()，它用来进行模型的选择和比较任务。它可以和不同的估计方法一起使用，如交叉验证法。这个函数有三个参数：1.用于比较的数据集，2.需要比较的可选模型，3.实验过程中的系数。我们以海藻数据集为例，用它来比较线性回归模型和几个不同回归树模型。 函数experimentalComparison()使用于任何模型和任何数据，在这个意义上，它是一个泛型函数。使用者提供一组实现待比较的模型的函数。其中每一个函数应该对训练集和测试集实现一个完整的“训练+测试+评估”周期。在评估过程的每一次迭代中，调用这些函数。这些函数应该返回一个向量，其元素为交叉验证中用户需要的性能评估指标值。下面给出两个目标模型的函数： 1234567891011121314cv.rpart &lt;- function(form,train,test,...)&#123; m &lt;- rpartXse(from,train,...) p &lt;- predict(m,test) mse &lt;- mean((p-resp(form,test))^2) c(nmse = mse/mean((mean(resp(form,train))-resp(form,test))^2))&#125;cv.lm &lt;- function(form, train, test,...)&#123; m &lt;- lm(form,train,...) p &lt;- predict(m,test) p &lt;- ifelse(p&lt;0,0,p) mse &lt;- mean((p-resp(form,test))^2) c(nmse=mse/mean((mean(resp(form,train))-resp(form,test))^2))&#125; 在这个示例中，假设用NMSE作为线性回归模型和回归树模型的性能评估指标。所有这些用户定义的函数的前三个参数应该是公式、训练数据和测试数据。实验过程调用函数时可以应用的其他参数包括要评估模型所需要的参数。虽然所评估的两个模型应用了完全不同的学习算法，但是两个模型函数都有同样的“训练+测试+评估”周期。函数的定义还包括一个特殊参数“…”。这个特殊参数可以用在任意的R函数中，它允许一个特定函数具有可变的参数。这个结构用于给实际模型传递所需要的额外参数(例如在函数rpartXse()中和函数lm()中)。这些函数的另一个特殊之处是应用本书添加包提供的函数resp()，它用于根据公式获得数据集的目标变量值。 在定义好用于模型学习和测试的函数后，就可以按下列代码进行模型的交叉验证比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354res &lt;- experimentalComparison( c(dataset(a1~.,clean.algae[,1:12],&quot;a1&quot;)), c(variants(&#x27;cv.lm&#x27;), variants(&#x27;cv.rpart&#x27;,se=c(0,0.5,1))), cvSettings(3,10,1234) )##### CROSS VALIDATION EXPERIMENTAL COMPARISON #####** DATASET :: a1++ LEARNER :: cv.lm variant -&gt; cv.lm.v1 3 x 10 - Fold Cross Validation run with seed = 1234 Repetition 1 Fold: 1 2 3 4 5 6 7 8 9 10Repetition 2 Fold: 1 2 3 4 5 6 7 8 9 10Repetition 3 Fold: 1 2 3 4 5 6 7 8 9 10++ LEARNER :: cv.rpart variant -&gt; cv.rpart.v1 3 x 10 - Fold Cross Validation run with seed = 1234 Repetition 1 Fold: 1 2 3 4 5 6 7 8 9 10Repetition 2 Fold: 1 2 3 4 5 6 7 8 9 10Repetition 3 Fold: 1 2 3 4 5 6 7 8 9 10++ LEARNER :: cv.rpart variant -&gt; cv.rpart.v2 3 x 10 - Fold Cross Validation run with seed = 1234 Repetition 1 Fold: 1 2 3 4 5 6 7 8 9 10Repetition 2 Fold: 1 2 3 4 5 6 7 8 9 10Repetition 3 Fold: 1 2 3 4 5 6 7 8 9 10++ LEARNER :: cv.rpart variant -&gt; cv.rpart.v3 3 x 10 - Fold Cross Validation run with seed = 1234 Repetition 1 Fold: 1 2 3 4 5 6 7 8 9 10Repetition 2 Fold: 1 2 3 4 5 6 7 8 9 10Repetition 3 Fold: 1 2 3 4 5 6 7 8 9 10 像先前提到的那样，第一个参数是含有在实验比较中所应用数据集的一个向量。每个数据集的声明形式为dataset(,,)。函数experimentalComparison()的第二个参数包含要研究的可选的模型方法。每个模型方法通过函数variant()来指定，该函数的第一个参数是用户定义的用于“学习+测试+评估”周期的函数名称。其余的可选参数用来给出估计方法的其他参数的可选值。函数variantes()根据所有参数值的组合生成一组可选模型。在上面的例子代码中，模型“cv.lm”采用了默认参数值，而模型“cv.rpart”的参数se则给出了不同的取值。这意味着实验将包含回归树的三个版本，这点可以在上面的函数输出中得到确认。函数experimentalComparison()的第三个参数是设定交叉验证实验的参数，即k折交叉验证实验过程重复的次数(这里设为3)、k的取值(10)、随机数生成器的种子。最后的参数(随机数种子)设定可以保证在必要的情况之下可以重视我们的实验(例如更换了训练模型系统)。 这个代码调用的结果是一个复杂的对象，它包含实验比较的所有信息。在本书的R添加包中提供了多种获取这些信息的函数。例如，下面代码提供了比较结果的概要： 123456789101112131415161718192021222324252627282930313233343536373839404142434445summary(res)== Summary of a Cross Validation Experiment == 3 x 10 - Fold Cross Validation run with seed = 1234 * Data sets :: a1* Learners :: cv.lm.v1, cv.rpart.v1, cv.rpart.v2, cv.rpart.v3* Summary of Experiment Results:-&gt; Datataset: a1 *Learner: cv.lm.v1 nmseavg 0.7196105std 0.1833064min 0.4678248max 1.2218455invalid 0.0000000 *Learner: cv.rpart.v1 nmseavg 0.6440843std 0.2521952min 0.2146359max 1.1712674invalid 0.0000000 *Learner: cv.rpart.v2 nmseavg 0.6873747std 0.2669942min 0.2146359max 1.3356744invalid 0.0000000 *Learner: cv.rpart.v3 nmseavg 0.7167122std 0.2579089min 0.3476446max 1.3356744invalid 0.0000000 从结果中可知，其中的一个回归树有最优的NMSE值。这个NMSE值是否明显优于其他模型，目前还不明显，本节的后面将回到这个问题。可以得到这些结果的可视化图形: 1plot(res) plot:","categories":[{"name":"技能-修行-进步-R语言","slug":"技能-修行-进步-R语言","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-R%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"数据挖掘与R语言-案例学习","slug":"数据挖掘与R语言-案例学习","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8ER%E8%AF%AD%E8%A8%80-%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/"}]},{"title":"DMwR-note-01-预测海藻数量(二)","slug":"技能-修行-进步-R语言/DMwR-note-01-预测海藻数量(二)","date":"2014-10-26T12:12:23.000Z","updated":"2023-07-22T01:34:20.040Z","comments":true,"path":"2014/10/26/技能-修行-进步-R语言/DMwR-note-01-预测海藻数量(二)/","link":"","permalink":"http://example.com/2014/10/26/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-R%E8%AF%AD%E8%A8%80/DMwR-note-01-%E9%A2%84%E6%B5%8B%E6%B5%B7%E8%97%BB%E6%95%B0%E9%87%8F(%E4%BA%8C)/","excerpt":"","text":"写在开头的话 上次的笔记讲了数据的读取，窥探和可视化，这次我们来分析一下数据当中的缺失值。对于缺失值的正确处理也是数据分析当中很重要的一步。 数据缺失 数据缺失是一种非常普遍的情形，但是有些数据分析的方法无法对缺失值进行处理，这样就会带来问题。 当我们处理含有缺失值的数据时，可以运用一下几种最常见的策略： 将含有缺失值的案例剔除 根据变量之间的相关关系填补缺失值 根据案例之间的相似性填补缺失值 使用能够处理缺失值数据的工具 在开始之前，我们先在Rstudio中载入包和数据 12library(DMwR)data(algae) 将缺失部分剔除 剔除缺失值的操作非常容易实现，特别当缺失值在数据当中所占的比例比较小的时候，这个选择比较合理。 在剔除缺失值之前，我们勿急，最好先检查观测值，或者至少得到这些观测值的个数， 1234567891011121314151617181920212223242526272829303132333435363738algae[!complete.cases(algae),] season size speed mxPH mnO2 Cl NO3 NH4 oPO4 PO4 Chla a128 autumn small high 6.80 11.1 9.000 0.630 20 4.000 NA 2.70 30.338 spring small high 8.00 NA 1.450 0.810 10 2.500 3.000 0.30 75.848 winter small low NA 12.6 9.000 0.230 10 5.000 6.000 1.10 35.555 winter small high 6.60 10.8 NA 3.245 10 1.000 6.500 NA 24.356 spring small medium 5.60 11.8 NA 2.220 5 1.000 1.000 NA 82.757 autumn small medium 5.70 10.8 NA 2.550 10 1.000 4.000 NA 16.858 spring small high 6.60 9.5 NA 1.320 20 1.000 6.000 NA 46.859 summer small high 6.60 10.8 NA 2.640 10 2.000 11.000 NA 46.960 autumn small medium 6.60 11.3 NA 4.170 10 1.000 6.000 NA 47.161 spring small medium 6.50 10.4 NA 5.970 10 2.000 14.000 NA 66.962 summer small medium 6.40 NA NA NA NA NA 14.000 NA 19.463 autumn small high 7.83 11.7 4.083 1.328 18 3.333 6.667 NA 14.4116 winter medium high 9.70 10.8 0.222 0.406 10 22.444 10.111 NA 41.0161 spring large low 9.00 5.8 NA 0.900 142 102.000 186.000 68.05 1.7184 winter large high 8.00 10.9 9.055 0.825 40 21.083 56.091 NA 16.8199 winter large medium 8.00 7.6 NA NA NA NA NA NA 0.0 a2 a3 a4 a5 a6 a728 1.9 0.0 0.0 2.1 1.4 2.138 0.0 0.0 0.0 0.0 0.0 0.048 0.0 0.0 0.0 0.0 0.0 0.055 0.0 0.0 0.0 0.0 0.0 0.056 0.0 0.0 0.0 0.0 0.0 0.057 4.6 3.9 11.5 0.0 0.0 0.058 0.0 0.0 28.8 0.0 0.0 0.059 0.0 0.0 13.4 0.0 0.0 0.060 0.0 0.0 0.0 0.0 1.2 0.061 0.0 0.0 0.0 0.0 0.0 0.062 0.0 0.0 2.0 0.0 3.9 1.763 0.0 0.0 0.0 0.0 0.0 0.0116 1.5 0.0 0.0 0.0 0.0 0.0161 20.6 1.5 2.2 0.0 0.0 0.0184 19.6 4.0 0.0 0.0 0.0 0.0199 12.5 3.7 1.0 0.0 0.0 4.9nrow(algae[!complete.cases(algae),])[1] 16 函数complete.cases()产生一个布尔值向量，该向量的元素个数与algae数据框中的行数相同，如果数据框的相应行中不含NA值(即为一个完整的观测值)，函数返回值就是TRUE。“！”逻辑非，因此上述指令显示了含有缺失值的水样记录。 为了从数据框中剔除这16个样本，我们可以这样简单的输入： 1algae1 &lt;- na.omit(algae) 这样我们就剔除了源数据中的所有含有缺失值的记录。但同时问题也浮出来了：数据分析的前提是有效数据越多越好。若果数据中含有缺失值的记录比例不低，那么这种做法会导致剩余数据的分析结果出现很大的偏差；或者另外一种情况，虽然缺失值的记录比例低，但是缺失值记录当中有很多是只是含有一个缺失值的，这样的剔除有点浪费数据，所以，下面我们利用函数找到缺失值记录当中含有缺失值最多的来进行剔除。 例如，观察样本中的数据，我们可以看到第62条和第199条记录中的11个解释变量中有6个是缺失值。我们就来剔除它们。 1algae2 &lt;- algae[-c(62,199),] 更进一步的，如果数据量大，单凭肉眼观察是不合理的，所以我们需要找出缺失值较多的记录的下标。下面的代码可以找出海藻数据集中每行数据的缺失值个数： 12345678algae3 &lt;- apply(algae, 1, function(x) sum(is.na(x)))algae3 [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 [37] 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 2 2 2 2 2 2 6 1 0 0 0 0 0 0 0 0 0 [73] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0[109] 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0[145] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0[181] 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 函数apply()属于R中功能非常强大的一类函数。这类函数又称为元函数，它们可以在某些条件下对对象应用其他函数。对函数apply()而言，它可以把任何其他函数应用到一个多维对象的各个维度上。使用函数apply()时，它把一个函数应用到数据框的每一行。这个被应用的函数在apply()函数的第三个参数给出，对数据框的每一个行都分别调用该函数。 在这个案例中我们使用一个临时函数。它只在调用apply()函数时才存在。另外，函数apply()的第三个也可以是一个“正常”函数的函数名。临时函数的功能室计算对象x中NA的数量。在R中逻辑值TRUE等于数值1，逻辑值FALSE等于0，这意味着当加一个布尔值向量时，得到向量中取值为TRUE的元素的个数。 根据以上代码，可以编写一个程序找出algae中含有给定数目缺失值的行。在本书提供的添加包中有这个函数。 12manyNAs(algae, 0.2)[1] 62 199 函数manyNAs()的功能是找出缺失值个数大于20%的行。在第二个参数中可以设置一个精确的列数作为界限。因此，用下面的代码就无须知道含有缺失值较多的行的具体数量： 12algae4 &lt;- algae[-manyNAs(algae),] manyNAs()函数的第二个参数的默认值是0.2。 用最高频率值来填补缺失值 填补含有缺失值的记录的另一个方法就是尝试找到这些缺失值最可能的值。同样的，这里有多种策略可供选择，不同策略对逼近程度和算法复杂度的权衡不同。 填补缺失数据最简单和快捷的方法是使用一些代表中心趋势的值。代表中心趋势的值反映了变量分布的最常见值，因此中心趋势值是最自然的选择。有多个代表数据中心趋势的指标，例如，平均值、中位数、众数等。最合适的选择由变量的分布决定。对于接近正态分布来说，所有的观测值都较好地集中在平均值周围，平均值就是最佳的选择。然而，对于偏态分布，或者有离群值的变量来说，选择平均值不好。偏态分布的大部分值都聚集在变量分布的一侧，因此平均值不能作为最常见值的代表。另一方面，离群值(极值)的存在会扭曲平均值，这就导致了平均值不具有代表性的问题。因此，在对变量分布进行检查之前选择平均值作为中心趋势的代表是不明智的例如，某些R的绘图工具。对偏态分布或者有离群值的分布而言，中位数是更好的代表数据中心趋势的指标。 比如，样本algae[48,]中的变量mxPH有缺失值。由于该变量分布近似正态分布，见DMwR-note-01-预测海藻数量(一)，我们可以选用平均值来填补这个“洞”，计算方法如下： 123temp &lt;- algaetemp[48,&quot;mxPH&quot;] &lt;- mean(algae$mxPH, na.rm=T) 这里，函数mean()计算数值向量的平均值，参数na.rm&#x3D;T使计算时忽略缺失数据。 大多数时候采用一次填补一列中的所有缺失值而不是像上面那样一行一行地逐个填补。以变量Chla为例，这个变量在第12行上有缺失值。另外，这也是平均值不能代表大多数变量值的一种情况。事实上，Chla的分布偏向较低的数值，并且它有几个极端值，这些都使得平均值不能代表大多数的变量值。因此，我们使用中位数来填补这一类的缺失值： 123temp &lt;- algaetemp[is.na(algae$Chla), &quot;Chla&quot;] &lt;- median(algae$Chla, na.rm=T) 本书插件包中提供的函数centralInputation()可以用数据的中心趋势值来填补数据集的所有缺失值。岁数值型变量，该函数用中位数；对名义变量，它采用众数。该函数的应用如下： 1234temp &lt;- algaetemp &lt;- temp[-manyNAs(algae),]temp &lt;- centralInputation(temp) 使用无偏方法来寻找最佳数据填补值复杂，对于大型数据挖掘问题可能并不适用。 通过变量的相关关系来填补缺失值 另一种获取缺失值较少偏差估计值的方法是探寻变量之间的相关关系。比如，听过变量值之间的相关关系，能够发现某变量与mxPH高度相关。这可以使我们得到含有缺失值的第48条样本更可能的填补值。这比之前使用平均值的方法将更胜一筹。 应用如下命令来得到变量间的相关值： 123temp &lt;- algaecor(temp[, 4:18], use = &quot;complete.obs&quot;) 函数cor()的功能室产生变量之间的相关值矩阵(因为前3个变量时名义变量，所以计算相关值时不考虑它们)。设定参数use &#x3D; “complete.obs”时，R在计算相关值时忽略含有NA的记录。相关值在1（或-1）周围表示相应的两个变量之间的强正（或负）线性相关关系。然后其他R函数可以得到变量间相关的近似函数形式，它可以让我们通过一个变量的值计算出另一个变量的值 函数cor()的输出结果并不是很清晰，但可以通过symnum()来改善结果的输出形式，例如： 1234567891011121314151617181920temp &lt;- algaesymnum(cor(temp[, 4:18], use = &quot;complete.obs&quot;)) mP mO Cl NO NH o P Ch a1 a2 a3 a4 a5 a6 a7mxPH 1 mnO2 1 Cl 1 NO3 1 NH4 , 1 oPO4 . . 1 PO4 . . * 1 Chla . 1 a1 . . . 1 a2 . . 1 a3 1 a4 . . . 1 a5 1 a6 . . . 1 a7 1 attr(,&quot;legend&quot;)[1] 0 &#x27; &#x27; 0.3 &#x27;.&#x27; 0.6 &#x27;,&#x27; 0.8 &#x27;+&#x27; 0.9 &#x27;*&#x27; 0.95 &#x27;B&#x27; 1 这种用符号表示相关值的方法更为清晰，特别是对于大的相关矩阵。 在本案例中，大多数变量之间是不相关的。然而，有2个例外：变量NH4和NO3之间，变量PO4和oPO4之间。后两者之间的相关值很高（大于0.9）。变量NH4和NO3之间的相关性不是特别明显（为0.72），因此根据他们来确定缺失数据是很危险的。此外，因为样本62和样本199有太多的变量含有缺失值，所以如果剔除它们，样本中的变量NH4和NO3就没有缺失值了。至于变量PO4和oPO4，它们之间相关性可以帮助填补这两个变量的缺失值。为了达到这个目标，我们需要找到这两个变量之间的线性关系，方法如下： 12345678910temp &lt;- algaetemp &lt;- temp[-manyNAs(temp),]lm(PO4 ~ oPO4, data = temp)Call:lm(formula = PO4 ~ oPO4, data = temp)Coefficients:(Intercept) oPO4 42.897 1.293 函数lm()可以用来获取形如Y&#x3D;β0+β1χ1+…+βnχn的线性模型。上述结果得到的线性模型是：PO4 &#x3D; 42.897 + 1.293 * oPO4。如果这两个变量不是同是有缺失值，那么通过这个模型计算这些变量的缺失值。 在剔除样本62和样本199后，还剩下一个样本（样本28）在变量PO4上有缺失值，可以简单地使用上面的线性关系计算缺失值的填补值： 12temp &lt;- algaetemp[28, &quot;PO4&quot;] &lt;- 42.897 + 1.293 * temp[28, &quot;oPO4&quot;] 然而，为了说明这个方法，我们假设变量PO4有很多个缺失值。如何使用上述的线性关系计算所有的缺失值呢？最好的方法就是构造一个函数，它可以根据给定的oPO4的值就是PO4的值，然后对所有缺失值应用这个函数。 12345678temp &lt;- algaetemp &lt;- temp[-manyNAs(temp),]fillPO4 &lt;- function(oP) &#123; if(is.na(oP)) return(NA) else return(42.897+1.293*oP)&#125;temp[is.na(temp$PO4), &quot;PO4&quot;] &lt;- sapply(temp[is.na(temp$PO4),&quot;PO4&quot;], fillPO4) 上面代码中创建了一个叫做fillPO4()的函数，该函数有一个参数来接受变量oPO4的值，通过这个值，根据模型计算对应的PO4的值。然后，将这个函数应用到变量PO4有缺失值的所有样本中。这个过程可以通过另外一个元函数sapply()来实现。函数sapply()的第一个参数是一个向量，第二个参数为一个函数，返回的结果是另一个向量，该向量和第一个参数有相同的长度，向量中的元素为sapply()中第一个向量中的每一个元素作为参数传递到第二个函数后返回的结果。这意味着sapply()的结果将是填补变量PO4缺失值的向量。 对线性关系的研究使我们能够填充一些新的缺失值。然而，还有几个观测值含有缺失值。可以试探着探索案例数据中含有缺失值的变量和名义变量之间的关系。这可以通过应用R添加包lattice中的函数来绘制条件直方图来进行。代码如下： 12temp &lt;- algaehistogram(~mxPH|season, data = temp) Pot: 上面代码绘制在不同季节变量mxPH的直方图。每个直方图对应于某个季节的观测值数据。注意，上图的季节顺序不是按照自然的时间顺序，可以转换数据框中因子季节标签的顺序，这样可以使图形中的季节值为自然顺序。代码如下： 123temp &lt;- algaetemp$season &lt;- factor(temp$season, levels = c(&quot;spring&quot;, &quot;summer&quot;, &quot;autumn&quot;, &quot;winter&quot;))histogram(~mxPH|season, data = temp) Pot: 由图看出，季节对mxPH的值没有显著的影响。 通过探索案例之间的相似性来填补缺失值 不同于探索数据集列（变量）之间的相关性，本节尝试使用行（观测值）之间的相似性来填补缺失值。我们可以使用这种方法来填补除去那两个含有太多NA值的样本外的其他缺失数据。 12temp &lt;- algaetemp &lt;- temp[-manyNAs(temp),] 本节所描述的方法假设如果两个水样是相似的，其中一个水样在某些变量上有缺失值，那么该缺失值很可能与另外一个水样的值是相似的。为了使用这种直观的方法，首先定义相似性的概念。相似性经常由描述观察值的多元度量空间的变量所定义。在文献中有许多度量相似性的指标，常用的就是欧氏距离。这个距离可以非正式地定义为任何两个案例的观测值之差的平方和。计算公式如下： 下面描述的方法将使用这种度量来寻找与任何含有缺失值的案例最相似的10个水样，并用它们来填补缺失值。我们考虑两种应用这些值的方法。第一种方法简单地计算着10个最相近的案例的中位数并用这个中位数来填补缺失值。如果缺失值是名义变量（本案例的algae数据不存在这种情况），我们采用这10个最相似数据中出现次数最多的值（众数）。第二种方法采用这些相似数据的加权均值。权重的大小随着距待填补缺失值的个案的距离增大而减小。这里用高斯核函数从距离获得权重。如果相邻个案距待填补缺失值的个案的距离为d，则它的值在加权平均重的权重为： 上面的方法可以通过本书添加包中的函数knnImputation()来实现。这个函数用一个欧氏距离的变种来找到距任何个案最近的k个邻居。这个变种的欧氏距离可以应用于同时含有名义变量和数值变量的数据集中。计算公式如下： 其中δi是变量i的两个值之间的距离，即 在计算距离时，一般要对数值变量进行标准化，即 下面说明如何使用knnImputation()函数。 12temp &lt;- algaetemp &lt;- knnImputation(temp, k -10) 吐过用中位数来填补缺失值，可以使用如下代码 12temp &lt;- algaetemp &lt;- knnImputation(temp, k = 10, meth = &quot;median&quot;) 总之，通过这些简单的操作，数据集中不在含有NA值（缺失值），为使用R的其他函数进行分析做好充分的准备工作。 后记 本节主要讨论了数据缺失值的处理，缺失值少的时候可以直接删除，但是当缺失值比较多的时候，然后会影响到整个数据集的正确性时，就要考虑用相关性或相似性来处理了。 本次博文是根据《数据挖掘与R语言(Luis Torgo著)》这本书的内容而写的笔记，本博文中所涉及的内容版权均归原作者所有。 下节讨论的主题是数据的建模。","categories":[{"name":"技能-修行-进步-R语言","slug":"技能-修行-进步-R语言","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-R%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"数据挖掘与R语言-案例学习","slug":"数据挖掘与R语言-案例学习","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8ER%E8%AF%AD%E8%A8%80-%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/"}]},{"title":"DMwR-note-01-预测海藻数量(一)","slug":"技能-修行-进步-R语言/DMwR-note-01-预测海藻数量(一)","date":"2014-10-23T07:53:18.000Z","updated":"2023-07-22T01:34:07.855Z","comments":true,"path":"2014/10/23/技能-修行-进步-R语言/DMwR-note-01-预测海藻数量(一)/","link":"","permalink":"http://example.com/2014/10/23/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-R%E8%AF%AD%E8%A8%80/DMwR-note-01-%E9%A2%84%E6%B5%8B%E6%B5%B7%E8%97%BB%E6%95%B0%E9%87%8F(%E4%B8%80)/","excerpt":"","text":"问题描述与目标 描述：有害藻类的高浓度会对河流生态环境造成强大的破坏，所以对有害藻类的数量进行预测对提高河流质量有很重要的意义。 目标：影响藻类繁殖的因素有什么特征。 数据说明 本案例有2个数据集：训练集和测试集 变量说明： 名义变量 season ： 季节 size : 河流规模 speed ： 流速 数值变量 mxPH : 最大PH值 mnO2 : 最小含氧量 Cl : 平均氯化物含量 NO3 ： 平均硝酸盐含量 NH4 ： 平均氨含量 oPO4 ： 平均正磷酸盐含量 PO4 ： 平均硝酸盐含量 Chla ： 平均叶绿素含量 UCI机器学习algae数据说明链接 数据加载到R 本例直接下载”DMwR”包，然后载入R空间，就可以得到一个algae的数据框。 123456789101112131415161718&gt; library(&quot;DMwR&quot;, lib.loc=&quot;e:/R/R-3.1.1/library&quot;)Loading required package: latticeLoading required package: grid&gt; head(algae) season size speed mxPH mnO2 Cl NO3 NH41 winter small medium 8.00 9.8 60.800 6.238 578.0002 spring small medium 8.35 8.0 57.750 1.288 370.0003 autumn small medium 8.10 11.4 40.020 5.330 346.6674 spring small medium 8.07 4.8 77.364 2.302 98.1825 autumn small medium 8.06 9.0 55.350 10.416 233.7006 winter small high 8.25 13.1 65.750 9.248 430.000 oPO4 PO4 Chla a1 a2 a3 a4 a5 a6 a71 105.000 170.000 50.0 0.0 0.0 0.0 0.0 34.2 8.3 0.02 428.750 558.750 1.3 1.4 7.6 4.8 1.9 6.7 0.0 2.13 125.667 187.057 15.6 3.3 53.6 1.9 0.0 0.0 0.0 9.74 61.182 138.700 1.4 3.1 41.0 18.9 0.0 1.4 0.0 1.45 58.222 97.580 10.5 9.2 2.9 7.5 0.0 7.5 4.1 1.06 18.250 56.667 28.4 15.1 14.6 1.4 0.0 22.5 12.6 2.9 数据框可以看做一种有列名称的矩阵或者表格，它是存储R数据表的一种理想的数据结构。函数head讲显示数据框的前6行。 数据可视化和摘要 探索性数据分析-summary在没有充分了解数据之前，我们可以首先了解一下数据的统计特性。R中提供了一个非常便利的函数summary，下面我们从探索性数据分析着手进行分析。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&gt; summary(algae) season size speed mxPH autumn:40 large :45 high :84 Min. :5.600 spring:53 medium:84 low :33 1st Qu.:7.700 summer:45 small :71 medium:83 Median :8.060 winter:62 Mean :8.012 3rd Qu.:8.400 Max. :9.700 NA&#x27;s :1 mnO2 Cl NO3 Min. : 1.500 Min. : 0.222 Min. : 0.050 1st Qu.: 7.725 1st Qu.: 10.981 1st Qu.: 1.296 Median : 9.800 Median : 32.730 Median : 2.675 Mean : 9.118 Mean : 43.636 Mean : 3.282 3rd Qu.:10.800 3rd Qu.: 57.824 3rd Qu.: 4.446 Max. :13.400 Max. :391.500 Max. :45.650 NA&#x27;s :2 NA&#x27;s :10 NA&#x27;s :2 NH4 oPO4 PO4 Min. : 5.00 Min. : 1.00 Min. : 1.00 1st Qu.: 38.33 1st Qu.: 15.70 1st Qu.: 41.38 Median : 103.17 Median : 40.15 Median :103.29 Mean : 501.30 Mean : 73.59 Mean :137.88 3rd Qu.: 226.95 3rd Qu.: 99.33 3rd Qu.:213.75 Max. :24064.00 Max. :564.60 Max. :771.60 NA&#x27;s :2 NA&#x27;s :2 NA&#x27;s :2 Chla a1 a2 Min. : 0.200 Min. : 0.00 Min. : 0.000 1st Qu.: 2.000 1st Qu.: 1.50 1st Qu.: 0.000 Median : 5.475 Median : 6.95 Median : 3.000 Mean : 13.971 Mean :16.92 Mean : 7.458 3rd Qu.: 18.308 3rd Qu.:24.80 3rd Qu.:11.375 Max. :110.456 Max. :89.80 Max. :72.600 NA&#x27;s :12 a3 a4 a5 Min. : 0.000 Min. : 0.000 Min. : 0.000 1st Qu.: 0.000 1st Qu.: 0.000 1st Qu.: 0.000 Median : 1.550 Median : 0.000 Median : 1.900 Mean : 4.309 Mean : 1.992 Mean : 5.064 3rd Qu.: 4.925 3rd Qu.: 2.400 3rd Qu.: 7.500 Max. :42.800 Max. :44.600 Max. :44.400 a6 a7 Min. : 0.000 Min. : 0.000 1st Qu.: 0.000 1st Qu.: 0.000 Median : 0.000 Median : 1.000 Mean : 5.964 Mean : 2.495 3rd Qu.: 6.925 3rd Qu.: 2.400 Max. :77.600 Max. :31.600 由结果可知，summary的作用是： 名义变量（R中用因子来表示）：统计数据中该变量某个值的频数。譬如，季节(season)当中秋季(autumn)出现的次数是40。 数值变量：summary为我们提供了均值、中位数、四分位数、极值等一系列的统计信息。譬如，最大的PH值(mxPH)当中，最小值是5.600，最大值是9.700，中位数是8.060，第一个四分位数(1st Qu)，即数据排序后25%的地方，是7.700，第三个四分位数(3st Qu)，即数据排序后75%的地方，是8.400，还有缺失值(NA)的个数是1.000。 数据分布状况-hist1&gt; hist(algae$mxPH, prob = T) plot： 该指令绘制变量mxPH的直方图。设置参数pro&#x3D;T，我们可以得到每个取值区间的概率，如果该参数设置为FALSE或者忽略该参数，它将给出频数。 由图中观察，变量mxPH的分布非常接近正态分布，它的值大部分聚集在该均值的周围。我们通过QQ图来检验该变量是否为正态分布。 12345678library(&quot;car&quot;, lib.loc=&quot;e:/R/R-3.1.1/library&quot;)par(mfrow=c(1,2))hist(algae$mxPH,prob = T, xlab=&#x27;&#x27;, main=&quot;Histogram of maximun pH value&quot;, ylim=0:1)lines(density(algae$mxPH, na.rm = T))rug(jitter(algae$mxPH))qqplot(algae$mxPH, main=&quot;Normal QQ plot of maximum pH&quot;)par(mfrow=c(1,1)) plot： 左图中的曲线是平滑版本的直方图，而在X轴上密密麻麻的小直线就是变量的实际值，利用它我们可以识别出离群点。譬如，小于6的两个奇异点。 右图是Q-Q图，图中黑色实线是正态分布的理论分位数，而散点图就是实际变量值的描述。另外，虚线组成的区域就是符合正态分布的95%置信区间的带状图。由图可知，变量有几个小的值明显在95%的置信区间之外，它们不服从正态分布。 数据分布状况的另一种展示-箱型图百度百科：箱型图 123boxplot(algae$oPO4, ylab = &quot;Orthophosphate(oPO4)&quot;)rug(jitter(algae$oPO4),side=2)abline(h = mean(algae$oPO4, na.rm = T), lty = 2) plot: lattice版本的箱图-bwplot条件绘图室依赖于某个特定因子的图形表示。因子是一个取值为有限集合的名义的变量。例如，对于变量size的不同取值，可以绘制变量a1的一组箱图。每个箱图是对应于变量size的某个特定值的水样子集。通过这些箱图可以研究名义变量size如何影响变量a1值的分布。 12library(lattice)bwplot(size ~ a1, data = algae, ylab=&#x27;River Size&#x27;, xlab=&#x27;Algal A1&#x27;) plot： 由上图可知，在规模较小的河流中，海藻a1的频率较高，这是很有用的信息。 Hmisc版本的箱图-bwplot分位箱图 1234library(Hmisc)bwplot(size ~ a1, data = algae, panel = panel.bpplot, probs=seq(.01,.49,by=.01), datadensity = TRUE, ylab = &#x27;River Size&#x27;, xlab = &#x27;Algal A1&#x27;) plot： 图中的点代表均值，而图中的竖线分别代表变量的第一个分位数、中位数和第三个分位数。图中的小竖线代表数据的真实取值，这些值的分布则由分位数图来体现。分位数箱图比上一个箱图提供了更多的信息。 我们可以得到以下结论：小型的河流有更高频率的海藻，但我们也观察到小型河流的海藻频率的分布比其他类型的河流频率的分布分散。 Hmisc版本的升级箱图-多个变量这种类型的条件绘图不局限于名义变量，也不局限于单个因子。只要先把连续变量“离散化”，也同样可以进行条件绘图。下面给出一个两个因子条件绘图的例子。考虑变量a3在给定变量season和变量mnO2下的条件绘图，变量mnO2是一个连续变量，绘图代码如下所示： 123minO2 &lt;- equal.count(na.omit(algae$mnO2),number=4, overlap=1/5)stripplot(season ~ a3|minO2, data = algae[!is.na(algae$mnO2),]) plot： 第一行调用equal.count()对连续变量mnO2离散化，把该变量转换为因子类型。参数number设置需要的区间个数，参数overlap设置两个区间之间的靠近边界的重合(这意味着某些观测值将被分配到相邻的区间中)。每个区间的观测值的个数相等。注意，变量algae$mnO2中含有NA值，所以上面的指令中没有直接应用该变量，否则会导致其后的绘图函数出错。函数na.omit()可以用来剔除向量中的任何NA值。 第二行调用绘图函数stripplot()，该函数是lattice包中的一个绘图函数，它根据另一个变量(这里是season)把变量的实际值绘制到不同的图形。这些区间按照从左到右，从下到上的顺序排列。即与左下方的图形相对应的是较小的mnO2值。变量mnO2中的NA值也会对图形的绘制产生影响。不能像绘制上图中那样直接应用参数data&#x3D;algae，而应该先剔除水样中变量mnO2含有NA值才行。 所以，下一次的笔记是针对缺失值的处理的。 后记 本次博文是根据《数据挖掘与R语言(Luis Torgo著)》这本书的内容而写的笔记，本博文中所涉及的内容版权均归原作者所有。 下节讨论的主题是数据缺失值的处理。","categories":[{"name":"技能-修行-进步-R语言","slug":"技能-修行-进步-R语言","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-R%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"数据挖掘与R语言-案例学习","slug":"数据挖掘与R语言-案例学习","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8ER%E8%AF%AD%E8%A8%80-%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/"}]},{"title":"正则表达式课堂笔记","slug":"ML/RegularExpression","date":"2014-10-18T13:18:17.000Z","updated":"2023-07-16T01:33:39.611Z","comments":true,"path":"2014/10/18/ML/RegularExpression/","link":"","permalink":"http://example.com/2014/10/18/ML/RegularExpression/","excerpt":"","text":"写在开头的话题：最近我在炼数成金社区上《R七种武器之网络爬虫RCurl》这一门课，然后三周的短课程在最后一周就提到了正则表达式。刚好我在大二的时候有听过传智播客的老师讲过，还有点印象，听起课来还蛮舒服的，倒也觉得这个东西还是挺重要的，它就像是一个模式，用以解决一类事情，如过滤邮箱地址等，故我现在做个笔记，以博客的形式。 对一个新事物学习的模式123(What is it)是什么?(How to do it)怎么做?(Why we need it)为什么? 正则表达式是什么？字符串的操作(R语言) 由于正则表达式是字符串的一些规则，所以我们首先温习一下字符串的基本操作 赋值 长度：nchar、字符串个数：length 替换：chartr(原始字符、替换字符、字符串) 连接：paste 参数sep，collapse 切割：strsplit 比较：&gt;、&lt;、&#x3D;&#x3D;、！&#x3D; 并集、交集、补集：union,intersect,setdiff 截取：sustr，substring 匹配：match，pmatch，charmatch 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# 赋值hello &lt;- &quot;Hello World!&quot;hello[1] &quot;Hello World!&quot;# 长度:ncharnchar(hello)[1] 12# 字符串个数:lengthhello2 &lt;- c(&quot;Hello&quot;,&quot;World!&quot;)length(hello2)[1] 2# 替换：chartr(原始字符、替换字符、字符串)# 原始字符和替换字符的长度一一对应，如例：e对1，l对2，o对3chartr(&quot;elo&quot;,&quot;123&quot;,hello)[1] &quot;H1223 W3r2d!&quot;hello[1] &quot;Hello World!&quot;# 连接：paste 参数sep，collapse# sep=&quot;&quot;表示字符串间无缝结合paste(&quot;Hello&quot;,&quot;World!&quot;,sep=&quot;&quot;)[1] &quot;HelloWorld!&quot;# 不设sep参数，默认字符串间是空格paste(&quot;Hello&quot;,&quot;World!&quot;)[1] &quot;Hello World!&quot;# 字符串切割strsplit# 第一个参数为要切割的字符串，第二个参数为字符串的切割值str=&quot;My/name/is/Tim/Chan!&quot;strsplit(str,&quot;/&quot;)[[1]][1] &quot;My&quot; &quot;name&quot; &quot;is&quot; &quot;Tim&quot; &quot;Chan!&quot;# 字符串的比较# 字符串的比较准则：从左到右逐个字符按照字母表顺序一一对比a = &quot;a&quot;b = &quot;b&quot;a &gt; b[1] FALSEb &gt; a[1] TRUEc = &quot;ab&quot;d = &quot;aaaaaaa&quot;c &gt;d[1] TRUEa == b[1] FALSE# 并集、交集、补集：union,intersect,setdiff# 高中集合知识温习，假设有a,b两个集合# 并集：所有ａ集合和所有ｂ集合的元素组成的新的集合，重复元素只出现一次# 交集：取既在a集合也在b集合的元素组成的集合# 补集：setdiff(a,b)，取在a中的元素但不在b中的元素组成的集合a = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)b = c(&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;)# 取并集union(a,b)[1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot;# 取交集intersect(a,b)[1] &quot;c&quot; &quot;d&quot; &quot;e&quot;# 取补集setdiff(a,b)[1] &quot;a&quot; &quot;b&quot;setdiff(b,a)[1] &quot;f&quot; &quot;g&quot;# 截取：substr,substring# substr(x, start, stop)# substring(text, first, last = 1000000L)# 准备字符串strs[1] &quot;abcdefghijklmnopqrstuvwxyz&quot;# 第一种比较，没有不同substr(strs,2,5)[1] &quot;bcde&quot;substring(strs,2,5)[1] &quot;bcde&quot;# 第二种比较# substring截取的字符串分布对应位置：2-5,3-6,4-7,5-8# 而substr只处理第一个位置2-5substring(strs,2:5,5:8)[1] &quot;bcde&quot; &quot;cdef&quot; &quot;defg&quot; &quot;efgh&quot;substr(strs,2:5,5:8)[1] &quot;bcde&quot;# 第三种比较，没有指定stop参数# substring默认为渠道字符串末尾# substr则报错substring(strs,2)[1] &quot;bcdefghijklmnopqrstuvwxyz&quot;substr(strs,2)Error in substr(strs, 2) : argument &quot;stop&quot; is missing, with no default# 匹配 match,pmatch,charmatch# matcht：完整匹配# pmatch，charmatch部分匹配 More info:百度百科 正则表达式的简单定义 正则表达式主要是对字符串操作的一系列规则。 正则表达式入门 :转义字符 .:除了换行以外的任意字符 ^:一行字符串的起始 $:一行字符串的结束 *:零个或多个字符 +:一个或多个字符 ?:零个或者一个字符 保留字符都需要在前面加上转义字符来表示 正则表达式怎么实现？为什么我们需要正则表达式？后记","categories":[{"name":"技能-修行-进步","slug":"技能-修行-进步","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"chp0_JSP","slug":"技能-修行-进步-JSP/chp0-JSP","date":"2014-07-06T14:46:10.000Z","updated":"2023-07-22T01:32:08.881Z","comments":true,"path":"2014/07/06/技能-修行-进步-JSP/chp0-JSP/","link":"","permalink":"http://example.com/2014/07/06/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/chp0-JSP/","excerpt":"","text":"JSP-Review-201407JSP的课本重点整理—《JSP应用教程（修订本）》石志国 11医用（1）班 整理者：陈玉庆 教授：陈国华 2014今年大题考背代码 page175 必背 page223 必背 page256 必背 9-25.jsp","categories":[{"name":"技能-修行-进步-JSP","slug":"技能-修行-进步-JSP","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/"}],"tags":[{"name":"JSP网页开发","slug":"JSP网页开发","permalink":"http://example.com/tags/JSP%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"}]},{"title":"chp9_JSP","slug":"技能-修行-进步-JSP/chp9-JSP","date":"2014-07-06T14:28:40.000Z","updated":"2023-07-22T01:33:10.084Z","comments":true,"path":"2014/07/06/技能-修行-进步-JSP/chp9-JSP/","link":"","permalink":"http://example.com/2014/07/06/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/chp9-JSP/","excerpt":"","text":"第九章 XML数据操作接口 9.1 XML(page233) XML：（eXtensible Markup Language）即可扩展的标记语言，可以定义语义标记，是元标记语言。 XML的结构：序言和文档元素 序言 XML声明、处理指令、注释 文档元素 元素、属性、文本内容、字符、实体引用、CDATA区","categories":[{"name":"技能-修行-进步-JSP","slug":"技能-修行-进步-JSP","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/"}],"tags":[{"name":"JSP网页开发","slug":"JSP网页开发","permalink":"http://example.com/tags/JSP%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"}]},{"title":"chp8_JSP","slug":"技能-修行-进步-JSP/chp8-JSP","date":"2014-07-06T14:27:37.000Z","updated":"2023-07-22T01:33:02.646Z","comments":true,"path":"2014/07/06/技能-修行-进步-JSP/chp8-JSP/","link":"","permalink":"http://example.com/2014/07/06/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/chp8-JSP/","excerpt":"","text":"第八章 Hibernate数据持久化技术 8.1.1 ORM的基本概念(page211) ORM （Object&#x2F;Relation Mapping）对象关系映射 作用 实现了Java应用中的对象到关系数据库中的表的自动的（和透明的）持久化，使用元数据描述对象鱼数据库间的映射。 ORM的优点 可以提高生产率，增加程序的可维护性，提供更好的性能。 8.1.2 POJO与PO的概念(page211) POJO (Pure Old Java Object或者Plain Ordinary Java Object，纯Java对象)，用来与数据库表建立映射的Java文件。 PO （Persistent Object，持久化对象），是在操作数据库时创建的对象。 有一下的数据库表 CREATE TABLE User ( id int, name varchar(20) ) 编写一个与之对应的持久化对象的类 public class User &#123; private long id; private String name; public void setId(long id)&#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; public long getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; &#125; 加强训练 给出以下数据库表（page217） use pubs; go CREATE TABLE Usertab ( userid int Identity primary key, username varchar(20), userpwd varchar(20) ) INSERT INTO usertab values('tom','tom'); 编写一个与之对应的持久化对象的类(page223) import java.io.Serializable; public class Usertab implements Serializable &#123; private Integer userid; private String username; private String userpwd; public Usertab()&#123;&#125; public Usertab(String username, String userpwd) &#123; this.username = username; this.userpwd = userpwd; &#125; public Integer getUserid() &#123; return userid; &#125; public void setUserid(Integer userid) &#123; this.userid = userid; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getUserpwd() &#123; return userpwd; &#125; public void setUserpwd(String userpwd) &#123; this.userpwd = userpwd; &#125; &#125;","categories":[{"name":"技能-修行-进步-JSP","slug":"技能-修行-进步-JSP","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/"}],"tags":[{"name":"JSP网页开发","slug":"JSP网页开发","permalink":"http://example.com/tags/JSP%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"}]},{"title":"chp7_JSP","slug":"技能-修行-进步-JSP/chp7-JSP","date":"2014-07-06T14:26:46.000Z","updated":"2023-07-22T01:32:55.624Z","comments":true,"path":"2014/07/06/技能-修行-进步-JSP/chp7-JSP/","link":"","permalink":"http://example.com/2014/07/06/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/chp7-JSP/","excerpt":"","text":"第七章 JDBC数据库开发接口 7.3.1 JDBC的四种类型(page171) JDBC-ODBC桥加ODBC驱动程序 本地API JDBC网络纯Java驱动程序 本地协议纯Java驱动程序 7.3.2 数据驱动程序(page172) 加载Oracle的JDBC驱动程序的语句为： Class.forName(“oracle.jdbc.driver.OracleDriver”); 使用JDBC-ODBC桥驱动程序的语句为： Class.forName(“sun.jdbc.odbc.JdbcOdbcDriver”); 加载Sql2005驱动程序的语句为： Class.forName(“com.microsoft.jdbc.sqlserver.SQLServerDriver”); 加载MySQL驱动下次语句为： Class.forName(“com.mysql.jdbc.Driver”); 7.3.3 Connection对象(page172) import java.sql.*; public class DB &#123; public static Connection getConn() &#123; Connection conn = null; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://localhost/shopping?user=root&password=123456\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; public static PreparedStatement prepare(Connection conn, String sql) &#123; PreparedStatement pstmt = null; try &#123; if(conn != null) &#123; pstmt = conn.prepareStatement(sql); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return pstmt; &#125; public static PreparedStatement prepare(Connection conn, String sql, int autoGenereatedKeys) &#123; PreparedStatement pstmt = null; try &#123; if(conn != null) &#123; pstmt = conn.prepareStatement(sql, autoGenereatedKeys); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return pstmt; &#125; public static Statement getStatement(Connection conn) &#123; Statement stmt = null; try &#123; if(conn != null) &#123; stmt = conn.createStatement(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return stmt; &#125; /* public static ResultSet getResultSet(Connection conn, String sql) &#123; Statement stmt = getStatement(conn); ResultSet rs = getResultSet(stmt, sql); close(stmt); return rs; &#125; */ public static ResultSet getResultSet(Statement stmt, String sql) &#123; ResultSet rs = null; try &#123; if(stmt != null) &#123; rs = stmt.executeQuery(sql); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return rs; &#125; public static void executeUpdate(Statement stmt, String sql) &#123; try &#123; if(stmt != null) &#123; stmt.executeUpdate(sql); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void close(Connection conn) &#123; try &#123; if(conn != null) &#123; conn.close(); conn = null; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void close(Statement stmt) &#123; try &#123; if(stmt != null) &#123; stmt.close(); stmt = null; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;","categories":[{"name":"技能-修行-进步-JSP","slug":"技能-修行-进步-JSP","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/"}],"tags":[{"name":"JSP网页开发","slug":"JSP网页开发","permalink":"http://example.com/tags/JSP%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"}]},{"title":"chp6_JSP","slug":"技能-修行-进步-JSP/chp6-JSP","date":"2014-07-06T14:25:23.000Z","updated":"2023-07-22T01:32:49.142Z","comments":true,"path":"2014/07/06/技能-修行-进步-JSP/chp6-JSP/","link":"","permalink":"http://example.com/2014/07/06/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/chp6-JSP/","excerpt":"","text":"第六章 JSP经典开发技巧 6.1.2 三种网页对话框(page115) 使用window.open打开的网页 使用Web模式对话框 使用Web非模式对话框 三种对话框的区别是：利用window.open打开的页面和其他的窗口一样，可以在几个窗口之间切换；模式对话框不可以和其他窗口切换焦点，只能是当前窗口。非模式对话框可以和其他对话框切换焦点，但是永远在屏幕的最前面。 6.7 面向对象设计模式(page150) 注：本节老师没划重点，但在课上有讲到，高分者可详看。 Factory模式 Singleton模式 mvc架构模式","categories":[{"name":"技能-修行-进步-JSP","slug":"技能-修行-进步-JSP","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/"}],"tags":[{"name":"JSP网页开发","slug":"JSP网页开发","permalink":"http://example.com/tags/JSP%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"}]},{"title":"chp5_JSP","slug":"技能-修行-进步-JSP/chp5-JSP","date":"2014-07-06T14:24:19.000Z","updated":"2023-07-22T01:32:42.912Z","comments":true,"path":"2014/07/06/技能-修行-进步-JSP/chp5-JSP/","link":"","permalink":"http://example.com/2014/07/06/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/chp5-JSP/","excerpt":"","text":"第五章 JavaBean编程技术 5.1.3 JavaBean简介(page98) JavaBean的4个特性：独立性，可重用性，在可视化开发工具中使用，状态可以保存。 5.2.1 JavaBean的特点(page98) 编写JavaBean就是编写一个Java类，一个完整JavaBean在类的命名上需要遵守以下4点： 如果类的成员变量的名字是XXX，那么未来更改或获取成员变量的值，在类中使用以下两个方法。 getXXX()：用来获取属性XXX setXXX()：用来修改属性XXX 对于boolean类型的成员变量，允许使用is代替get和set。 类中方法的访问属性必须是public。 类中如果有构造方法，那么这个构造方法也是public的，并且是无参数的。","categories":[{"name":"技能-修行-进步-JSP","slug":"技能-修行-进步-JSP","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/"}],"tags":[{"name":"JSP网页开发","slug":"JSP网页开发","permalink":"http://example.com/tags/JSP%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"}]},{"title":"chp4_JSP","slug":"技能-修行-进步-JSP/chp4-JSP","date":"2014-07-06T14:23:13.000Z","updated":"2023-07-22T01:32:36.176Z","comments":true,"path":"2014/07/06/技能-修行-进步-JSP/chp4-JSP/","link":"","permalink":"http://example.com/2014/07/06/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/chp4-JSP/","excerpt":"","text":"第四章 JSP编程技术(重点) JSP的主要内容包括：3大编译指令，7大操作指令(课本6个)和9大隐含对象(课本7个)。 4.2 JSP页面结构(page68) JSP的页面主要包含3种元素：编译指令，操作指令和JSP代码。 编译指令 编译指令告诉JSP解释引擎，需要在编译时做什么动作，例如引入其他类，设置JSP页面使用什么语言编码等。 操作指令 操作指令则是在JSP页面被请求时动态执行的，比如可以根据某个条件动态跳转到另一个页面。 JSP代码 JSP代码指我们嵌入JSP页面中的Java代码，分两种：变量和方法的声明，使用“&lt;%!”和“%&gt;”标记，另一种是常用到的用“&lt;%”和“%&gt;”包含的JSP代码块。 4.3 编译指令(page68) JSP指令的一般形式：**&lt;%@ 指令名 属性1 &#x3D; “value1” %&gt;，&lt;%@ 指令名 属性2 &#x3D; “value2” %&gt;，多个指令也可以合并写为：&lt;%@ 指令名 属性1 &#x3D; “value1” 属性2 &#x3D; “value2” %&gt;** JSP的3大编译指令：page指令，include指令，taglib指令(不考)。 page指令：page 指令是最复杂的JSP指令，它的主要功能为设定整个JSP 网页的属性和相关功能。 属性 定义 language=“语言\" 主要指定JSP 容器 要用什么语言来编译JSP 网页。JSP 1.2 规范中指出，目前只可以使用Java 语言，不过未来不排除增加其他语言，如C、C++、Perl 等等。默认值为Java语言 extends=“基类名\" 主要定义此JSP 网页产生的Servlet 是继承哪个父类 import= \"importList\" 定义此JSP 网页可以使用哪些Java类库 errorPage=\"error_url\" 表示如果发生异常错误时，网页会被重新指向指定的URL isErrorPage=\"true | false\" 表示此JSP Page 是否为专门处理错误和异常的网页 contentType = \"ctinfo\" 表示MIME 类型和JSP 网页的编码方式，其作用相当于HttpServletResponse接口的setContentType()方法 isThreadSafe=\"true | false\" 告诉JSP 容器，此JSP 网页是否能同时处理多个请求。默认值为true，如果此值设为false， 转义生成的Servlet会实现SingleThreadModel接口。 &lt;tr&gt; &lt;td&gt;session=&quot;true | false&quot;&lt;/td&gt; &lt;td&gt;决定此JSP 网页是否可以使用session 对象。默认值为true&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; include指令(page70):用来指定怎样把另一个文件包含到当前的JSP页面中，这个文件可以是普通的文本文件，也可以是JSP页面。例如：**&lt;%@include file&#x3D;”login.htm”%&gt;**。 使用include指令，可以实现JSP页面的模块化，使JSP的开发和维护变得非常简单。 4.4 操作指令(page71) 操作指令和编译指令不同，编译指令是通知Servlet引擎的处理消息，而操作指令只是运行时的动作。编译指令在将JSP编译成Servlet时起作用；而操作指令通常可替换成JSP脚本，它只是JSP脚本的标准化写法。 JSP操作指令主要有如下的6个： jsp:include：用于引入静态和动态的资源，功能和include指令相同。格式：&lt;jsp:include page&#x3D;”test.htm”&#x2F;&gt; jsp:forward：执行页面转向，将请求的处理转发到下一个页面。格式：&lt;jsp:forward page&#x3D;”test.htm”&#x2F;&gt; jsp:param：用于传递参数，必须与其他支持参数的标签一起使用。 1234&lt;jsp:forward page=&quot;mypage.jsp&quot;&gt; &lt;jsp:param name=&quot;param1&quot; value=&quot;value1&quot;/&gt; &lt;jsp:param name=&quot;param2&quot; value=&quot;value2&quot;/&gt; &lt;/jsp:forward&gt; jsp:useBean：创建一个JavaBean的实例。 jsp:setProperty：设置JavaBean实例的属性值。 jsp:getProperty：输出JavaBean实例的属性值 JSP的操作指令均以“&#x2F;&gt;”结束。 4.5 JSP代码(page72) 变量和方法(略) 代码块(略) 4.6 7大隐含对象(page75) 隐含对象：有些对象不用声明就可以在JSP页面的脚本代码和表达式中随意使用，这些缺省对象统称为隐含对象。 7大隐含对象： out 页面输出对象； request 请求对象； response 响应对象； application 应用对象； session 会话对象； cookie 对象； pageContext 对象； 对象名 对象类型 作用域 定义 out JspWriter page 一个输出的缓冲流，给浏览器的客户返回内容 request HttpServletRequest request 用来得到客户端的信息 response HttpServletResponse page 处理服务器端对客户端的一些响应 application ServletContext application 用来保存网站的一些全局变量 session HttpSession session 用来保存单个用户访问时的一些信息 cookie Cookie 不清楚呢 将服务器端的一些信息写到客户端的浏览器中 pageContext PageContext page 提供了访问和放置页面中共享数据的方式 4.7 response对象(page76) 网页转向：sendRedirect()方法，跳转到其他页面 格式：response.sendRedirect(“URL 地址”); 与jsp:forward的最大区别 使用jsp:forward只能在本站内跳转，但用response.sendRedirect(“URL 地址”)可以跳转到任何一个地址的页面。 其他(略，自己看书) 4.8 request对象(page78) 自己看书","categories":[{"name":"技能-修行-进步-JSP","slug":"技能-修行-进步-JSP","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/"}],"tags":[{"name":"JSP网页开发","slug":"JSP网页开发","permalink":"http://example.com/tags/JSP%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"}]},{"title":"chp3_JSP","slug":"技能-修行-进步-JSP/chp3-JSP","date":"2014-07-06T14:21:33.000Z","updated":"2023-07-22T01:32:26.161Z","comments":true,"path":"2014/07/06/技能-修行-进步-JSP/chp3-JSP/","link":"","permalink":"http://example.com/2014/07/06/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/chp3-JSP/","excerpt":"","text":"第三章 Servlet编程技术 3.1.1 Servlet概念(page45) Servlet Servlet是一个标准的Java类，它的特殊之处是可以处理HTTP请求。 JSP与Servlet有什么关系？ JSP是以另一种方式实现的Servlet，Servlet是JSP的早期版本，在JSP中，更加注重页面的表现，而在Servlet中则更注重业务逻辑的实现。 3.1.2 Servlet的生命周期(page45) init()方法：服务器初始化Servlet 该方法描述为：public void init(ServletConfig config)throws ServletException 当Servlet第一次被加载时，服务器调用init()方法初始化一个Servlet对象 service()方法:初始化完毕，Servlet对象调用该方法响应客户端请求 该方法描述为：public void service(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException service()方法可以被多次调用，每次用户请求都导致service()方法被调用，调用过程运行在不同的进程中，互不干扰 destroy()方法：调用该方法消灭Servlet对象 该方法描述为：public void destroy()当Servlet引擎终止服务时，比如关闭服务器等，destroy()方法会被执行，销毁Servlet对象。 总结：在整个Servlet的生命周期中，init()方法和destroy()方法都只被调用一次， 而service()方法被调用多次。 3.3.2 GenericServlet类和HttpServlet类 (page51) 有上述继承树可知：GenericServlet是父类，它实现了Servlet接口中的service()方法，但它还是一个抽象方法，所有子类都应该实现这个方法。HttpServlet继承了GenericServlet类，自然也要实现service()方法。 service()方法 HttpServlet类有两种形式的service()方法：public 和 protected，描述如下： public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException 当包容器为一个Servlet收到一个请求时，这个方法的调用顺序是： 包容器调用public的service()方法； 在把参数分布转换为HttpServletRequest和HttpServletResponse后，public的service()方法调用protected的service()方法； 根据HTTP请求方法的类型，protected的service()调用doXXX()方法之一。 #####注意：常用的doXXX()方法有doGet()和doPost()，我们编写的Servlet类继承HttpServlet之后，只需要覆盖doGet()或doPost()方法即可，不需要覆盖service()方法。","categories":[{"name":"技能-修行-进步-JSP","slug":"技能-修行-进步-JSP","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/"}],"tags":[{"name":"JSP网页开发","slug":"JSP网页开发","permalink":"http://example.com/tags/JSP%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"}]},{"title":"chp2_JSP","slug":"技能-修行-进步-JSP/chp2-JSP","date":"2014-07-06T14:19:41.000Z","updated":"2023-07-22T01:32:20.266Z","comments":true,"path":"2014/07/06/技能-修行-进步-JSP/chp2-JSP/","link":"","permalink":"http://example.com/2014/07/06/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/chp2-JSP/","excerpt":"","text":"第二章 2.3 安装和配置Tomcat(page15) Tomcat 服务器的默认端口是 8080 访问Tomcat的默认路径是：http://localhost:8080 2.3.1 配置Tomcat(page18) 更改服务端口：在Tomcat下打开conf文件夹找到server.xml文件用记事本打开在**&lt; connector port &#x3D;”8080” &gt;**中把8080更改即可 2.3.2 测试第一个JSP页面(page20) 第一段JSP程序（Hello World） &lt;%****out.print(“Hello World”);****%&gt; 对这个程序做简单的说明： 所有的JSP脚本程序都必须用“&lt;%”和“%&gt;”括起来； 可以用out对象的print方法输出信息，输出的字符需要用双引号括起来； 每一条JSP语句的末尾用分号结束。","categories":[{"name":"技能-修行-进步-JSP","slug":"技能-修行-进步-JSP","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/"}],"tags":[{"name":"JSP网页开发","slug":"JSP网页开发","permalink":"http://example.com/tags/JSP%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"}]},{"title":"chp1_JSP","slug":"技能-修行-进步-JSP/chp1-JSP","date":"2014-07-06T14:13:19.000Z","updated":"2023-07-22T01:32:14.953Z","comments":true,"path":"2014/07/06/技能-修行-进步-JSP/chp1-JSP/","link":"","permalink":"http://example.com/2014/07/06/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/chp1-JSP/","excerpt":"","text":"第一章 1.3.3 JSP 概述(page5) jsp的最大优点是：开放的，跨平台的结构，它可以运行在所有的服务器系统上。 JSP与ASP的区别： 每次访问asp文件，服务器都要将该文件解释一遍，然后将标准的HTML代码发送到客户端； 而JSP有所不同，当第一次访问JSP文件时，服务器先将JSP编译成二进制码，以后再访问的时候，就直接访问二进制码，这样大大提高了执行的效率。 总结：JSP一次编译，多次运行；而ASP每次运行需要每次编译。 JSP的优点如下： 多平台的支持，可以再所有的服务器操作系统上运行。 编译后执行，能够大大提高执行效率。 JSP采用Java技术，Java应用比较普遍，因此学习起来比较容易。 JSP是J2EE十三种核心技术中的一种，可以和其他核心技术共同建立企业应用。 JSP的缺点如下： 开发环境相对ASP来说，比较复杂。需要先安装JDK，然后安装Web服务器。 相对ASP的VBsript脚本语言，Java语言学起来稍微复杂。 1.4.3 J2EE体系概述(page6) J2EE的任务是提供一个平台独立的，便携式，多用户，安全及标准的企业级平台。 J2EE的13种核心技术包括（不全，常见的）： JDBC (Java Database Connectivity, Java数据库连接) EJB （Enterprise Java Bean，企业JavaBean） JSP （Java Server Pages, Java服务器端网页） Servlet （服务器端小程序） XML （eXtensible Markup Language） JavaMail (Java邮件) JTS （Java Transaction Service, Java事务服务） 。。。 1.5.1 N层开发框架（page8） 理想的J2EE体系包括6个层：表示，应用，服务，域，连通性和持续化。 这些层横跨客户机和服务器，而它们逻辑上划分为Web容器，EJB容器和数据库，如图1-7所示：![](/img/jsp_review/1-7.jpg)","categories":[{"name":"技能-修行-进步-JSP","slug":"技能-修行-进步-JSP","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/"}],"tags":[{"name":"JSP网页开发","slug":"JSP网页开发","permalink":"http://example.com/tags/JSP%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"}]},{"title":"Linux_develop_C-我的第一篇博客","slug":"小而美-工具/Linux-develop-C","date":"2012-06-27T04:46:16.000Z","updated":"2024-03-16T15:23:16.303Z","comments":true,"path":"2012/06/27/小而美-工具/Linux-develop-C/","link":"","permalink":"http://example.com/2012/06/27/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/Linux-develop-C/","excerpt":"","text":"目录在linux下编写C程序，必须要学会Vi编辑器的使用 我的linux界面： 桌面单击右键，选择终端打开 便可进入终端界面 输入vi，便可以查看vi的版本信息，同时进入vi编辑器 因为当前文件未命名，故在编辑完成后无法保存，我们重新回到开始界面 输入vi a.c ，然后回车（表明进入vi编辑器的同时创建一个文件名为a.c的新文件） 输入i进入插入模式，左下角会出现“插入”2字（否则不能进行编辑）： 然后敲代码，例如： 代码输入完毕后，按esc键进入命令模式（左下角的“插入”2字会消失）： 此时输入冒号”:”,接着可以输入2种命令（2选1）wq（保存，退出）；q!(退出不保存)。 因为我们输入的是”:wq”，即保存并退出。 按回车键后便回到开始界面，且在桌面上生成了a.c的文件 编译C程序 编译C程序需要gcc编译器，我们可以输入gcc -v查看当前系统的gcc编译器信息 ok，一切正常，可以对a.c文件进行编译了，接着输入gcc a.c,若什么也不提示，恭喜你编译成功了，且在桌面上生成了一个a.out文件。 运行a.c文件 在终端输入.&#x2F;a.c点（不可漏），反斜杠，加文件名)，回车键后便可以看到结果： I love u！！！ 以上就是在Linux下编写C程序的简单步骤。希望能帮到你！Thanks for your reading !谢谢！！！","categories":[{"name":"小而美-工具","slug":"小而美-工具","permalink":"http://example.com/categories/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C开发","slug":"C开发","permalink":"http://example.com/tags/C%E5%BC%80%E5%8F%91/"}]}],"categories":[{"name":"认知-修行-平衡","slug":"认知-修行-平衡","permalink":"http://example.com/categories/%E8%AE%A4%E7%9F%A5-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"},{"name":"技能-修行-进步-Web3","slug":"技能-修行-进步-Web3","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Web3/"},{"name":"技能-修行-平衡","slug":"技能-修行-平衡","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E5%B9%B3%E8%A1%A1/"},{"name":"技能-修行-塔罗","slug":"技能-修行-塔罗","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E5%A1%94%E7%BD%97/"},{"name":"技能-修行-进步-影视图像","slug":"技能-修行-进步-影视图像","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-%E5%BD%B1%E8%A7%86%E5%9B%BE%E5%83%8F/"},{"name":"小而美-工具","slug":"小而美-工具","permalink":"http://example.com/categories/%E5%B0%8F%E8%80%8C%E7%BE%8E-%E5%B7%A5%E5%85%B7/"},{"name":"技能-修行-进步-AI助手","slug":"技能-修行-进步-AI助手","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-AI%E5%8A%A9%E6%89%8B/"},{"name":"技能-修行-进步","slug":"技能-修行-进步","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5/"},{"name":"技能-修行-进步-MLOps","slug":"技能-修行-进步-MLOps","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-MLOps/"},{"name":"技能-修行-进步-ML","slug":"技能-修行-进步-ML","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-ML/"},{"name":"技能-修行-进步-R语言","slug":"技能-修行-进步-R语言","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-R%E8%AF%AD%E8%A8%80/"},{"name":"毕业设计系列","slug":"毕业设计系列","permalink":"http://example.com/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%97/"},{"name":"技能-修行-进步-Django","slug":"技能-修行-进步-Django","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-Django/"},{"name":"技能-修行-进步-JSP","slug":"技能-修行-进步-JSP","permalink":"http://example.com/categories/%E6%8A%80%E8%83%BD-%E4%BF%AE%E8%A1%8C-%E8%BF%9B%E6%AD%A5-JSP/"}],"tags":[{"name":"炼金术士","slug":"炼金术士","permalink":"http://example.com/tags/%E7%82%BC%E9%87%91%E6%9C%AF%E5%A3%AB/"},{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"佛学","slug":"佛学","permalink":"http://example.com/tags/%E4%BD%9B%E5%AD%A6/"},{"name":"chainlink","slug":"chainlink","permalink":"http://example.com/tags/chainlink/"},{"name":"建立系统","slug":"建立系统","permalink":"http://example.com/tags/%E5%BB%BA%E7%AB%8B%E7%B3%BB%E7%BB%9F/"},{"name":"solidity","slug":"solidity","permalink":"http://example.com/tags/solidity/"},{"name":"塔罗牌","slug":"塔罗牌","permalink":"http://example.com/tags/%E5%A1%94%E7%BD%97%E7%89%8C/"},{"name":"openzeppelin","slug":"openzeppelin","permalink":"http://example.com/tags/openzeppelin/"},{"name":"摄影","slug":"摄影","permalink":"http://example.com/tags/%E6%91%84%E5%BD%B1/"},{"name":"视觉语言","slug":"视觉语言","permalink":"http://example.com/tags/%E8%A7%86%E8%A7%89%E8%AF%AD%E8%A8%80/"},{"name":"影像","slug":"影像","permalink":"http://example.com/tags/%E5%BD%B1%E5%83%8F/"},{"name":"自愈, 情绪管理","slug":"自愈-情绪管理","permalink":"http://example.com/tags/%E8%87%AA%E6%84%88-%E6%83%85%E7%BB%AA%E7%AE%A1%E7%90%86/"},{"name":"EVM","slug":"EVM","permalink":"http://example.com/tags/EVM/"},{"name":"从历史中进行学习","slug":"从历史中进行学习","permalink":"http://example.com/tags/%E4%BB%8E%E5%8E%86%E5%8F%B2%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%AD%A6%E4%B9%A0/"},{"name":"成瘾戒瘾","slug":"成瘾戒瘾","permalink":"http://example.com/tags/%E6%88%90%E7%98%BE%E6%88%92%E7%98%BE/"},{"name":"web3基础设施","slug":"web3基础设施","permalink":"http://example.com/tags/web3%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"},{"name":"心想事成","slug":"心想事成","permalink":"http://example.com/tags/%E5%BF%83%E6%83%B3%E4%BA%8B%E6%88%90/"},{"name":"Steven Jobs","slug":"Steven-Jobs","permalink":"http://example.com/tags/Steven-Jobs/"},{"name":"GPT视频总结","slug":"GPT视频总结","permalink":"http://example.com/tags/GPT%E8%A7%86%E9%A2%91%E6%80%BB%E7%BB%93/"},{"name":"Ray Dalio","slug":"Ray-Dalio","permalink":"http://example.com/tags/Ray-Dalio/"},{"name":"活出真我","slug":"活出真我","permalink":"http://example.com/tags/%E6%B4%BB%E5%87%BA%E7%9C%9F%E6%88%91/"},{"name":"markdown用法","slug":"markdown用法","permalink":"http://example.com/tags/markdown%E7%94%A8%E6%B3%95/"},{"name":"系统思考","slug":"系统思考","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83/"},{"name":"技术商人","slug":"技术商人","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF%E5%95%86%E4%BA%BA/"},{"name":"人生建议","slug":"人生建议","permalink":"http://example.com/tags/%E4%BA%BA%E7%94%9F%E5%BB%BA%E8%AE%AE/"},{"name":"方法论","slug":"方法论","permalink":"http://example.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"name":"人类简史","slug":"人类简史","permalink":"http://example.com/tags/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/"},{"name":"发展周期","slug":"发展周期","permalink":"http://example.com/tags/%E5%8F%91%E5%B1%95%E5%91%A8%E6%9C%9F/"},{"name":"中国历史路线","slug":"中国历史路线","permalink":"http://example.com/tags/%E4%B8%AD%E5%9B%BD%E5%8E%86%E5%8F%B2%E8%B7%AF%E7%BA%BF/"},{"name":"人性","slug":"人性","permalink":"http://example.com/tags/%E4%BA%BA%E6%80%A7/"},{"name":"GPT","slug":"GPT","permalink":"http://example.com/tags/GPT/"},{"name":"monica-AI","slug":"monica-AI","permalink":"http://example.com/tags/monica-AI/"},{"name":"conda-docker-git-vim-ssr","slug":"conda-docker-git-vim-ssr","permalink":"http://example.com/tags/conda-docker-git-vim-ssr/"},{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"FLOPs","slug":"FLOPs","permalink":"http://example.com/tags/FLOPs/"},{"name":"命理","slug":"命理","permalink":"http://example.com/tags/%E5%91%BD%E7%90%86/"},{"name":"MLOps","slug":"MLOps","permalink":"http://example.com/tags/MLOps/"},{"name":"从历史学习经验","slug":"从历史学习经验","permalink":"http://example.com/tags/%E4%BB%8E%E5%8E%86%E5%8F%B2%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/"},{"name":"下载工具","slug":"下载工具","permalink":"http://example.com/tags/%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/"},{"name":"系统, 方法论","slug":"系统-方法论","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F-%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"name":"物体检测-metrics","slug":"物体检测-metrics","permalink":"http://example.com/tags/%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8B-metrics/"},{"name":"人工智能的底层逻辑","slug":"人工智能的底层逻辑","permalink":"http://example.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"},{"name":"物体检测","slug":"物体检测","permalink":"http://example.com/tags/%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8B/"},{"name":"yolov3","slug":"yolov3","permalink":"http://example.com/tags/yolov3/"},{"name":"darknet","slug":"darknet","permalink":"http://example.com/tags/darknet/"},{"name":"mtcnn","slug":"mtcnn","permalink":"http://example.com/tags/mtcnn/"},{"name":"RK3399","slug":"RK3399","permalink":"http://example.com/tags/RK3399/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://example.com/tags/tensorflow/"},{"name":"目标检测","slug":"目标检测","permalink":"http://example.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"linux shell命令","slug":"linux-shell命令","permalink":"http://example.com/tags/linux-shell%E5%91%BD%E4%BB%A4/"},{"name":"object detection","slug":"object-detection","permalink":"http://example.com/tags/object-detection/"},{"name":"nms","slug":"nms","permalink":"http://example.com/tags/nms/"},{"name":"iou","slug":"iou","permalink":"http://example.com/tags/iou/"},{"name":"soft-nms","slug":"soft-nms","permalink":"http://example.com/tags/soft-nms/"},{"name":"Tree","slug":"Tree","permalink":"http://example.com/tags/Tree/"},{"name":"binary tree","slug":"binary-tree","permalink":"http://example.com/tags/binary-tree/"},{"name":"binary search tree","slug":"binary-search-tree","permalink":"http://example.com/tags/binary-search-tree/"},{"name":"pre-order","slug":"pre-order","permalink":"http://example.com/tags/pre-order/"},{"name":"in-order","slug":"in-order","permalink":"http://example.com/tags/in-order/"},{"name":"post-order","slug":"post-order","permalink":"http://example.com/tags/post-order/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://example.com/tags/blog/"},{"name":"rebuild","slug":"rebuild","permalink":"http://example.com/tags/rebuild/"},{"name":"myself","slug":"myself","permalink":"http://example.com/tags/myself/"},{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"light framwork","slug":"light-framwork","permalink":"http://example.com/tags/light-framwork/"},{"name":"convolution","slug":"convolution","permalink":"http://example.com/tags/convolution/"},{"name":"interview","slug":"interview","permalink":"http://example.com/tags/interview/"},{"name":"computer vision","slug":"computer-vision","permalink":"http://example.com/tags/computer-vision/"},{"name":"translation","slug":"translation","permalink":"http://example.com/tags/translation/"},{"name":"物体识别","slug":"物体识别","permalink":"http://example.com/tags/%E7%89%A9%E4%BD%93%E8%AF%86%E5%88%AB/"},{"name":"Faster-RCNN","slug":"Faster-RCNN","permalink":"http://example.com/tags/Faster-RCNN/"},{"name":"RCNN","slug":"RCNN","permalink":"http://example.com/tags/RCNN/"},{"name":"YOLO","slug":"YOLO","permalink":"http://example.com/tags/YOLO/"},{"name":"openpose","slug":"openpose","permalink":"http://example.com/tags/openpose/"},{"name":"pyopenpose","slug":"pyopenpose","permalink":"http://example.com/tags/pyopenpose/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"可视化证明","slug":"可视化证明","permalink":"http://example.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96%E8%AF%81%E6%98%8E/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"循环神经网络","slug":"循环神经网络","permalink":"http://example.com/tags/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"Tensorflow tutorial","slug":"Tensorflow-tutorial","permalink":"http://example.com/tags/Tensorflow-tutorial/"},{"name":"ML","slug":"ML","permalink":"http://example.com/tags/ML/"},{"name":"DL","slug":"DL","permalink":"http://example.com/tags/DL/"},{"name":"KNN","slug":"KNN","permalink":"http://example.com/tags/KNN/"},{"name":"Classification","slug":"Classification","permalink":"http://example.com/tags/Classification/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"手写数字SVM","slug":"手写数字SVM","permalink":"http://example.com/tags/%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97SVM/"},{"name":"SVM入门","slug":"SVM入门","permalink":"http://example.com/tags/SVM%E5%85%A5%E9%97%A8/"},{"name":"10大基础实用算法","slug":"10大基础实用算法","permalink":"http://example.com/tags/10%E5%A4%A7%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%94%A8%E7%AE%97%E6%B3%95/"},{"name":"Django-Models","slug":"Django-Models","permalink":"http://example.com/tags/Django-Models/"},{"name":"SVM","slug":"SVM","permalink":"http://example.com/tags/SVM/"},{"name":"字符串操作","slug":"字符串操作","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"name":"手写数字识别","slug":"手写数字识别","permalink":"http://example.com/tags/%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"},{"name":"Kernel Support Vector Machine","slug":"Kernel-Support-Vector-Machine","permalink":"http://example.com/tags/Kernel-Support-Vector-Machine/"},{"name":"最小二乘法 论文翻译","slug":"最小二乘法-论文翻译","permalink":"http://example.com/tags/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95-%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"单例设计模式","slug":"单例设计模式","permalink":"http://example.com/tags/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"R Tutorial","slug":"R-Tutorial","permalink":"http://example.com/tags/R-Tutorial/"},{"name":"概率论基本概念","slug":"概率论基本概念","permalink":"http://example.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"name":"Aprior Algorithm","slug":"Aprior-Algorithm","permalink":"http://example.com/tags/Aprior-Algorithm/"},{"name":"数据挖掘与R语言-案例学习","slug":"数据挖掘与R语言-案例学习","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8ER%E8%AF%AD%E8%A8%80-%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"JSP网页开发","slug":"JSP网页开发","permalink":"http://example.com/tags/JSP%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91/"},{"name":"C开发","slug":"C开发","permalink":"http://example.com/tags/C%E5%BC%80%E5%8F%91/"}]}